declare namespace ts {
const diagnosticMap: WeakMap<Program, Diagnostic[]>;

interface PluginConfig {
    [x: string]: any;
    /**
     * Language Server TypeScript Plugin name
     */
    name?: string;
    /**
     * Path to transformer or transformer module name
     */
    transform?: string;
    /**
     * tsconfig.json file (for transformer)
     */
    tsConfig?: string;
    /**
     * The optional name of the exported transform plugin in the transform module.
     */
    import?: string;
    /**
     * Plugin entry point format type, default is program
     */
    type?: 'ls' | 'program' | 'config' | 'checker' | 'raw' | 'compilerOptions';
    /**
     * Apply transformer after internal TypeScript transformers
     */
    after?: boolean;
    /**
     * Apply transformer on d.ts files TS2.9+
     */
    afterDeclarations?: boolean;
    /**
     * Transform *Program* instance (alters during createProgram()) (`type`, `after`, & `afterDeclarations` settings will
     * not apply) Entry point must be (program: Program, host?: CompilerHost) => Program
     */
    transformProgram?: boolean;
    /**
     * Alias to transformProgram
     * @deprecated
     */
    beforeEmit?: boolean;
}
type TransformerList = Required<CustomTransformers>;
type TransformerPlugin = TransformerBasePlugin | TransformerFactory<SourceFile>;
type PluginFactory = LSPattern | ProgramPattern | ConfigPattern | CompilerOptionsPattern | TypeCheckerPattern | RawPattern;
interface TransformerBasePlugin {
    before?: TransformerFactory<SourceFile>;
    after?: TransformerFactory<SourceFile>;
    afterDeclarations?: TransformerFactory<SourceFile | Bundle>;
}
type TransformerExtras = {
    /**
     * Originating TypeScript instance
     */
    ts: typeof ts;
    /**
     * TypeScript library file event was triggered in (ie. 'tsserverlibrary' or 'typescript')
     */
    library: string;
    addDiagnostic: (diag: Diagnostic) => number;
    removeDiagnostic: (index: number) => void;
    diagnostics: readonly Diagnostic[];
};
type ProgramTransformerExtras = {
    /**
     * Originating TypeScript instance
     */
    ts: typeof ts;
};
type ProgramTransformer = (program: Program, host: CompilerHost | undefined, config: PluginConfig, extras: ProgramTransformerExtras) => Program;
type LSPattern = (ls: LanguageService, config: {}) => TransformerPlugin;
type CompilerOptionsPattern = (compilerOpts: CompilerOptions, config: {}) => TransformerPlugin;
type ConfigPattern = (config: {}) => TransformerPlugin;
type TypeCheckerPattern = (checker: TypeChecker, config: {}) => TransformerPlugin;
type ProgramPattern = (program: Program, config: {}, extras: TransformerExtras) => TransformerPlugin;
type RawPattern = (context: TransformationContext, program: Program, config: {}) => Transformer<SourceFile>;

/**
 * @example
 *
 * new PluginCreator([
 *   {transform: '@zerollup/ts-transform-paths', someOption: '123'},
 *   {transform: '@zerollup/ts-transform-paths', type: 'ls', someOption: '123'},
 *   {transform: '@zerollup/ts-transform-paths', type: 'ls', after: true, someOption: '123'}
 * ]).createTransformers({ program })
 */
class PluginCreator {
    private configs;
    private resolveBaseDir;
    currentProject?: string;
    constructor(configs: PluginConfig[], resolveBaseDir?: string);
    mergeTransformers(into: TransformerList, source: CustomTransformers | TransformerBasePlugin): this;
    createTransformers(params: {
        program: Program;
    } | {
        ls: LanguageService;
    }, customTransformers?: CustomTransformers): TransformerList;
    getProgramTransformers(): [ProgramTransformer, PluginConfig][];
    private resolveFactory;
    static validateConfigs(configs: PluginConfig[]): void;
    static createTransformerFromPattern({ factory, config, program, ls }: {
        factory: PluginFactory;
        config: PluginConfig;
        program: Program;
        ls?: LanguageService;
    }): TransformerBasePlugin;
}
const tspVersion: string;
const originalCreateProgram: typeof createProgram;
const diagnosticMap$1: typeof diagnosticMap;



}
