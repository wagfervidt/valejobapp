const { pickAnnotations } = require('./keywords');
const { getUnionSchema } = require('./union');
const { intersectionValues } = require('./utils/array');
const { isSubsetSchema } = require('./validation');

/**
 * Constructs a type schema by extracting from the source schema all (sub)types that are
 * overlapping (compatible) with the target schema. Returns `null` if the two schemas
 * are not overlapping.
 * @param {object} sourceSchema source schema
 * @param {object} targetSchema target schema
 */
function extractSchema(sourceSchema, targetSchema) {
  // eslint-disable-next-line no-param-reassign
  sourceSchema = sourceSchema || {};
  // eslint-disable-next-line no-param-reassign
  targetSchema = targetSchema || {};
  // If there are enums, then take their intersection
  const { enum: sourceEnum, ...enumlessSourceSchema } = sourceSchema;
  const { enum: targetEnum, ...enumlessTargetSchema } = targetSchema;
  if (sourceEnum || targetEnum) {
    const schema = extractSchema(enumlessSourceSchema, enumlessTargetSchema);
    if (!schema) {
      return null;
    }
    if (!sourceEnum) {
      return { ...schema, enum: targetEnum };
    }
    if (!targetEnum) {
      return { ...schema, enum: sourceEnum };
    }
    // Take intersection of the enum arrays
    const resultEnum = intersectionValues(targetEnum, sourceEnum);
    if (!resultEnum.length) {
      // No common values => incompatible schemas
      return null;
    }
    return { ...schema, enum: resultEnum };
  }
  // If there are examples, then take their intersection
  const { examples: sourceExamples, ...examplelessSourceSchema } = sourceSchema;
  const { examples: targetExamples, ...examplelessTargetSchema } = targetSchema;
  if (sourceExamples || targetExamples) {
    const schema = extractSchema(examplelessSourceSchema, examplelessTargetSchema);
    if (!schema) {
      return null;
    }
    if (!sourceExamples || !targetExamples) {
      return { ...schema, examples: targetExamples || sourceExamples };
    }
    // Take intersection of the examples arrays
    const resultExamples = intersectionValues(targetExamples, sourceExamples);
    if (!resultExamples.length) {
      // No common values => no examples
      return schema;
    }
    return { ...schema, examples: resultExamples };
  }
  // Merge other kind of annotations
  const result = extractSchemaTypes(sourceSchema, targetSchema);
  if (!result) {
    return result;
  }
  const sourceAnnotations = pickAnnotations(sourceSchema);
  const targetAnnotations = pickAnnotations(targetSchema);
  return { ...result, ...sourceAnnotations, ...targetAnnotations };
}

function extractSchemaTypes(sourceSchema, targetSchema) {
  const sourceAnyOf = sourceSchema.anyOf;
  if (sourceAnyOf) {
    return getUnionSchema(sourceAnyOf
      .map((schema) => extractSchema(schema, targetSchema))
      .filter((schema) => schema != null));
  }
  const targetAnyOf = targetSchema.anyOf;
  if (targetAnyOf) {
    return getUnionSchema(targetAnyOf
      .map((schema) => extractSchema(sourceSchema, schema))
      .filter((schema) => schema != null));
  }
  // If the one schema is a sub-set of the another, then return the more explicit one
  if (isSubsetSchema(sourceSchema, targetSchema, true)) {
    return sourceSchema;
  }
  if (isSubsetSchema(targetSchema, sourceSchema, false)) {
    return targetSchema;
  }
  // No overlap!
  return null;
}

module.exports.extractSchema = extractSchema;
