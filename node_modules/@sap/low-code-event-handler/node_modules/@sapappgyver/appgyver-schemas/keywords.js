const { pickBy } = require('./utils/object');

/**
 * List of reserved keywords in any schema object.
 * Not all of them are supported, but they might still be reserved
 * for future use.
 */
const reservedKeywords = [
  '$schema',
  '$id',
  '$ref',
  'type',
  'enum',
  'const',
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxContains',
  'minContains',
  'maxProperties',
  'minProperties',
  'required',
  'dependentRequired',
  'format',
  'schema',
  'contentEncoding',
  'contentMediaType',
  'contentSchema',
  'definitions',
  'allOf',
  'anyOf',
  'oneOf',
  'not',
  'if',
  'then',
  'else',
  'items',
  'additionalItems',
  'contains',
  'propertyNames',
  'properties',
  'patternProperties',
  'additionalProperties',
  'dependencies',
  // Function types
  'parameters',
  'returnValue',
];

/**
 * List of some of the known annotation keywords.
 * Basically any non-reserved keyword is a valid annotation.
 */
const annotationKeywords = [
  'title',
  'description',
  'default',
  'examples',
  'deprecated',
  'readOnly',
  'writeOnly',
];

/**
 * Returns an object containing those properties of the given schema
 * that are not reserved validation-related keywords (`type`, `format`, etc.).
 * In other words, it only picks annotation keywords (`title`, `description`, etc.)
 * including any custom annotation keywords.
 *
 * @param {object} schema schema object
 */
function pickAnnotations(schema) {
  return pickBy(schema, (key, annotation) => (
    reservedKeywords.indexOf(key) < 0 && typeof annotation !== 'undefined'
  ));
}

/**
 * Returns an object containing only validation-related keywords of the given
 * schema (`type`, `format`, etc.). In other words, ignore all annotation
 * keywords (`title`, `description`, etc.) including any custom annotation keywords.
 *
 * @param {object} schema schema object
 */
function omitAnnotations(schema) {
  return pickBy(schema, (key) => reservedKeywords.indexOf(key) >= 0);
}

/**
 * Returns an annotation property of the given schema.
 * If the schema is a combination schema, the property is looked from
 * sub-schemas secondarily.
 * @param {object} schema schema object
 * @param {string} annotationName name of the annotation property
 */
function getSchemaAnnotation(schema, annotationName) {
  let annotationValue;
  if (schema) {
    annotationValue = schema[annotationName];
    if (annotationValue != null) {
      return annotationValue;
    }
    const combination = schema.anyOf || schema.allOf;
    if (combination && combination.length) {
      const annotationValues = combination.map(
        (subSchema) => getSchemaAnnotation(subSchema, annotationName),
      );
      return annotationValues.reduce((commonValue, value) => (
        commonValue === value ? commonValue : undefined
      ));
    }
  }
  return annotationValue;
}

module.exports.annotationKeywords = annotationKeywords;
module.exports.getSchemaAnnotation = getSchemaAnnotation;
module.exports.omitAnnotations = omitAnnotations;
module.exports.pickAnnotations = pickAnnotations;
module.exports.reservedKeywords = reservedKeywords;
