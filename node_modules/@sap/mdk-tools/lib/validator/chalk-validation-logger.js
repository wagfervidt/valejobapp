const chalk = require('chalk');
const fs = require('fs-extra');

const LogLevel = require('../../language-service/out/lib/mdkLanguageTypes').LogLevel;

const VALIDATION_LOG_HEADER = "MDK Validator";

class ChalkValidationLogger {
	constructor(path, diagnosticFormatter, logLevel) {
		this._logFilePath = path;
		this._diagnosticFormatter = diagnosticFormatter;
		this._logLevel = logLevel ? logLevel : LogLevel.Info;

		this._diagnostics = [];
		this._errors = 0;
		this._warnings = 0;
	}

	debug(message) {
		if (this._checkLevel(LogLevel.Debug, this._logLevel)) {
			console.log(this._addHeader() + chalk.gray(message));
		}
	}

	info(message) {
		if (this._checkLevel(LogLevel.Info, this._logLevel)) {
			console.log(this._addHeader() + message);
		}
	}

	warn(message) {
		if (this._checkLevel(LogLevel.Warn, this._logLevel)) {
			console.log(this._addHeader() + chalk.yellow(message));
		}
	}

	error(message) {
		if (this._checkLevel(LogLevel.Error, this._logLevel)) {
			console.log(this._addHeader() + chalk.red(message));
		}
	}

	start(appPath, sdkVersion) {
		sdkVersion = sdkVersion ? sdkVersion : '';
		this.info('Start validating the application ' +
			appPath + ' with the metadata schema supported in MDK SDK ' + sdkVersion);
	}

	end() {
		let errors = this._errors;
		let issues = errors + this._warnings;
		let message = 'End validation with ' + issues + ' issue(s) - ';

		let errorMessage = errors + ' error(s)';
		if (errors > 0) {
			errorMessage = chalk.red(errorMessage);
		}
		let warningMessage = this._warnings + ' warning(s)';
		if (this._warnings > 0) {
			warningMessage = chalk.yellow(warningMessage);
		}
		message += errorMessage + ', ' + warningMessage + '.';

		if (issues > 0) {
			message += ' Please take a look at PROBLEMS for details.';
		}
		this.info(message);
	}

	logVailationStart() {
	}

	logValidationEnd(errors, warnings) {
		this._errors += errors;
		this._warnings += warnings;
	}

	logDiagnostic(message) {
		if (!message) {
			return;
		}

		let chalkMessage = message;
		let header = '[MDK] ';
		if (message.startsWith(header)) {
			let pos = message.indexOf(':', header.length);
			if (pos > -1) {
				let severity = message.substring(header.length, pos);
				let leftMessage = message.substring(pos);
				switch (severity.toLowerCase().trim()) {
					case 'error':
						chalkMessage = chalk.red(header + severity) + leftMessage;
						break;
					case 'warning':
						chalkMessage = chalk.yellow(header + severity) + leftMessage;
						break;
				}
			}
		}

		console.log(this._addHeader() + chalkMessage);
		this._diagnostics.push(message);
	}

	outputDiagnostics() {
		if (this._diagnostics.length === 0) {
			return;
		}

		let content = '';
		this._diagnostics.forEach(diagonstic => {
			content += diagonstic + '\n';
		});
		this._diagnostics = [];

		if (!this._logFilePath) {
			this.debug('Failed to write diagnostics because the path of log file is null.');
			return;
		}

		try {
			fs.appendFileSync(this._logFilePath, content);
		} catch (err) {
			this.error('Failed to write diagnostics to the file ' + this._logFilePath);
			this.debug('Failed to write diagnostics with error ' + err);
		}
	}

	_checkLevel(currentLevel, configLevel) {
		return currentLevel >= configLevel;
	}

	_addHeader() {
		return chalk.cyan(VALIDATION_LOG_HEADER + ' - ');
	}
}

exports.ChalkValidationLogger = ChalkValidationLogger;