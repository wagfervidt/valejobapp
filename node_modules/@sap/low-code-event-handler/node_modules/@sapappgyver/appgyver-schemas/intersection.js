const { pickAnnotations } = require('./keywords');
const { intersectionValues } = require('./utils/array');
const { isSubsetSchema } = require('./validation');

/**
 * Combines the given schemas to an intersection schema that only matches
 * if all the original schemas match. Returns `null` if some of the given
 * schemas are incompatible so that there is no common schema. Otherwise
 * returns a valid schema object.
 * @param {array} schemas schemas to combine
 */
function getIntersectionSchema(schemas) {
  if (!Array.isArray(schemas)) {
    throw new Error('getIntersectionSchema expects an array parameter');
  }
  const actualSchemas = schemas.filter((schema) => schema != null);
  if (!actualSchemas.length) {
    return null;
  }
  return actualSchemas.reduce((result, schema) => combineSchemaIntersection(result, schema));
}

/**
 * Builds an intersection of the two given schemas so that the returned
 * schema matches both of them.
 * @param {object} sourceSchema the first schema
 * @param {object} targetSchema the second schema
 */
function combineSchemaIntersection(sourceSchema, targetSchema) {
  // eslint-disable-next-line no-param-reassign
  sourceSchema = sourceSchema || {};
  // eslint-disable-next-line no-param-reassign
  targetSchema = targetSchema || {};
  // If there are enums, then take their intersection
  const { enum: sourceEnum, ...enumlessSourceSchema } = sourceSchema;
  const { enum: targetEnum, ...enumlessTargetSchema } = targetSchema;
  if (sourceEnum || targetEnum) {
    const schema = combineSchemaIntersection(enumlessSourceSchema, enumlessTargetSchema);
    if (!schema) {
      return null;
    }
    if (!sourceEnum) {
      return { ...schema, enum: targetEnum };
    }
    if (!targetEnum) {
      return { ...schema, enum: sourceEnum };
    }
    // Take intersection of the enum arrays
    const resultEnum = intersectionValues(targetEnum, sourceEnum);
    if (!resultEnum.length) {
      // No common values => incompatible schemas
      return null;
    }
    return { ...schema, enum: resultEnum };
  }
  // If there are examples, then take their intersection
  const { examples: sourceExamples, ...examplelessSourceSchema } = sourceSchema;
  const { examples: targetExamples, ...examplelessTargetSchema } = targetSchema;
  if (sourceExamples || targetExamples) {
    const schema = combineSchemaIntersection(examplelessSourceSchema, examplelessTargetSchema);
    if (!schema) {
      return null;
    }
    if (!sourceExamples || !targetExamples) {
      return { ...schema, examples: targetExamples || sourceExamples };
    }
    // Take intersection of the examples arrays
    const resultExamples = intersectionValues(targetExamples, sourceExamples);
    if (!resultExamples.length) {
      // No common values => no examples
      return schema;
    }
    return { ...schema, examples: resultExamples };
  }
  // Merge other kind of annotations
  const sourceAnnotations = pickAnnotations(sourceSchema);
  const targetAnnotations = pickAnnotations(targetSchema);
  return {
    ...combineSchemaIntersectionType(sourceSchema, targetSchema),
    ...sourceAnnotations,
    ...targetAnnotations,
  };
}

function combineSchemaIntersectionType(sourceSchema, targetSchema) {
  // If the target is an intersection type, flatten it
  const targetAllOf = targetSchema.allOf;
  if (targetAllOf) {
    return getIntersectionSchema([sourceSchema, ...targetAllOf]);
  }
  const sourceAnyOf = sourceSchema.anyOf;
  if (sourceAnyOf) {
    const anyOf = sourceAnyOf.filter((schema) => isSubsetSchema(schema, targetSchema, true));
    return anyOf.length === 1 ? anyOf[0] : { anyOf };
  }
  const targetAnyOf = targetSchema.anyOf;
  if (targetAnyOf) {
    const anyOf = targetAnyOf.filter((schema) => isSubsetSchema(schema, sourceSchema, true));
    return anyOf.length === 1 ? anyOf[0] : { anyOf };
  }
  const sourceAllOf = sourceSchema.allOf;
  if (sourceAllOf) {
    // Include the target schema to the intersection schema if it does not
    // already contain a sub-schema of it.
    if (sourceAllOf.some((schema) => isSubsetSchema(schema, targetSchema, true))) {
      // There is a more explicit schema already present in the intersection.
      return sourceSchema;
    }
    // Include the target schema to the intersection, but also filter out schemas
    // that would be the super-sets of the newly added schema
    const remainingSourceAllOf = sourceAllOf.filter(
      (schema) => !isSubsetSchema(targetSchema, schema, true),
    );
    if (!remainingSourceAllOf.length) {
      // The target schema is a sub-set of everything
      return targetSchema;
    }
    return { allOf: [...remainingSourceAllOf, targetSchema] };
  }
  // If both schemas have type "schema", then combine their meta schemas
  const sourceType = sourceSchema.type;
  const targetType = targetSchema.type;
  if (sourceType === 'schema' && targetType === 'schema') {
    const sourceMeta = sourceSchema.schema;
    const targetMeta = targetSchema.schema;
    if (sourceMeta && targetMeta) {
      return {
        type: 'schema',
        schema: combineSchemaIntersection(sourceMeta, targetMeta),
      };
    }
    return targetMeta ? targetSchema : sourceSchema;
  }
  // If the one schema is a sub-set of the another, then return the more explicit one
  if (isSubsetSchema(sourceSchema, targetSchema, true)) {
    return sourceSchema;
  }
  if (isSubsetSchema(targetSchema, sourceSchema, false)) {
    return targetSchema;
  }
  return { allOf: [sourceSchema, targetSchema] };
}

module.exports.getIntersectionSchema = getIntersectionSchema;
