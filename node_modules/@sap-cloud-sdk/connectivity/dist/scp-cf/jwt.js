"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeOrMakeJwt = exports.isUserToken = exports.getJwtPair = exports.isXsuaaToken = exports.wrapJwtInHeader = exports.verificationKeyCache = exports.verifyJwt = exports.retrieveJwt = exports.decodeJwtComplete = exports.decodeJwt = exports.audiences = exports.tenantId = exports.userId = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const xssec = __importStar(require("@sap/xssec"));
const jsonwebtoken_1 = require("jsonwebtoken");
const cache_1 = require("./cache");
const environment_accessor_1 = require("./environment-accessor");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'jwt'
});
function makeArray(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
}
/**
 * Get the user ID from the JWT payload.
 * @param jwtPayload - Token payload to read the user ID from.
 * @returns The user ID, if available.
 * @internal
 */
function userId({ user_id }) {
    logger.debug(`JWT user_id is: ${user_id}.`);
    return user_id;
}
exports.userId = userId;
/**
 * Get the tenant ID of a decoded JWT, based on its `zid` property.
 * @param jwtPayload - Token payload to read the tenant ID from.
 * @returns The tenant ID, if available.
 * @internal
 */
function tenantId({ zid }) {
    logger.debug(`JWT zid is: ${zid}.`);
    return zid;
}
exports.tenantId = tenantId;
/**
 * Retrieve the audiences of a decoded JWT based on the audiences and scopes in the token.
 * @param decodedToken - Token to retrieve the audiences from.
 * @returns A set of audiences.
 * @internal
 */
// Comments taken from the Java SDK implementation
// Currently, scopes containing dots are allowed.
// Since the UAA builds audiences by taking the substring of scopes up to the last dot,
// scopes with dots will lead to an incorrect audience which is worked around here.
// If a JWT contains no audience, infer audiences based on the scope names in the JWT.
// This is currently necessary as the UAA does not correctly fill the audience in the user token flow.
function audiences(decodedToken) {
    const parsedAudiences = audiencesFromAud(decodedToken);
    return parsedAudiences.length
        ? parsedAudiences
        : audiencesFromScope(decodedToken);
}
exports.audiences = audiences;
function audiencesFromAud({ aud }) {
    return makeArray(aud).map(audience => audience.split('.')[0]);
}
function audiencesFromScope({ scope }) {
    return makeArray(scope).reduce((aud, s) => (s.includes('.') ? [...aud, s.split('.')[0]] : aud), []);
}
/**
 * Decode JWT.
 * @param token - JWT to be decoded.
 * @returns Decoded payload.
 */
function decodeJwt(token) {
    return typeof token === 'string' ? decodeJwtComplete(token).payload : token;
}
exports.decodeJwt = decodeJwt;
/**
 * Decode JWT and return the complete decoded token.
 * @param token - JWT to be decoded.
 * @returns Decoded token containing payload, header and signature.
 * @internal
 */
function decodeJwtComplete(token) {
    const decodedToken = (0, jsonwebtoken_1.decode)(token, { complete: true, json: true });
    if (decodedToken !== null && isJwtWithPayloadObject(decodedToken)) {
        return decodedToken;
    }
    throw new Error('JwtError: The given jwt payload does not encode valid JSON.');
}
exports.decodeJwtComplete = decodeJwtComplete;
/**
 * Retrieve JWT from a request that is based on the node `IncomingMessage`. Fails if no authorization header is given or has the wrong format. Expected format is 'Bearer <TOKEN>'.
 * @param req - Request to retrieve the JWT from.
 * @returns JWT found in header.
 */
function retrieveJwt(req) {
    const authHeader = getAuthHeader(req);
    if (validateAuthHeader(authHeader)) {
        return authHeader?.split(' ')[1];
    }
}
exports.retrieveJwt = retrieveJwt;
function getAuthHeader(req) {
    const authHeader = (0, util_1.pickValueIgnoreCase)(req.headers, 'authorization');
    if (authHeader) {
        return Array.isArray(authHeader) ? authHeader[0] : authHeader;
    }
}
function validateAuthHeader(header) {
    if (typeof header === 'undefined') {
        logger.warn('Authorization header not set.');
        return false;
    }
    const [authType, token] = header.split(' ');
    if (typeof token === 'undefined') {
        logger.warn('Token in auth header missing.');
        return false;
    }
    if (authType.toLowerCase() !== 'bearer') {
        logger.warn('Authorization type is not Bearer.');
        return false;
    }
    return true;
}
/**
 * Verifies the given JWT and returns the decoded payload.
 * @param token - JWT to be verified
 * @param options - Options to control certain aspects of JWT verification behavior.
 * @returns A Promise to the decoded and verified JWT.
 * @internal
 */
async function verifyJwt(token, options) {
    const disableCache = !{ ...defaultVerifyJwtOptions, ...options }
        .cacheVerificationKeys;
    const credentials = (0, environment_accessor_1.getXsuaaServiceCredentials)(token);
    const promise = new Promise((resolve, reject) => {
        xssec.createSecurityContext(token, { disableCache, credentials }, function (error, securityContext, tokenInfo) {
            if (error) {
                return reject(error);
            }
            return resolve(tokenInfo.getPayload());
        });
    });
    return promise
        .then(data => data)
        .catch(e => {
        throw new util_1.ErrorWithCause('Failed to verify JWT.', e);
    });
}
exports.verifyJwt = verifyJwt;
const defaultVerifyJwtOptions = {
    cacheVerificationKeys: true
};
/**
 * 15 minutes is the default value used by the xssec lib.
 * @internal
 */
exports.verificationKeyCache = new cache_1.Cache(900000);
/**
 * Wraps the access token in header's authorization.
 * @param token - Token to attach in request header
 * @returns The request header that holds the access token
 * @internal
 */
function wrapJwtInHeader(token) {
    return { headers: { Authorization: 'Bearer ' + token } };
}
exports.wrapJwtInHeader = wrapJwtInHeader;
/**
 * Checks if the given JWT was issued by XSUAA based on the `iss` property and the UAA domain of the XSUAA.
 * @param jwt - JWT to be checked.
 * @returns Whether the JWT was issued by XSUAA.
 * @internal
 */
function isXsuaaToken(jwt) {
    return jwt.payload.ext_attr?.enhancer === 'XSUAA';
}
exports.isXsuaaToken = isXsuaaToken;
/**
 * Build JwtPair from an encoded JWT.
 * @internal
 */
function getJwtPair(encodedJwt) {
    return { encoded: encodedJwt, decoded: decodeJwt(encodedJwt) };
}
exports.getJwtPair = getJwtPair;
/**
 * The user JWT can be a full JWT containing user information but also a reduced one setting only the iss value
 * This method divides the two cases.
 * @param token - Token to be investigated
 * @returns Boolean value with true if the input is a UserJwtPair
 * @internal
 */
function isUserToken(token) {
    if (!token) {
        return false;
    }
    // Check if it is an Issuer Payload
    const keys = Object.keys(token.decoded);
    return !(keys.length === 1 && keys[0] === 'iss');
}
exports.isUserToken = isUserToken;
function isJwtWithPayloadObject(decoded) {
    return typeof decoded.payload !== 'string';
}
/**
 * This method either decodes the given JWT or tries to retrieve the subaccount ID from the XSUAA service binding as `zid`.
 * @param options - Options passed to register the destination containing the JWT.
 * @returns The decoded JWT or a dummy JWT containing the tenant identifier (zid).
 * @internal
 */
function decodeOrMakeJwt(jwt) {
    if (jwt) {
        const decodedJwt = typeof jwt === 'string' ? decodeJwt(jwt) : jwt;
        if (decodedJwt.zid) {
            return decodedJwt;
        }
    }
    const providerTenantId = (0, environment_accessor_1.getServiceCredentials)('xsuaa', jwt)?.subaccountid;
    if (providerTenantId) {
        return { zid: providerTenantId };
    }
}
exports.decodeOrMakeJwt = decodeOrMakeJwt;
//# sourceMappingURL=jwt.js.map