const fs = require("fs-extra");
const JSPath = require("jspath");
const _ = require('lodash');
const path = require("path");
const toolUtils = require('../../tool-utils');
const migrateJson = require('./migrate.json');
const migrateFuns = require('./migrate-functions');

const JSON_FILE_ENCODING = 'UTF-8';
const APPLICATION_FILE_NAME = "Application.app";
const _SUPPORTED_FILE_EXT = [
	"action",
	"app",
	"global",
	"page",
	"service",
	"js",
	"ts",
	"xml"
];
const _SUPPORTED_JSON_FILE_EXT = [
	"action",
	"app",
	"global",
	"page",
	"service"
];

class MigrationHelper {
	constructor (sAppBasePath, sTargetVersion) {
		this.appBasePath = path.resolve(sAppBasePath);
		this.oMigrationConfig = migrateJson;
		this.targetVersion = sTargetVersion || this.oMigrationConfig.latest;
		this.output = [];
	}

	_isMatch (source, sSchemaVersion) {
		if (source.startsWith("^")) {
			source = source.substring(1);
			let floatSource = parseFloat(source);
			let floatSchemaVersion = parseFloat(sSchemaVersion);
			if (!isNaN(floatSource) && !isNaN(floatSchemaVersion)) {
				return floatSchemaVersion > floatSource;
			}
			return sSchemaVersion > source;
		}
		return source === sSchemaVersion;
    }

	_getMigrationSetting (sSchemaVersion) {
		if (this.oMigrationConfig) {
			let _schemaVersion = sSchemaVersion || this.oMigrationConfig.default;
			var oTargetSetting = _.find(this.oMigrationConfig.migrations, migration => {
				let _target = migration.target || this.oMigrationConfig.latest;
				return this.targetVersion === _target && this._isMatch(migration.source, _schemaVersion);
			});
			return oTargetSetting || null;
		}

		return null;
	}

	_getMigrationSettingRules (sSchemaVersion, sFileExtension) {
		var oTargetSetting = this._getMigrationSetting(sSchemaVersion);
		return oTargetSetting ? oTargetSetting.rules[sFileExtension] : null;
	}

	_getMigrationSettingReplacedItems (sSchemaVersion) {
		var oTargetSetting = this._getMigrationSetting(sSchemaVersion);
		return oTargetSetting ? oTargetSetting["replaced_items"] : null;
	}

	_replaceItems (content, sSchemaVersion) {
		let _oMigrationSetting = this._getMigrationSettingReplacedItems(sSchemaVersion);
		if (_oMigrationSetting) {
			_oMigrationSetting.forEach(oRep => {
				if (content.indexOf(oRep.old) !== -1) {
					content = this._replaceAll(content, oRep.old, oRep.new);
					this.output.push(`[replace] "${oRep.old}" with "${oRep.new}"`);
				}
			});
		}

		return content;
	}

	_isJson (obj) {
		var isJson = typeof(obj) == "object" && Object.prototype.toString.call(obj).toLowerCase() == "[object object]" && !obj.length;
		return isJson;
	}

	_escapeRegExp (str) {
		return str.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
	}

	_replaceAll (str, find, replace) {
		return str.replace(new RegExp(this._escapeRegExp(find), 'gm'), replace);
	}

	_updateKeys (obj, updates) {
		let output = [];
		if (typeof obj === "object") {
			updates.forEach(oUpdate => {
				if (!_.isNil(obj[oUpdate.old_key])) {
					// obj[oUpdate.new_key] = obj[oUpdate.old_key];
					// delete obj[oUpdate.old_key];
					
					// To make sure there are less differs in the stringify json text.
					Object.keys(obj).forEach(key => {
						if (key === oUpdate.old_key && oUpdate.new_key) {
							// replace old key with new key
							obj[oUpdate.new_key] = obj[key];
							delete obj[key];
							output.push(`key "${oUpdate.old_key}" --> key "${oUpdate.new_key}"`);
						} else if (key === oUpdate.old_key && oUpdate.$fn) {
							var _fn = migrateFuns[oUpdate.$fn];
							if (_fn && typeof _fn === "function") {
								_fn.call(this, obj, key, output);
							}
						} else {
							// for others, use this logic to keep the key orders in json object
							obj[`_${key}`] = obj[key];
							delete obj[key];
	
							obj[`${key}`] = obj[`_${key}`];
							delete obj[`_${key}`];
						}
	
						// replace key value with new value
						if (!_.isNil(oUpdate.old_value) && 
							!_.isNil(oUpdate.new_value) && 
							key === oUpdate.old_key &&
							obj[key] === oUpdate.old_value) {
							obj[key] = oUpdate.new_value;
							output.push(`value {"${key}": "${oUpdate.old_value}"} --> value {"${key}": "${oUpdate.new_value}"}`);
						}
					});
				}
			});
		}

		return output;
	}

	_deleteKeys (obj, deletes) {
		let output = [];
		if (typeof obj === "object") {
			if (Array.isArray(deletes)) {
				deletes.forEach(delKey => {
					output.push(`key "${delKey}"`);
					delete obj[delKey];
				});
			} else if (typeof deletes === "string") {
				output.push(`key "${deletes}"`);
				delete obj[deletes];
			}
		}

		return output;
	}

	_addKeys (obj, adds) {
		let output = [];
		if (typeof obj === "object") {
			adds.forEach(oAdd => {
				if (_.isNil(obj[oAdd.key])) {
					obj[oAdd.key] = oAdd.value;
					output.push(`{"${oAdd.key}": "${oAdd.value}"}`);
				}
			});
		}

		return output;
	}

	_isFolderSync(fullPath) {
		try {
			return fs.lstatSync(fullPath).isDirectory();
		} catch (error) {
			console.log(error);
			return false;
		}
	}

	_getChildrenFullPathsSync (folderFullPath, recursive) {
		let allSubFileFullPaths = [];
		try {
			if (fs.existsSync(folderFullPath)) {
				let childrenNames = fs.readdirSync(folderFullPath);
				childrenNames.forEach(childName => {
					let childFullPath = path.join(folderFullPath, childName);
					let isFolder = this._isFolderSync(childFullPath);
					if (isFolder && recursive) {
						allSubFileFullPaths = allSubFileFullPaths.concat(this._getChildrenFullPathsSync(childFullPath, true));
					} else {
						allSubFileFullPaths.push(childFullPath);
					}
				}, this);
			}
		} catch (error) {
			console.log(error);
		}
		return allSubFileFullPaths;
	}

	async _getDocumentJson(fileFullPath) {
		let data = await this._getDocumentContent(fileFullPath);
		return JSON.parse(data);
	}

	async _getDocumentContent(fileFullPath) {
		return new Promise(resolve => {
			fs.readFile(fileFullPath, JSON_FILE_ENCODING, (err, data) => {
				if (err) {
					console.log(err);
					resolve("{}");
				} else {
					resolve(data);
				}
			});
		});
	}

	_getFileExtension(filePath) {
		let fileExt = path.extname(filePath).toLowerCase();
		if (fileExt) {
			fileExt = fileExt.substr(1);
		}
		return fileExt;
	}

	async init() {
		let appFilePath = path.join(this.appBasePath, APPLICATION_FILE_NAME);
		this.oAppInfo = await this._getDocumentJson(appFilePath);
	}

	getLatestSchemaVersion() {
		return this.oMigrationConfig ? this.oMigrationConfig.latest : null;
	}

	checkTargetVersionExist() {
		if (this.targetVersion === this.oMigrationConfig.latest) {
			return true;
		}
		for (let i = 0; i < this.oMigrationConfig.migrations.length; i++) {
			let oMigration = this.oMigrationConfig.migrations[i];
			if (oMigration.target && oMigration.target === this.targetVersion) {
				return true;
			}
		}
		return false;
	}

	migrate(data, sFileExtension, sSchemaVersion) {
		this.output = [];
		if (this._isJson(data)) {
			let _oMigrationSetting = this._getMigrationSettingRules(sSchemaVersion, sFileExtension.toLowerCase());
			if (_oMigrationSetting) {
				// modification
				_oMigrationSetting.modification.forEach(oModi => {
					var oPartial = JSPath.apply(oModi.path, data);
					if (oPartial) {
						let _outputTmp = [];
						if (Array.isArray(oPartial)) {
							oPartial.forEach(oItem => {
								_outputTmp = _outputTmp.concat(this._updateKeys(oItem, oModi.updates));
							});
						} else {
							_outputTmp = this._updateKeys(oPartial, oModi.updates);
						}

						_outputTmp.map(item => {
							this.output.push(`[update] "${oModi.loc || oModi.path}" => ${item}`);
						});
					}
				});

				// addition
				_oMigrationSetting.addition.forEach(oAdd => {
					var oPartial = JSPath.apply(oAdd.path, data);
					if (oPartial) {
						let _outputTmp = [];
						if (Array.isArray(oPartial)) {
							oPartial.forEach(oItem => {
								_outputTmp = _outputTmp.concat(this._addKeys(oItem, oAdd.adds));
							});
						} else {
							_outputTmp = this._addKeys(oPartial, oAdd.adds);
						}

						_outputTmp.map(item => {
							this.output.push(`[add] "${oAdd.loc || oAdd.path}" => ${item}`);
						});
					}
				});

				// deletion
				_oMigrationSetting.deletion.forEach(oDel => {
					var oPartial = JSPath.apply(oDel.path, data);
					if (oPartial) {
						let _outputTmp = [];
						if (Array.isArray(oPartial)) {
							oPartial.forEach(oItem => {
								_outputTmp = _outputTmp.concat(this._deleteKeys(oItem, oDel.key));
							});
						} else {
							_outputTmp = this._deleteKeys(oPartial, oDel.key);
						}

						_outputTmp.map(item => {
							this.output.push(`[delete] "${oDel.loc || oDel.path}" => ${item}`);
						});
					}
				});
			}

			data = JSON.stringify(data, null, "\t");
		}
		
		return this._replaceItems(data, sSchemaVersion);
	}

	async check(isPreview) {
		let oMigration = [];
		let sAppName = path.parse(this.appBasePath).name;
		let appFolderSubFileFullPaths = this._getChildrenFullPathsSync(this.appBasePath, true);
		let tempFolder = toolUtils.getTempDirectory("mdk_migration");
		if (isPreview) {
			if (fs.existsSync(tempFolder)) {
				fs.emptyDirSync(tempFolder);
			} else {
				fs.mkdirSync(tempFolder);
			}
		}
		let output = [];
		let sSchemaVersion = this.oAppInfo ? this.oAppInfo["_SchemaVersion"] : "";
		for (const appFolderSubFileFullPath of appFolderSubFileFullPaths) {
			try {
				let sFileExtension = this._getFileExtension(appFolderSubFileFullPath);
				if (!_SUPPORTED_FILE_EXT.includes(sFileExtension)) {
					continue;
				}
				let isUpdated = false;
				let targetPath = isPreview ? appFolderSubFileFullPath.replace(this.appBasePath, path.join(tempFolder, sAppName)) : appFolderSubFileFullPath;
				let sFileName = path.basename(appFolderSubFileFullPath);
				let sourceContent = await this._getDocumentContent(appFolderSubFileFullPath);
				let migratedContent = sourceContent;
	
				if (_SUPPORTED_JSON_FILE_EXT.includes(sFileExtension)) {
					migratedContent = _.cloneDeep(JSON.parse(sourceContent));
					if (sFileName === APPLICATION_FILE_NAME && this.checkTargetVersionExist()) {
						// update "_SchemaVersion" to the target schema version in Application.app
						if (migratedContent["_SchemaVersion"] !== this.targetVersion) {
							migratedContent["_SchemaVersion"] = this.targetVersion;
							output.push(`${targetPath}:\n[add/update] {"_SchemaVersion": "${migratedContent["_SchemaVersion"]}"}`);
							isUpdated = true;
						}
					}
				}
	
				migratedContent = this.migrate(migratedContent, _.trimStart(path.extname(appFolderSubFileFullPath), "."), sSchemaVersion);
				if (this.output.length > 0) {
					isUpdated = true;
					output.push(`${targetPath}:\n${this.output.join('\n')}`);
				}
	
				if (isUpdated) {
					fs.mkdirSync(path.dirname(targetPath), {recursive: true});
					fs.writeFileSync(targetPath, migratedContent);
					oMigration.push(targetPath);
				}
			} catch (error) {
				console.log(appFolderSubFileFullPath);
				console.log(error);
			}
		}

		return {
			migration: oMigration,
			output: output
		};
	}
}

exports.MigrationHelper = MigrationHelper;
