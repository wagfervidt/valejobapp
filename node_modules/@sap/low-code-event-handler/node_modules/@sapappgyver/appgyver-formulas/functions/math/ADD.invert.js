function unstringify(str, original) {
  if (original === null) {
    return str === 'null' ? null : str;
  }
  if (original === undefined) {
    return str === 'undefined' ? undefined : str;
  }
  if (typeof original === 'object') {
    // NOTE: Let the JSON-parse error to pass through
    return JSON.parse(str);
  }
  if (typeof original === 'number') {
    const numeric = +str;
    if (Number.isNaN(numeric) && !Number.isNaN(original)) {
      throw new Error(`Cannot invert non-numeric string ${JSON.stringify(str)} as number`);
    }
    return numeric;
  }
  if (typeof original === 'boolean') {
    if (str === 'false') {
      return false;
    }
    if (str === 'true') {
      return true;
    }
  }
  return str;
}

module.exports = (inv) => {
  const { params: [a, b], result, invertIndexes: [invertIndex] } = inv;
  const type = typeof result;
  const original = invertIndex === 0 ? a : b;
  const constant = invertIndex === 0 ? b : a;
  if (type === 'number') {
    // Arithmetic invert
    if (typeof constant !== 'number') {
      throw new Error('Cannot invert addition using a non-number value');
    }
    if (Number.isNaN(result)) {
      throw new Error('Cannot invert addition with NaN value');
    }
    return inv.invertTo(invertIndex === 0 ? result - b : result - a);
  }
  if (type === 'string') {
    // String concatenation
    if (typeof constant !== 'string') {
      throw new Error('Cannot invert text combination with a non-string value');
    }
    if (invertIndex === 0) {
      // Remove the suffix
      if (!result.endsWith(constant)) {
        throw new Error(`Cannot invert text without suffix ${JSON.stringify(constant)}`);
      }
      const prefix = unstringify(
        result.slice(0, -constant.length),
        original,
      );
      return inv.invertTo(prefix);
    }
    // Remove the prefix
    if (!result.startsWith(constant)) {
      throw new Error(`Cannot invert text without prefix ${JSON.stringify(constant)}`);
    }
    const suffix = unstringify(
      result.slice(constant.length),
      original,
    );
    return inv.invertTo(suffix);
  }
  throw new Error(`Cannot invert value of type ${type}`);
};
