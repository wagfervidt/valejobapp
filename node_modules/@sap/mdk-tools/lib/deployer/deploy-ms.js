
const logger = require('../logger');
const execSync = require('child_process').execSync;
const fs = require('fs-extra');
const path = require('path');
const os = require('os');
const axios = require('axios');
const _ = require('lodash');
const qrcode = require('qrcode');
const AdmZip = require('adm-zip');
const btoa = require('btoa');
const prompt = require('prompt');

const utils = require('../utils');
const NEO_APPS_API = "mobileservices/origin/hcpms/mbaas/v1/odata/admin/ApplicationSet";
const NEO_APPS_FILTER = "?$filter=(ApplicationTemplate%20ne%20%27Agentry%27)%20and%20(ApplicationTemplate%20ne%20%27Wechat%27)";
const CF_APPS_API = "apps";
const CF_SERVICES_API = "services";
const NEO_GET_TOKEN = "Admin/Sessions/jaxrs/version";
const NEO_ENDPOINT_API = "Admin/BackendConnections/jaxrs/ApplicationConnections/";

const NEO_MSG_SUCCESS_MARKER = "successfully";
const QRCODE_IMAGE_NAME = "qrcode.png";

const MAX_ARRAY_COUNT = 2048;
let instance;
let randomInt = 0;
let childProcessExecOption;
class DeployMS {
    constructor(args) {
        this.deployArgs = args;
        instance = this;
        childProcessExecOption = {
            stdio: 'inherit'
        }

        instance._option = {};
        instance._prjConfig = {};
        instance.iRevision = -1;
        instance.isNewApp = false;
        instance.csrfToken = "";
        instance.cookie = "";
        instance.sBundleZipfile = path.join(instance.deployArgs.project(), utils.BUILD_TEMP_FOLDER, utils.BUNDLE_ZIP_FILE);
        instance._getLoginInfo();
    }

    deploy() {
        if (instance.deployArgs.fetch()) {
            return instance._fetch();
        } else {
            return instance._deploy();
        }
    }

    _deploy() {
        return instance._getProjectInfo()
            .then(instance._validate)
            .then(instance._getCsrfToken)
            .then(instance._checkApp)
            .then(instance._build)
            .then(instance._amend)
            .then(instance._zip)
            .then(instance._getServices)
            .then(instance._prepareMobileApp)
            .then(instance._prepareMobileDest)
            .then(instance._upload2ms)
            .then(instance._deploy2ms)
            .then(instance._showOnbloardingUrl)
            .then(instance._setProjectInfo)
            .then(() => {
                return true;
            })
            .catch(error => {
                utils.logInfo(error, `${instance.deployArgs.marker()}${instance.deployArgs.marker()}`);
                return Promise.reject(error);
            });
    }

    _fetch() {
        instance.csrfToken = instance.deployArgs.csrfToken();
        instance.cookie = instance.deployArgs.cookie();
        switch (instance.deployArgs.fetch()) {
            case "token":
                return instance._getProjectInfo()
                    .then(instance._getCsrfToken(true));
            case "applications":
                return instance._getProjectInfo()
                    .then(instance._checkApp(true));
            case "destinations":
                return instance._getProjectInfo()
                    .then(instance._checkDestination());
            case "xml":
                return instance._getProjectInfo()
                    .then(instance._checkBackendXml(instance.deployArgs.destination()));
            case "onboardingUrl":
                return instance._getProjectInfo()
                    .then(instance._showOnbloardingUrl(true));
            default:
                throw new Error(`Unsupport fetch type: ${instance.deployArgs.fetch()}`);
        }
    }

    _getProjectInfo() {
        return new Promise(function (resolve, reject) {
            //resolve(true);
            let sPojectInfoFile = path.join(instance.deployArgs.project(), utils.MDK_CONFIG_JSON);
            let lcapOption;
            if (fs.existsSync(sPojectInfoFile)) {
                try {
                    instance._prjConfig = fs.readJSONSync(sPojectInfoFile);
                    instance._option = instance._prjConfig["MobileService"];
                    lcapOption = instance._prjConfig["LCAP"];
                } catch (e) {
                    reject("Failed to parse .project.json with error " + e.message);
                }
            } else if (!instance.deployArgs.zip()) {
                console.log("Failed to get configuration from .project.json.");
            }

            instance._option = instance._option ? instance._option : {};
            lcapOption = lcapOption ? lcapOption : {};

            if (instance.deployArgs.name()) {
                instance._option["AppId"] = instance.deployArgs.name();
            }
            if (instance.deployArgs.adminApi() && instance.deployArgs.neo()) {
                instance._option["AdminAPI"] = instance.deployArgs.adminApi();
            }
            if (instance.deployArgs.neo()) {
                instance._option["Neo"] = instance.deployArgs.neo();
            } else {
                instance._option["AdminAPI"] = instance.loginInfo.cpmsEndpoint;
            }
            if (instance.deployArgs.user()) {
                instance._option["User"] = instance.deployArgs.user();
            }

            if (instance.deployArgs.create()) {
                instance._option["Create"] = instance.deployArgs.create();
            } else if (instance.deployArgs.lcap()) {
                instance._option["Create"] = true;
            }

            const lcapPrjName = instance._getLcapPrjNameByService(lcapOption);

            if (instance.deployArgs.lcap() && lcapPrjName === "") {
                reject("Failed to get LCAP project name by services");
            }

            if (instance.deployArgs.destination() && instance.deployArgs.destinationUrl()) {
                instance._option["DestinationName"] = instance.deployArgs.destination();
                instance._option["DestinationUrl"] = instance.deployArgs.destinationUrl();
            } else if (instance.deployArgs.lcap() && lcapPrjName !== "") {
                instance._option["DestinationName"] = lcapOption["Service"][0]["cap"]["name"];
                const srvAppName = `${lcapPrjName}-srv`;
                const path = lcapOption["Service"][0]["cap"]["entryPath"];
                const routes = instance._getCapSrvRoute(srvAppName);
                if (routes === "") {
                    reject(`Failed to get ${srvAppName} in BTP, please deploy LCAP project first.`)
                } else {
                    instance._option["DestinationUrl"] = `${routes}${path}`;
                }
            }

            if (instance.deployArgs.uaa()) {
                instance._option["Uaa"] = instance.deployArgs.uaa();
            } else if (instance.deployArgs.lcap() && !instance._option["Uaa"] && lcapPrjName !== "") {
                instance._option["Uaa"] = `${lcapPrjName}-uaa`;
            }

            if (!instance._option["AppId"] && instance.deployArgs.lcap() && lcapPrjName !== "") {
                const mdkPrjName = path.basename(instance.deployArgs.project());
                instance._option["AppId"] = `lcap.${lcapPrjName.replace(/(\s|-)/g, '')}.${mdkPrjName.replace(/(\s|-)/g, '')}`;
            }

            instance._pwd = instance.deployArgs.pwd();
            resolve(true);

        });
    }

    _setProjectInfo() {
        return new Promise(function (resolve, reject) {
            if (!instance.deployArgs.zip()) {
                try {
                    let sPojectInfoFile = path.join(instance.deployArgs.project(), utils.MDK_CONFIG_JSON);
                    instance._prjConfig["MobileService"] = instance._option;
                    fs.writeFileSync(sPojectInfoFile, JSON.stringify(instance._prjConfig, null, "\t"));
                } catch (e) {
                    resolve("Failed to set .project.json with error " + e.message);
                }
            }
            resolve(true);
        });
    }

    _getLcapPrjNameByService(lcapOption) {
        if (lcapOption["Service"] && lcapOption["Service"].length > 0 && lcapOption["Service"][0]["cap"]
            && lcapOption["Service"][0]["cap"]["name"] && lcapOption["Service"][0]["cap"]["destination"]) {
            const serviceSuffix = "-app-srv";
            const length = lcapOption["Service"][0]["cap"]["destination"].length;
            return lcapOption["Service"][0]["cap"]["destination"].substring(0, length - serviceSuffix.length);
        }
        return "";
    }

    _validate() {
        return new Promise(function (resolve, reject) {
            if (!instance._option["AppId"]) {
                reject("no mobile application name provided");
            }

            if (instance._option["Neo"]) {
                if (instance._option["AdminAPI"] && instance.deployArgs.csrfToken() || instance.deployArgs.cookie()) {
                    instance.csrfToken = instance.deployArgs.csrfToken();
                    instance.cookie = instance.deployArgs.cookie();
                    resolve();
                } else if (!instance._option["AdminAPI"] || !instance._option["User"] || !instance._pwd) {
                    return instance._askUserInput()
                        .then(() => {
                            if (instance._option["AdminAPI"] && instance._option["User"] && instance._pwd) {
                                resolve();
                            } else {
                                reject();
                            }
                        })
                        .catch(error => reject(error));
                }
            }
            if (instance._option["DestinationName"] && instance._option["DestinationUrl"]) {
                return instance._checkService(instance._option["DestinationUrl"])
                    .then(ret => {
                        resolve(ret);
                    })
                    .catch(error => {
                        reject(error);
                    });
            } else {
                resolve(true); //todo
            }
        });
    }

    _formatArrayToParameters(aInput) {
        return aInput.map(item => `"${item}"`).join(" ");
    }

    _build() {
        return new Promise(function (resolve, reject) {
            if (instance.deployArgs.zip()) {
                resolve();
            } else {
                utils.logInfo(`Building application...`, instance.deployArgs.marker());
                let sMDKTools = utils.getMDKTools();
                let sCommand = `${sMDKTools} build --target js --project "${instance.deployArgs.project()}" `;

                if (instance.deployArgs.externals() && instance.deployArgs.externals().length > 0) {
                    sCommand = sCommand + ` --externals ${instance._formatArrayToParameters(instance.deployArgs.externals())}`;
                }
                if (instance.deployArgs.filters() && instance.deployArgs.filters().length > 0) {
                    sCommand = sCommand + ` --filters ${instance._formatArrayToParameters(instance.deployArgs.filters())}`;
                }

                if (instance.deployArgs.tsTarget()) {
                    sCommand = sCommand + ` --ts-target ${instance.deployArgs.tsTarget()}`;
                }

                if (instance.deployArgs.useWmf()) {
                    sCommand = sCommand + " --wmf";
                }

                if (instance.deployArgs.devtool()) {
                    sCommand = sCommand + ` --devtool ${instance.deployArgs.devtool()}`;
                }

                try {
                    console.log(sCommand);
                    execSync(sCommand, childProcessExecOption);
                    resolve();
                } catch (error) {
                    console.error(logger.getError(`Failed to bundle project with error: ${error}`));
                    reject(error);
                }
            }
        });
    }

    _amend() {
        return new Promise(function (resolve, reject) {
            if (instance.deployArgs.zip()) {
                resolve();
            } else {
                if (instance._option["DestinationName"]) {
                    utils.logInfo(`Applying destination to build...`, instance.deployArgs.marker());
                    let servicePath = path.join(instance.deployArgs.project(), "Services");
                    let buildPath = path.join(instance.deployArgs.project(), utils.BUILD_TEMP_FOLDER);
                    let sMDKTools = utils.getMDKTools();
                    let sCommand = `${sMDKTools} amend --target mobile --path "${buildPath}" --servicePath "${servicePath}" --destination ${instance._option["DestinationName"]}`;
                    try {
                        console.log(sCommand);
                        execSync(sCommand, childProcessExecOption);
                        resolve();
                    } catch (error) {
                        console.error(logger.getError(`Failed to bundle project with error: ${error}`));
                        reject(error);
                    }
                } else {
                    resolve();
                }
            }
        });
    }

    _zip() {
        return new Promise(function (resolve, reject) {
            if (instance.deployArgs.zip()) {
                resolve();
            } else {
                utils.logInfo(`Zipping build result ...`, instance.deployArgs.marker());
                let destCheProjectPath = path.join(instance.deployArgs.project(), utils.BUILD_TEMP_FOLDER, '.che', utils.MDK_IDENTITY_FILE);
                let destBundleJS = path.join(instance.deployArgs.project(), utils.BUILD_TEMP_FOLDER, utils.BUNDLE_JS_FILE);

                if (!fs.existsSync(destBundleJS)) {
                    reject("bundle.js file is not generated.");
                }

                //synch _SchemaVersion from application to project.json
                let srcCheProjectPath = path.join(utils.getRootPath(), 'deployer', 'template', utils.MDK_IDENTITY_FILE);
                const applicationFile = path.join(instance.deployArgs.project(), utils.APPLICATION_FILE);
                let definistionsVersion = "5.2";
                if (fs.existsSync(applicationFile)) {
                    const applicationJson = fs.readJSONSync(applicationFile);
                    definistionsVersion = applicationJson["_SchemaVersion"] ? applicationJson["_SchemaVersion"] : "5.2";
                }
                let configContent = fs.readFileSync(srcCheProjectPath, {
                    encoding: "utf8"
                });
                configContent = configContent.replace("{definitionsVersion}", definistionsVersion);
                fs.ensureDirSync(path.dirname(destCheProjectPath));
                fs.writeFileSync(destCheProjectPath, configContent);

                var zip = new AdmZip();
                zip.addLocalFolder(path.join(instance.deployArgs.project(), utils.BUILD_TEMP_FOLDER));
                zip.writeZip(instance.sBundleZipfile);

                if (!fs.existsSync(instance.sBundleZipfile)) {
                    reject("failed to zip bundle file");
                } else {
                    resolve();
                }
            }

        });
    }

    async _checkApp(checkApps) {
        utils.logInfo(`Checking application in Mobile Services...`, instance.deployArgs.marker());
        return new Promise(async function (resolve, reject) {
            let sAppId = instance._option["AppId"];
            let req;
            if (instance._option["Neo"]) {
                req = {
                    url: `${instance._option["AdminAPI"]}${NEO_APPS_API}${NEO_APPS_FILTER}&_=${randomInt++}`,
                    method: 'GET',
                    headers: {
                        'X-CSRF-Token': instance.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest',
                        "X-SMP-ENTITYNAME": "application",
                        'Cookie': instance.cookie
                    }
                };
            } else {
                req = {
                    url: `${instance._option["AdminAPI"]}${CF_APPS_API}?_=${randomInt++}`,
                    method: 'GET',
                    headers: {
                        'Authorization': instance.deployArgs.cfToken(),
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                };
            }
            let response, length;
            try {
                response = await axios(req);
            } catch(e) {
                reject(e.message);
            }

            const result = instance._checkHttpResponse(response);

            if (result.pass) {
                const data = response.data;
                let aApps, aList = [], aAllList = [];
                if (instance._option["Neo"]) {
                    aApps = data.value;
                    aApps.forEach(app =>{
                        aAllList.push(app.ApplicationId);
                        aList.push(app.ApplicationId);
                    });
                } else {
                    aApps = data;
                    aApps.forEach(app => {
                        aAllList.push(app.name);
                        let hasAppUpdate = app.services.find(service => {
                            return service.name === "app-update";
                        });
                        if (hasAppUpdate) {
                            aList.push(app.name);
                        }
                    });    

                }

                if (checkApps) {
                    console.log(`get applications ${NEO_MSG_SUCCESS_MARKER}.`);
                    utils.logInfo(JSON.stringify(aList), instance.deployArgs.marker(), true);
                    resolve()
                } else {
                    if (aAllList.includes(sAppId)) {
                        if (aList.includes(sAppId)) {
                            console.log(`${sAppId} exists on Mobile Services.`);
                            instance.isNewApp = false;
                            resolve();
                        } else {
                            reject(`Deploy failed. Detail: The App update feature has not assigned to ${sAppId}. Please assign this feature in your app configuration first and then redeploy.`);
                        }
                    } else if (instance._option["Create"]) { //trigger application create process
                        console.log(`${sAppId} doesn't exist on Mobile Services, start creating app.`);
                        instance.isNewApp = true;
                        resolve();
                    } else {
                        console.log(instance.deployArgs.marker() ? `${instance.deployArgs.marker()} ${aList.join(" ")}` : aList.join(" "));
                        reject(`Not found ${sAppId}`);
                    }
                }
            } else {
                reject(result.message);
            }
        });
    }

    _checkDestination() {
        utils.logInfo(`Checking destinations in Mobile Services...`, instance.deployArgs.marker());
        return new Promise(async function (resolve, reject) {
            let sAppId = instance._option["AppId"];
            let req;

            if (instance._option["Neo"]) {
                req = {
                    url: `${instance._option["AdminAPI"]}${NEO_ENDPOINT_API}${sAppId}/false&_=${randomInt++}`,
                    method: 'GET',
                    headers: {
                        'X-CSRF-Token': instance.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest',
                        "X-SMP-ENTITYNAME": "application",
                        'Cookie': instance.cookie
                    }
                };
            } else {
                reject("unsupport");
            }

            let response;
            try {
                response = await axios(req);
            } catch(e) {
                reject(e.message);
            }

            const result = instance._checkHttpResponse(response);
            if (result.pass) {
                let aDest, aList = [], length;
                const data = response.data;
                try {
                    aDest = data.appBeConnMap ? data.appBeConnMap : [];
                    aDest.forEach(dest => {
                        aList.push(dest.endpointName);
                    });
                    console.log(`get destinations ${NEO_MSG_SUCCESS_MARKER}.`);
                    utils.logInfo(JSON.stringify(aList), instance.deployArgs.marker(), true);
                    resolve();
                } catch (err) {
                    console.error(logger.getError(err));
                    reject(err);
                }
            } else {
                reject(result.message);
            }
        });
    }

    _checkBackendXml(destination) {
        utils.logInfo(`Checking backend xml in Mobile Services...`, instance.deployArgs.marker());
        return new Promise(async function (resolve, reject) {
            let sAppId = instance._option["AppId"];
            let req;

            let sConduit = `{"appId":"${sAppId}","encapsulateResponse":true,"method":"GET","url":"${destination}/$metadata"}`;
            if (instance._option["Neo"]) {
                req = {
                    url: `${instance._option["AdminAPI"]}/Admin/proxy/v1/conduitWithHeaderContent`,
                    method: 'GET',
                    headers: {
                        'X-CSRF-Token': instance.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest',
                        "X-SMP-CONDUIT-REQ-BODY": btoa(sConduit),
                        'Cookie': instance.cookie
                    }
                };
            } else {
                reject("unsupport");
            }

            let response;
            try {
                response = await axios(req);
            } catch(e) {
                reject(e.message);
            }

            const result = instance._checkHttpResponse(response);
            if (result.pass) {
                const data = response.data;
                try {
                    let xml = data.bodyBase64;
                    console.log(`get xml ${NEO_MSG_SUCCESS_MARKER}.`);
                    utils.logInfo(xml, instance.deployArgs.marker(), true)
                    resolve()

                } catch (err) {
                    console.error(logger.getError(err));
                    reject(err);
                }
            } else {
                reject(result.message);
            }
        });
    }

    _getServices() {
        return new Promise(async function (resolve, reject) {
            if (instance.isNewApp) {
                utils.logInfo(`Retrieving services...`, instance.deployArgs.marker());
                instance._services = [];
                var sURI = `${instance._option["AdminAPI"]}${CF_SERVICES_API}?_=${randomInt++}`;
                let req = {
                    url: sURI,
                    method: 'GET',
                    headers: {
                        'Authorization': instance.deployArgs.cfToken(),
                        'X-Requested-With': 'XMLHttpRequest',
                        "Content-Type": 'application/json'
                    }
                };

                let response;
                try {
                    response = await axios(req);
                } catch(e) {
                    console.error(logger.getError('Failed to get mobile services with error:' + e.message));
                    reject('get mobile servies failed');
                }
                const result = instance._checkHttpResponse(response);
                if (result.pass) {
                    console.info(`Retrieve services successfully.`);
                    instance._services = response.data;
                    resolve(instance._services);
                } else {
                    console.error(logger.getError('Failed to get services with server response:' + JSON.stringify(response.data)));
                    reject(result.message);
                }
            } else {
                resolve(true);
            }
        });
    }

    _prepareMobileApp() {
        utils.logInfo(`Preparing application in Mobile Services...`, instance.deployArgs.marker())
        return new Promise(async function (resolve, reject) {
            if (instance.isNewApp) {
                let req, templateAppJson;
                let name = instance._option["AppId"];

                if (instance.deployArgs.neo()) {
                    if (instance.deployArgs.neo()) {
                        reject('not support create application on neo Mobile Services yet.');
                    }
                } else {
                    let DisplaName = name.replace(/(\.|_|-)/g, ' ');
                    let uris = `https://cfapps.${instance.loginInfo.target.substring(15)}`;
                    let xsuaa = instance._option["Uaa"];

                    let templateAppFile = path.join(utils.getRootPath(), 'deployer', 'template', "msapp.json");
                    let templateAppContent = fs.readFileSync(templateAppFile).toString();
                    templateAppContent = templateAppContent.replace("{Name}", name);
                    templateAppContent = templateAppContent.replace("{DisplaName}", DisplaName);
                    templateAppContent = templateAppContent.replace("{URIS}", uris);

                    templateAppJson = JSON.parse(templateAppContent);
                    if (instance._services) {
                        for (let i = templateAppJson.mobileServices.length - 1; i >= 0; i--) {
                            let bFound = false;
                            for (let j = 0; j < instance._services.length; j++) {
                                if (instance._services[j].name === templateAppJson.mobileServices[i].name) {
                                    bFound = true;
                                    templateAppJson.mobileServices[i].plan = instance._services[j].plans[0].name;
                                }
                            }
                            if (!bFound) {
                                templateAppJson.mobileServices.splice(i, 1);// remove the unsupport service
                            }
                        }
                    }
                    if (xsuaa) {
                        templateAppJson["xsuaaConfig"] = {
                            sharedXsuaaInstance: xsuaa
                        };
                    }
                    req = {
                        url: `${instance._option["AdminAPI"]}app?async=true`,
                        method: 'POST',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Authorization': instance.deployArgs.cfToken(),
                            'Connection': 'keep-alive'
                        },
                        body: templateAppJson,
                        json: true
                    };
                }

                let response;
                try {
                    response = await axios.post(req.url, req.body, req);
                    
                } catch(e) {
                    console.error(logger.getError('Failed to create app with error:' + e.message));
                    reject('create app failed');
                }

                const result = instance._checkHttpResponse(response);
                if (result.pass) {
                    utils.logInfo(`Create mobile application successfully`, instance.deployArgs.marker());
                    resolve(response.data);
                } else {
                    console.error(logger.getError('Failed to create app with server response:' + JSON.stringify(response.data)));
                    reject(response.data.message ? response.data.message : result.message);
                }

            } else {
                resolve(true);
            }
        });
    }


    _prepareMobileDest() {
        return new Promise(function (resolve, reject) {
            if (instance._option["DestinationName"] && instance._option["DestinationUrl"]) {
                if (instance.deployArgs.neo()) {
                    reject('not support create destination on neo Mobile Services yet.');
                }
                let templateFile = path.join(utils.getRootPath(), 'deployer', 'template', "msdest.json");
                let templateContent = fs.readFileSync(templateFile).toString();
                templateContent = templateContent.replace("{Name}", instance._option["DestinationName"]);
                templateContent = templateContent.replace("{URL}", instance._option["DestinationUrl"]);
                let templateJson = JSON.parse(templateContent);
                instance._getMobileDest().then(response => {
                    if (response && response.parameters) {
                        let parameters = response.parameters;
                        if (parameters.endpointConfigurations && parameters.endpointConfigurations.length > 0) {
                            let length = parameters.endpointConfigurations.length;
                            for (let i = length - 1; i >= 0; i--) {
                                if (parameters.endpointConfigurations[i]["endPointName"] === instance._option["DestinationName"]) {
                                    parameters.endpointConfigurations.splice(i, 1);
                                }
                            }
                        }
                        parameters.endpointConfigurations.push(templateJson);
                        instance._setMobileDest(parameters).then(ret => {
                            resolve(ret);
                        })
                            .catch(error => {
                                return reject(error);
                            });
                    }
                })
                    .catch(error => {
                        return reject(error);
                    });
            } else {
                resolve(true);
            }
        });
    }

    _getMobileDest() {
        return new Promise(async function (resolve, reject) {
            utils.logInfo(`Retrieving mobile destination...`, instance.deployArgs.marker());

            var sURI = `${instance._option["AdminAPI"]}app/${instance._option["AppId"]}/service/proxy?_=${randomInt++}`;

            let req = {
                url: sURI,
                method: 'GET',
                headers: {
                    'Authorization': instance.deployArgs.cfToken(),
                    'X-Requested-With': 'XMLHttpRequest',
                    "Content-Type": 'application/json'
                }
            };


            let response;
            try {
                response = await axios(req);
            } catch(e) {
                console.error(logger.getError('Failed to get destination with error:' + e.message));
                reject('get destination failed');
            }

            const result = instance._checkHttpResponse(response);
            if (result.pass) {
                console.info(`Retrieve mobile destinations successfully.`);
                resolve(response.data);
            } else {
                console.error(logger.getError('Failed to get destination with server response:' + JSON.stringify(response.data)));
                reject(result.message);
            }
        });
    }

    _setMobileDest(oDest) {
        return new Promise(async function (resolve, reject) {
            utils.logInfo(`Updating mobile destination...`, instance.deployArgs.marker());
            var sURI = `${instance._option["AdminAPI"]}app/${instance._option["AppId"]}/service/proxy`;
            let req = {
                url: sURI,
                method: 'PUT',
                headers: {
                    'Authorization': instance.deployArgs.cfToken(),
                    'X-Requested-With': 'XMLHttpRequest',
                    "Content-Type": 'application/json'
                },
                body: { parameters: oDest },
                json: true
            };

            let response;
            try {
                response = await axios.put(req.url,req.body, req);
            } catch(e) {
                console.error(logger.getError('Failed to set destination with error:' + e.message));
                reject('set destination failed');
            }
            const result = instance._checkHttpResponse(response);
            if (result.pass) {
                console.info(`Update mobile destination successfully.`);
                resolve(response.data);
            } else {
                console.error(logger.getError('Failed to set destination with server response:' + JSON.stringify(response.data)));
                reject(result.message);
            }
        });
    }

    _upload2ms() {
        return new Promise(async function (resolve, reject) {
            let sBundleZipfile = instance.sBundleZipfile;
            if (instance.deployArgs.zip()) {
                sBundleZipfile = instance.deployArgs.zip();
            } else {
                sBundleZipfile = instance.sBundleZipfile;
            }
            if (fs.existsSync(sBundleZipfile)) {
                utils.logInfo(`Uploading build to Mobile Services...`, instance.deployArgs.marker());
                let sAppId = instance._option["AppId"];
                let cfToken = instance.deployArgs.cfToken();


                let oFileData = {
                    file: fs.createReadStream(sBundleZipfile),
                    _charset_: 'UTF-8'
                };

                let upLoadURL;
                if (instance.deployArgs.neo()) {
                    upLoadURL = `${instance._option["AdminAPI"]}Admin/kapsel/jaxrs/KapselApp/${sAppId}?_=${randomInt++}`;
                } else {
                    upLoadURL = `${instance._option["AdminAPI"]}app/${sAppId}/service/app-update/Admin/kapsel/jaxrs/KapselApp/${sAppId}?_=${randomInt++}`;
                }
                let req = {
                    url: upLoadURL,
                    method: 'POST',
                    headers: {},
                    formData: oFileData
                };
                if (instance.deployArgs.neo()) {
                    req.headers = {
                        'X-CSRF-Token': instance.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest',
                        "X-SMP-ENTITYNAME": "application",
                        'Cookie': instance.cookie,
                        'Content-Type': 'multipart/form-data'
                    }
                } else {
                    req.headers = {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Authorization': cfToken,
                        'Connection': 'keep-alive',
                        'Content-Type': 'multipart/form-data'
                    }
                }

                let response;
                try {
                    response = await axios.post(upLoadURL, oFileData, req);
                } catch(e) {
                    console.error(logger.getError(`Failed to upload with error:${e.message}`));
                    reject('upload failed');
                }
                const result = instance._checkHttpResponse(response);
                if (result.pass) {
                    let data = response.data;
                    if (typeof data === "string") {
                        data = JSON.parse(data)
                    }
                    if (Array.isArray(data) && data.length > 0 && data[data.length - 1].pendingVersions.length > 0) {
                        instance.iRevision = data[data.length - 1].pendingVersions[data[data.length - 1].pendingVersions.length - 1].revision;
                    }
                    console.log(`Uploaded to Mobile Services successfully with revision:` + logger.getPrompt(instance.iRevision));
                    resolve();
                } else {
                    reject(result.message);
                }
            } else {
                console.error(logger.getError(`Failed to find bundle result zip file: ${sBundleZipfile}`));
                reject();
            }
        });
    }

    _deploy2ms() {
        utils.logInfo(`Deploying new version in Mobile Services...`, instance.deployArgs.marker());
        return new Promise(async function (resolve, reject) {
            let sAppId = instance._option["AppId"];
            let cfToken = instance.deployArgs.cfToken();
            let upLoadURL;
            if (instance.deployArgs.neo()) {
                upLoadURL = `${instance._option["AdminAPI"]}Admin/kapsel/jaxrs/KapselApp/${sAppId}`;
            } else {
                upLoadURL = `${instance._option["AdminAPI"]}app/${sAppId}/service/app-update/Admin/kapsel/jaxrs/KapselApp/${sAppId}`;
            }
            let deployURL = `${upLoadURL}/promotePending`;
            let oRevision = {
                "platform": "AppModeler",
                "revisions": [instance.iRevision]
            };
            let req = {
                url: deployURL,
                method: 'PUT',
                headers: {},
                json: [oRevision]
            };
            if (instance.deployArgs.neo()) {
                req.headers = {
                    'X-CSRF-Token': instance.csrfToken,
                    'X-Requested-With': 'XMLHttpRequest',
                    "X-SMP-ENTITYNAME": "application",
                    'Cookie': instance.cookie
                }
            } else {
                req.headers = {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Authorization': cfToken,
                    'Connection': 'keep-alive'
                }
            }

            let response;
            try {
                response = await axios.put(deployURL,req.json, req);
            } catch(e) {
                console.error(logger.getError('Failed to deploy with error:' + e.message));
                reject('deploy failed');
            }
            const result = instance._checkHttpResponse(response);
            if (result.pass) {
                const data = response.data;
                let revision = data[data.length - 1].currentVersion.revision;
                console.log(`Deploy ${NEO_MSG_SUCCESS_MARKER}! The current revision is ` + logger.getPrompt(revision));
                resolve(data);
            } else {
                console.error(logger.getError('Failed to deploy with server response:' + JSON.stringify(data)));
                reject(result.message);
            }
        });
    }

    _checkHttpResponse(httpResponse) {
        let unAuthenticate = "Unauthenticate";
        let result = {};
        if (!httpResponse) {
            result.pass = false;
            result.message = "Internal Server Error";
            return result;
        } else {
            result = {
                pass: false,
                message: "Failed with response code:" + httpResponse.status + " detail:" + httpResponse.statusText
            };
        }
        switch (httpResponse.status) {
            case 200:
            case 201:
            case 202:
                result.pass = true;
                if (httpResponse.headers['com.sap.cloud.security.login'] === 'login-request') {
                    result.pass = false;
                    result.message = unAuthenticate;
                }
                break;
            case 403:
            case 401:
                result.pass = false;
                result.message = unAuthenticate;
                break;
            case 500:
                result.pass = false;
                result.message = "Internal Server Error";
                break;
        }
        return result;
    }

    _getLoginInfo() {
        const homedir = os.homedir();
        instance.loginInfo = {
            target: "",
            org: "",
            orgName: "",
            space: "",
            spaceName: "",
            cpmsEndpoint: "",
            host: ""
        };

        if (instance.deployArgs.neo()) {
            return true;
        } else {
            let configFile = path.join(homedir, ".cf/config.json");
            if (fs.existsSync(configFile)) {
                let data = fs.readFileSync(configFile).toString();
                let oLogin = JSON.parse(data);
                instance.loginInfo.target = _.get(oLogin, "Target", "");
                instance.loginInfo.org = _.get(oLogin, "OrganizationFields.GUID", "");
                instance.loginInfo.orgName = _.get(oLogin, "OrganizationFields.Name", "");
                instance.loginInfo.space = _.get(oLogin, "SpaceFields.GUID", "");
                instance.loginInfo.spaceName = _.get(oLogin, "SpaceFields.Name", "");

                let host = instance.loginInfo.target;
                if (instance.loginInfo.target.substring(0, 15) === 'https://api.cf.') {
                    host = instance.loginInfo.target.substring(15);
                }
                instance.loginInfo.host = host;

                let aHost = host.split(".");
                aHost[0] = aHost[0].replace(/([a-zA-Z0-9]+)(-\d{3})$/i, "$1");
                let newHost = aHost.join(".");

                if (instance.deployArgs.preview()) {
                    instance.loginInfo.cpmsEndpoint = `https://mobile-service-cockpit-api-preview.cfapps.${newHost}/cockpit/v1/org/${instance.loginInfo.org}/space/${instance.loginInfo.space}/`;
                } else {
                    instance.loginInfo.cpmsEndpoint = `https://mobile-service-cockpit-api.cfapps.${newHost}/cockpit/v1/org/${instance.loginInfo.org}/space/${instance.loginInfo.space}/`;
                }
                return true;
            } else {
                return false;
            }
        }
    }

    _showOnbloardingUrl(show) {
        return new Promise(async function (resolve, reject) {
            if (!instance.deployArgs.showqr() && show !== true) {
                resolve();
            } else {
                let sAppId = instance._option["AppId"];
                let req;
                if (instance.deployArgs.neo()) {
                    req = {
                        url: `${instance._option["AdminAPI"]}mobileservices/Admin/Discovery/ApplicationConfigurations/getApplicationConfiguration?_=${randomInt++}`,
                        method: 'GET',
                        json: true,
                        headers: {
                            'X-CSRF-Token': instance.csrfToken,
                            'X-Requested-With': 'XMLHttpRequest',
                            'x-sms-appconfigid': `${sAppId}:1.0`,
                            'Cookie': instance.cookie
                        }
                    };
                } else {
                    let cfToken = instance.deployArgs.cfToken();
                    req = {
                        url: instance._option["AdminAPI"] + "app/" + sAppId,
                        method: 'GET',
                        json: true,
                        headers: {
                            'Authorization': cfToken,
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    };
                }

                let response;
                try {
                    response = await axios(req);
                } catch(e) {
                    reject(e.message);
                }
                const result = instance._checkHttpResponse(response);
                if (result.pass) {
                    try {
                        let sOnboardingUrl = await instance._getOnboardingURL(response.data);
                        console.log(`get onboarding URL ${NEO_MSG_SUCCESS_MARKER}.`);
                        utils.logInfo(sOnboardingUrl, instance.deployArgs.marker(), true);
                        // qrcode.toString(sOnboardingUrl, {}, function (err, url) {
                        // console.log(url);
                        let qrcodeImgPath = path.join(instance.deployArgs.project(), utils.BUILD_TEMP_FOLDER, QRCODE_IMAGE_NAME);
                        qrcode.toFile(qrcodeImgPath, sOnboardingUrl, {}, function (err) {
                            if (err) reject(err);
                            console.log(`The QRCode image location: ${qrcodeImgPath}`);
                            resolve();
                        });
                        // });
                    } catch (err) {
                        reject(err);
                    }
                } else {
                    reject(result.message);
                }
            }
        });
    }

    async _getOnboardingURL(data) {
        if (!instance.deployArgs.neo() && data.security && data.security.qrcode_signature_settings
            && data.security.qrcode_signature_settings.enabled) {
            return instance._getSignedOnboardingURL(data);
        } else {
            return instance._getUnsignedOnboardingURL(data);
        }
    }

    async _getSignedOnboardingURL(data) {
        return new Promise(async function (resolve, reject) {
            let sAppId = data.name;
            let cfToken = instance.deployArgs.cfToken();
            let req = {
                url: instance._option["AdminAPI"] + "app/" + sAppId + "/onboardingInfo",
                method: 'GET',
                json: true,
                headers: {
                    'Authorization': cfToken,
                    'X-Requested-With': 'application/json'
                }
            };

            let response;
            try {
                response = await axios(req);
            } catch(e) {
                reject(e.message);
            }
            const result = instance._checkHttpResponse(response);
            let errRet = "Failed to get onboarding info."
            if (result.pass) {
                const data = response.data;
                if (data && (data.iOsOnboardingUrl || data.iOsInAppConfiguration)) {
                    let url = data.iOsOnboardingUrl ? data.iOsOnboardingUrl : data.iOsInAppConfiguration;
                    if (url) {
                        resolve(url);
                    } else {
                        reject(errRet);
                    }
                }
            } else {
                reject(errRet);
            }
        });
    }

    async _getUnsignedOnboardingURL(data) {
        return new Promise(async function (resolve, reject) {
            let oArg = {
                "AppId": "",
                "SapCloudPlatformEndpoint": "",
                "ClientId": "",
                "RedirectUrl": "",
                "AuthorizationEndpointUrl": "",
                "TokenUrl": "",
                "multiUser": false
            };
            let sFormat = "sapmobilesvcs://?AppId={AppId}&ClientId={ClientId}&SapCloudPlatformEndpoint={SapCloudPlatformEndpoint}&ServerUrl={ServerUrl}&AuthorizationEndpointUrl={AuthorizationEndpointUrl}&RedirectUrl={RedirectUrl}&TokenUrl={TokenUrl}&multiUser={multiUser}";
            let bHasStorage = false;
            let bHasAppUpdate = false;

            if (instance.deployArgs.neo()) {
                oArg.AppId = data.appID;
                oArg.ServerUrl = data.host;
                oArg.SapCloudPlatformEndpoint = data.host;
                if (data.host && data.protocol && data.host.indexOf(data.protocol + "://") < 0) {
                    oArg.ServerUrl = data.protocol + "://" + data.host;
                    oArg.SapCloudPlatformEndpoint = data.protocol + "://" + data.host;
                }
                if (data.auth && data.auth.length && data.auth[0].config) {
                    if (data.auth[0].config && data.auth[0].config["oauth2.clients"] &&
                        data.auth[0].config["oauth2.clients"].length) {
                        var aClients = data.auth[0].config["oauth2.clients"];
                        oArg.ClientId = aClients[0].clientID;
                        oArg.RedirectUrl = aClients[0].redirectURL;
                    }
                    oArg.AuthorizationEndpointUrl = data.auth[0].config["oauth2.authorizationEndpoint"];
                    oArg.TokenUrl = data.auth[0].config["oauth2.tokenEndpoint"];
                }
                oArg.multiUser = !!data.multiUser;
            } else {
                oArg.AppId = data.name;
                oArg.SapCloudPlatformEndpoint = (data.uris && data.uris.length) ? data.uris[0] : "";
                oArg.ServerUrl = (data.uris && data.uris.length) ? data.uris[0] : "";
                if (data.security && data.security.oauth_settings && data.security.oauth_settings.length) {
                    oArg.ClientId = data.security.oauth_settings[0].client_id;
                    oArg.RedirectUrl = data.security.oauth_settings[0].redirect_url;
                }
                if (data.apis && data.apis.length) {
                    data.apis.forEach(function (api) {
                        if (api.type === "OAuth2_Authorization") {
                            oArg.AuthorizationEndpointUrl = api.url;
                        }
                        if (api.type === "OAuth2_Token") {
                            oArg.TokenUrl = api.url;
                        }
                    });
                }

                if (data.services && data.services.length) {
                    let aService = data.services;
                    for (var i = 0; i < aService.length; i++) {
                        if (aService[i].name === "app-update") {
                            bHasAppUpdate = true;
                        }

                        if (aService[i].name === "storage") {
                            bHasStorage = true;
                        }
                    }
                }

            }
            if (bHasStorage) {
                oArg.multiUser = await instance._getMultiUserInfo();
            }

            for (var key in oArg) {
                //all parameters must be replaced;
                if (oArg[key] === undefined) oArg[key] = "";
                var reg = new RegExp("({" + key + "})", "g");
                sFormat = sFormat.replace(reg, oArg[key]);
            }
            resolve(sFormat);
        });
    }

    _getMultiUserInfo() {
        return new Promise(async function (resolve, reject) {
            let appId = instance._option["AppId"];
            let req;
            if (instance.deployArgs.neo()) {
                req = {
                    url: `${instance._option["AdminAPI"]}app/${appId}/service/storage/mobileservices/origin/hcpms/Storage/v1/admin/ApplicationStorageSet('${appId}')?_=${randomInt++}`,
                    method: 'GET',
                    json: true,
                    headers: {
                        'X-CSRF-Token': instance.csrfToken,
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                };
            } else {
                let cfToken = instance.deployArgs.cfToken();
                req = {
                    url: `${instance._option["AdminAPI"]}app/${appId}/service/storage/mobileservices/origin/hcpms/Storage/v1/admin/ApplicationStorageSet('${appId}')?_=${randomInt++}`,
                    method: 'GET',
                    json: true,
                    headers: {
                        'Authorization': cfToken,
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                };
            }

            let response;
            try {
                response = await axios(req);
            } catch(e) {
                resolve(false);
            }
            const result = instance._checkHttpResponse(response);
            if (result.pass) {
                const data = response.data;
                try {
                    if (data.mobileservices && data.mobileservices.settingsExchange && data.mobileservices.settingsExchange.sharedDevices) {
                        resolve(!!data.mobileservices.settingsExchange.sharedDevices.allowUploadPendingChangesFromPreviousUser);
                    } else {
                        resolve(false);
                    }
                } catch (err) {
                    resolve(false);
                }
            } else {
                resolve(false);
            }
        });
    }

    _checkService(serviceUrl) {
        utils.logInfo(`Checking destination service ${serviceUrl}`, instance.deployArgs.marker());
        return new Promise(async function (resolve, reject) {
            let req = {
                url: `${serviceUrl}`,
                method: 'GET',
                headers: {}
            };

            req.headers = {
                'X-Requested-With': 'XMLHttpRequest'
            }

            let response;
            try {
                response = await axios(req);
            } catch(e) {
               //todo
            }
            const result = instance._checkHttpResponse(response);
            if (response && response.statusCode === 404) {
                reject(`Please make sure the backend service was deployed already. Failed to access ${serviceUrl} with 404 error code.`);
            } else {
                resolve(result.pass);
            }
        });
    }

    _getCsrfToken(log) {
        return new Promise(async function (resolve, reject) {
            if (instance._option["Neo"]) {
                utils.logInfo(`Fetching token from Mobile Services...`, instance.deployArgs.marker());
                let req = {
                    url: `${instance._option["AdminAPI"]}${NEO_GET_TOKEN}`,
                    method: 'GET',
                    headers: {
                        'X-CSRF-Token': 'Fetch',
                        'Connection': 'keep-alive',
                        'X-Requested-With': 'fake'
                    }
                };

                if (instance._option["User"] && instance._pwd) {
                    req.headers['Authorization'] = 'Basic ' + btoa(instance._option["User"] + ':' + instance._pwd);
                } else if (instance.cookie && instance.csrfToken) {
                    req.headers['X-CSRF-Token'] = instance.csrfToken;
                    req.headers['Cookie'] = instance.cookie;
                }

                const sDefaultMsg = 'get X-CSRF-Token failed:';
                let response;
                try {
                    response = await axios(req);
                } catch(e) {
                    console.error(logger.getError(`${sDefaultMsg}:${e.message}`));
                    reject(`${sDefaultMsg}:${e.message}`);
                }
                const result = instance._checkHttpResponse(response);
                
                if (result.pass) {
                    let data = response.data;
                    if (typeof data === "string") {
                        data = JSON.parse(data);
                    }
                    if (data.version !== undefined) {
                        instance.csrfToken = response.headers['x-csrf-token'] || instance.csrfToken;
                        instance.cookie = response.headers['set-cookie'] || instance.cookie;
                        if (log) {
                            console.log(`get X-CSRF-Token ${NEO_MSG_SUCCESS_MARKER}.`);
                            utils.logInfo(instance.csrfToken, instance.deployArgs.marker(), true);
                            utils.logInfo(JSON.stringify(instance.cookie), instance.deployArgs.marker(), true);
                        }
                        resolve();
                    } else {
                        reject(sDefaultMsg);
                    }
                } else {
                    reject(result.message);
                }
            } else {
                resolve();
            }
        });
    }

    _askUserInput() {
        return new Promise(function (resolve, reject) {
            let schema = [];

            if (!instance._option["AdminAPI"]) {
                schema.push({
                    name: "AdminAPI",
                    required: true
                });
            }
            if (!instance._option["User"]) {
                schema.push({
                    name: "User",
                    required: true
                });
            }
            if (!instance._pwd) {
                schema.push({
                    name: "Password",
                    hidden: true
                });
            }

            prompt.start();
            prompt.get(schema, function (err, result) {
                if (err) {
                    reject();
                }
                if (result.AdminAPI) {

                    instance._option["AdminAPI"] = result.AdminAPI.endsWith("/") ? result.AdminAPI : result.AdminAPI + "/";
                }
                if (result.User) {
                    instance._option["User"] = result.User;
                }
                if (result.Password) {
                    instance._pwd = result.Password;
                }
                resolve();
            });
        });
    }

    _getCapSrvRoute(srvName) {
        let sCommand = `cf app ${srvName}`;
        try {
            console.log(sCommand);
            let ret = execSync(sCommand);
            let output = ret.toString();
            console.log(output);
            if (output && output.indexOf("FAILED") < 0) {
                output = output.substr(output.indexOf("\nroutes:") + 9);
                output = output.substr(0, output.indexOf("\n")).trim();
                if (output && !output.startsWith("https://")) {
                    output = "https://" + output;
                }
                console.log(`Get cap service url from BTP: ${output}`);
                return output;
            } else {
                return "";
            }
        } catch (error) {
            console.log(error.message);
            return "";
        }
    }
};

exports.DeployMS = DeployMS;