/* eslint-disable no-param-reassign */
const { getExampleValues } = require('./examples');
const { getIntersectionSchema } = require('./intersection');
const { convertSchematicValueToObjectSchema } = require('./schematicValues');
const { getUnionSchema } = require('./union');
const { unionValues, intersectionValues, includesValue } = require('./utils/array');
const { pickBy } = require('./utils/object');
const {
  makeResult, makeError, stringifyType, stringify,
} = require('./utils/shortcuts');
const { isSchemaAssignable, getSchemaAssignmentErrors } = require('./validation');

/**
 * Resolves the result schema when accessing a property of the value, described by the
 * given schema, using the given accessor schema. Returns an object with two
 * properties: `schema` is the result schema and `errors` is an array of any errors
 * with the accessor operation.
 * @param {object} operandSchema Schema of the value whose property is being accessed
 * @param {object} accessorSchema Schema of the accessor (the property to get)
 * @param tolerant {boolean} if true, then treat unknown values as wildcards
 */
function resolveObjectMemberAccessor(operandSchema, accessorSchema, tolerant) {
  operandSchema = convertSchematicValueToObjectSchema(operandSchema);
  if (!operandSchema) {
    // Accessing an unknown type
    return makeResult({});
  }
  const operandAnyOf = operandSchema.anyOf;
  if (operandAnyOf) {
    // The accessor schema must be able to access all of the operand schemas
    if (!operandAnyOf.length) {
      return makeResult({}, [{ message: 'Type has no properties' }]);
    }
    const resolved = operandAnyOf.map(
      (schema) => resolveObjectMemberAccessor(schema, accessorSchema, tolerant),
    );
    const successful = resolved.filter(({ errors }) => !errors.length);
    if (successful.length < operandAnyOf.length) {
      return makeResult(
        getUnionSchema(successful.map((result) => result.schema)),
        unionValues(...resolved.map((result) => result.errors)),
      );
    }
    return makeResult(getUnionSchema(successful.map((result) => result.schema)));
  }
  const operandAllOf = operandSchema.allOf;
  if (operandAllOf) {
    // The accessor schema must be able to access some of the operand schemas
    if (!operandAllOf.length) {
      return makeResult({}, [{ message: 'Type has no properties' }]);
    }
    const resolved = operandAllOf.map(
      (schema) => resolveObjectMemberAccessor(schema, accessorSchema, tolerant),
    );
    const successful = resolved.filter(({ errors }) => !errors.length);
    if (!successful.length) {
      return makeResult(
        getIntersectionSchema(resolved.map((result) => result.schema)),
        unionValues(...resolved.map((result) => result.errors)),
      );
    }
    return makeResult(getIntersectionSchema(successful.map((result) => result.schema)));
  }
  if (!operandSchema.type) {
    // Accessing an unknown type
    return { schema: {}, errors: [] };
  }
  const operandType = operandSchema.type;
  const accessorType = accessorSchema && accessorSchema.type;
  if (operandType === 'array') {
    // Preferring to use COUNT instead of `length` property of an array
    if (isSchemaAssignable(accessorSchema, { type: 'string', enum: ['length'] })) {
      return makeResult({ type: 'number' }, [
        makeError('Use `COUNT` function to get the length of a list instead of using the "length" property'),
      ]);
    }
    // Allow taking an item from an array
    const itemsSchema = operandSchema.items || {};
    if (isSchemaAssignable(accessorSchema, { type: 'number' })) {
      return makeResult(itemsSchema);
    }
    if (accessorType) {
      return makeResult(itemsSchema, [
        makeError(`Should use a number to access a list item instead of ${stringifyType(accessorType)}`),
      ]);
    }
    return makeResult(itemsSchema, [makeError('Should use a number to access a list item')]);
  }
  if (operandType === 'string') {
    // Allow taking the length of a string
    if (isSchemaAssignable(accessorSchema, { type: 'string', enum: ['length'] })) {
      return makeResult({ type: 'number' }, [
        makeError('Use `LENGTH` function to get the length of a text instead of using the "length" property'),
      ]);
    }
    // Allow taking a character from a string
    if (isSchemaAssignable(accessorSchema, { type: 'number' })) {
      const schema = { type: 'string' };
      const operandEnum = operandSchema.enum;
      const accessorEnum = accessorSchema.enum;
      const operandExamples = operandEnum ? [] : getExampleValues(operandSchema);
      const accessorExamples = getExampleValues(accessorSchema);
      if (accessorEnum && accessorEnum.length > 0 && operandEnum) {
        schema.enum = operandEnum.map((str) => str[accessorEnum[0]]);
      }
      if (accessorExamples.length > 0 && operandExamples.length > 0) {
        schema.examples = operandExamples.map((str) => str[accessorExamples[0]]);
      }
      return makeResult(schema);
    }
    if (accessorType) {
      return makeResult({ type: 'string' }, [
        makeError(`Should use a number to get a character of a text instead of ${stringifyType(accessorType)}`),
      ]);
    }
    return makeResult({ type: 'string' }, [
      makeError('Should use a number to get a character of a text'),
    ]);
  }
  if (operandType === 'value') {
    return makeResult({ type: 'value' });
  }
  if (operandType === 'json' || operandType === 'schema') {
    return makeResult({ type: 'json' });
  }
  if (operandType !== 'object') {
    // Accessing an unsupported type
    const propertyNames = accessorSchema && accessorSchema.enum;
    if (!propertyNames) {
      return makeResult({}, [
        makeError(`Cannot access properties of ${stringifyType(operandType)}`),
      ]);
    }
    if (propertyNames.length === 1) {
      return makeResult({}, [
        makeError(`Value of ${stringifyType(operandType)} does not have property ${stringify(propertyNames[0])}`),
      ]);
    }
    return makeResult({}, [
      makeError(`Value of ${stringifyType(operandType)} does not have properties: ${propertyNames.map((prop) => stringify(prop)).join(', ')}`),
    ]);
  }
  const { properties, additionalProperties } = operandSchema;
  const exampleObjects = (operandSchema.examples || [])
    .concat([operandSchema.default]);
  const enumObjects = operandSchema.enum;
  // The accessor type must be one of the object keys
  const requiredAccessorSchema = { type: 'string' };
  if (properties && !additionalProperties) {
    requiredAccessorSchema.enum = Object.keys(properties);
  }
  // Allow indexing objects with strings
  const errors = getSchemaAssignmentErrors(accessorSchema, requiredAccessorSchema, { tolerant });
  // The result schema is an union of all schemas for each object property
  const propertyEnum = accessorSchema.enum || (properties ? Object.keys(properties) : []);
  const valueSchemas = propertyEnum
    .map((value) => (properties && properties[value]) || additionalProperties || null)
    .filter((valSchema) => valSchema != null)
    .concat(additionalProperties ? [additionalProperties] : []);
  let resultSchema = getUnionSchema(valueSchemas);
  if (!resultSchema) {
    return makeResult(resultSchema, errors);
  }
  // Get example values from example objects
  const resultExamples = [];
  exampleObjects.forEach((obj) => {
    if (obj != null && typeof obj === 'object') {
      propertyEnum.forEach((propName) => {
        const value = obj[propName];
        if (value != null && !includesValue(resultExamples, value)) {
          resultExamples.push(value);
        }
      });
    }
  });
  if (resultExamples.length) {
    resultSchema = { ...resultSchema, examples: resultExamples };
  }
  // Get enum values from enum objects
  if (enumObjects && !enumObjects.some((obj) => obj == null || typeof obj !== 'object')) {
    const resultEnum = [];
    enumObjects.forEach((obj) => {
      propertyEnum.forEach((propName) => {
        const value = obj[propName];
        if (!includesValue(resultEnum, value)) {
          resultEnum.push(value);
        }
      });
    });
    if (resultEnum.length) {
      resultSchema = { ...resultSchema, enum: resultEnum };
    }
  }
  return makeResult(resultSchema, errors);
}

/**
 * An useful shortcut to resolve a type for an property of an object, represented
 * by the given schema. Same than calling `resolveObjectMemberAccessor` using
 * a constant string type as an accessor schema.
 *
 * @param {object} schema schema object
 * @param {string} propertyName name of the property
 * @param tolerant {boolean} if true, then treat unknown values as wildcards
 */
function getObjectPropertySchema(schema, propertyName, tolerant) {
  const member = resolveObjectMemberAccessor(schema, { type: 'string', enum: [propertyName] }, tolerant);
  return member.errors.length && !tolerant ? null : member.schema || {};
}

/**
 * Returns an array of properties that the object represented by the schema can
 * possibly have. Note that in case of union (`anyOf`) types, not all the returned
 * properties are valid for every type.
 *
 * If the schema (or any of its allowed schemas) is not an object, or do not have
 * known properties, then this returns null.
 *
 * @param {object} schema schema object
 */
function getPossibleObjectSchemaProperties(schema) {
  if (!schema) {
    return null;
  }
  schema = convertSchematicValueToObjectSchema(schema);
  const { anyOf, allOf } = schema;
  const combinations = anyOf || allOf;
  if (combinations) {
    return combinations.reduce(
      (prevProperties, subSchema) => {
        const nextProperties = getPossibleObjectSchemaProperties(subSchema);
        if (prevProperties && nextProperties) {
          return unionValues(prevProperties, nextProperties);
        }
        return prevProperties || nextProperties;
      },
      null,
    );
  }
  const { type, properties } = schema;
  if (type === 'object' && properties) {
    return Object.keys(properties);
  }
  // Unknown properties
  return null;
}

/**
 * Returns an array of properties that the object represented by the schema
 * always has. This is a subset of properties returned by getPossibleObjectSchemaProperties.
 *
 * If the schema (or any of its allowed schemas) is not an object, then this returns null.
 * If the schema is an object without known properties, returns an empty array.
 *
 * @param {object} schema schema object
 */
function getRequiredObjectSchemaProperties(schema) {
  if (!schema) {
    return null;
  }
  schema = convertSchematicValueToObjectSchema(schema);
  const { anyOf, allOf } = schema;
  if (allOf) {
    return allOf.reduce(
      (prevProperties, subSchema) => {
        const nextProperties = getRequiredObjectSchemaProperties(subSchema);
        if (prevProperties && nextProperties) {
          return unionValues(prevProperties, nextProperties);
        }
        return prevProperties || nextProperties;
      },
      null,
    );
  }
  if (anyOf) {
    if (!anyOf.length) {
      return null;
    }
    const subProperties = anyOf.map(
      (subSchema) => getRequiredObjectSchemaProperties(subSchema),
    );
    return subProperties.reduce(
      (prevProperties, nextProperties) => {
        if (prevProperties && nextProperties) {
          return intersectionValues(prevProperties, nextProperties);
        }
        return null;
      },
    );
  }
  const { type, properties, required } = schema;
  if (type === 'schema') {
    return [];
  }
  if (type !== 'object') {
    return null;
  }
  if (required) {
    return required;
  }
  if (properties) {
    return Object.keys(properties);
  }
  return [];
}

function editObjectSchemaProperties(schema, edit) {
  if (!schema) {
    return null;
  }
  schema = convertSchematicValueToObjectSchema(schema);
  const { anyOf, allOf, type } = schema;
  if (anyOf) {
    return {
      ...schema,
      anyOf: anyOf.map((subSchema) => editObjectSchemaProperties(subSchema, edit)),
    };
  }
  if (allOf) {
    return {
      ...schema,
      allOf: allOf.map((subSchema) => editObjectSchemaProperties(subSchema, edit)),
    };
  }
  if (type !== 'object') {
    // Not an object schema
    return schema;
  }
  return edit(schema);
}

function filterObjectSchemaProperties(schema, callback) {
  return editObjectSchemaProperties(schema, (objSchema) => {
    const { properties, required } = objSchema;
    const newSchema = { ...objSchema };
    if (properties) {
      newSchema.properties = pickBy(properties, callback);
    }
    if (required) {
      newSchema.required = required.filter(callback);
    }
    return newSchema;
  });
}

/**
 * Takes a schema representing an object and returns an altered
 * schema for object that only includes the given property names.
 * All other properties from the original schema are omitted.
 * This also correctly handles union and intersection types.
 *
 * NOTE: The ordering of the keys will be altered to equal the given property name list!
 *
 * @param {Object} schema schema representing an object
 * @param {Array} propertyNames list of picked property names
 * @returns {Object} new schema representing an object with the picked properties
 */
function pickObjectSchemaProperties(schema, propertyNames) {
  return editObjectSchemaProperties(schema, (objSchema) => {
    const { properties, required } = objSchema;
    const newSchema = { ...objSchema };
    if (properties) {
      // Re-construct the properties to apply the new key order
      const newProperties = {};
      propertyNames.forEach((propName) => {
        const prop = properties[propName];
        if (typeof prop !== 'undefined') {
          newProperties[propName] = prop;
        }
      });
      newSchema.properties = newProperties;
    }
    if (required) {
      newSchema.required = propertyNames.filter((propName) => required.includes(propName));
    }
    return newSchema;
  });
}

/**
 * Takes a schema representing an object and returns an altered
 * schema for object that does not contain the given property names,
 * but contains all the other existing properties.
 * This also correctly handles union and intersection types.
 * @param {Object} schema schema representing an object
 * @param {Array} propertyNames list of omitted property names
 * @returns {Object} new schema representing an object without the omitted properties
 */
function omitObjectSchemaProperties(schema, propertyNames) {
  return filterObjectSchemaProperties(schema, (propName) => !propertyNames.includes(propName));
}

/**
 * Takes a schema representing an object and returns an altered
 * schema for object that has a required property with the given name
 * and the given schema as its schema. If the schema already defines
 * a property of the same name, it will be overridden (and made required).
 * This also correctly handles union and intersection types.
 * @param {Object} schema schema representing an object
 * @param {string} propertyName name of the property
 * @param {Object} propertySchema schema for the property value
 * @returns {Object} new schema representing an object with the property
 */
function setRequiredObjectSchemaProperty(schema, propertyName, propertySchema) {
  return editObjectSchemaProperties(schema, (objSchema) => {
    const { properties, required } = objSchema;
    const newSchema = { ...objSchema };
    newSchema.properties = { ...properties, [propertyName]: propertySchema };
    // Property name must be listed in required, if defined
    if (required) {
      newSchema.required = unionValues(required, [propertyName]);
    }
    return newSchema;
  });
}

/**
 * Takes a schema representing an object and returns an altered
 * schema for object that has a required property with the given name
 * and the given schema as its schema. If the schema already defines
 * a property of the same name, it will be overridden (and made required).
 * This also correctly handles union and intersection types.
 * @param {Object} schema schema representing an object
 * @param {string} propertyName name of the property
 * @param {Object} propertySchema schema for the property value
 * @returns {Object} new schema representing an object with the property
 */
function setOptionalObjectSchemaProperty(schema, propertyName, propertySchema) {
  return editObjectSchemaProperties(schema, (objSchema) => {
    const { properties, required } = objSchema;
    const newSchema = { ...objSchema };
    newSchema.properties = { ...properties, [propertyName]: propertySchema };
    // Property name must not be listed in required
    newSchema.required = (required || Object.keys(properties || {}))
      .filter((propName) => propName !== propertyName);
    return newSchema;
  });
}

/**
 * Takes a schema representing an object and returns an altered
 * schema for object that has all the given property names marked as required.
 * All other properties will become optional. You should only use existing property names.
 * This also correctly handles union and intersection types.
 * @param {Object} schema schema representing an object
 * @param {Array} requiredPropertyNames list of required property names
 * @returns {Object} new schema representing an object with the required properties
 */
function setRequiredObjectSchemaProperties(schema, requiredPropertyNames) {
  return editObjectSchemaProperties(schema, (objSchema) => {
    const newSchema = { ...objSchema };
    newSchema.required = requiredPropertyNames;
    return newSchema;
  });
}

module.exports.getObjectPropertySchema = getObjectPropertySchema;
module.exports.getPossibleObjectSchemaProperties = getPossibleObjectSchemaProperties;
module.exports.getRequiredObjectSchemaProperties = getRequiredObjectSchemaProperties;
module.exports.omitObjectSchemaProperties = omitObjectSchemaProperties;
module.exports.pickObjectSchemaProperties = pickObjectSchemaProperties;
module.exports.resolveObjectMemberAccessor = resolveObjectMemberAccessor;
module.exports.setOptionalObjectSchemaProperty = setOptionalObjectSchemaProperty;
module.exports.setRequiredObjectSchemaProperties = setRequiredObjectSchemaProperties;
module.exports.setRequiredObjectSchemaProperty = setRequiredObjectSchemaProperty;
