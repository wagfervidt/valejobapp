const { isSame, isEqual } = require('@sapappgyver/appgyver-schemas/utils/equality');

const empty = {};
const noSideEffects = [];

class FunctionInversion {
  constructor(params, result, invertIndexes) {
    this.params = params;
    this.result = result;
    this.invertIndexes = invertIndexes;
  }

  invertToParams(params, sideEffects = noSideEffects) {
    return {
      params: params.length < this.params.length
        ? params.concat(this.params.slice(params.length))
        : params,
      sideEffects,
    };
  }

  invertTo(resultParam, sideEffects) {
    if (this.invertIndexes.length !== 1) {
      throw new Error('Use `invertToParams` with more than 1 inverted parameter');
    }
    const [invertIndex] = this.invertIndexes;
    return this.invertToParams(
      this.params.map((param, index) => (index === invertIndex ? resultParam : param)),
      sideEffects,
    );
  }

  invertNothing() {
    return { params: this.params, sideEffects: noSideEffects };
  }

  getParamInverter(index, errorMsg) {
    const func = this.params[index];
    if (typeof func !== 'function' || typeof func.invert !== 'function') {
      throw new Error(errorMsg || `Cannot invert formula of parameter index ${index}`);
    }
    return func.invert;
  }
}

function mergeInversionUpdates(original, update1, update2) {
  if (isSame(update1, update2) || isSame(original, update2)) {
    return update1;
  }
  if (isSame(original, update1)) {
    return update2;
  }
  const isArray1 = Array.isArray(update1);
  const isArray2 = Array.isArray(update2);
  if (isArray1 && isArray2) {
    if (update1.length !== update2.length) {
      throw new Error(`Cannot invert with conflicting array lengths ${update1.length} and ${update2.length}`);
    }
    return update1.map((item1, index) => {
      const item2 = update2[index];
      const originalItem = Array.isArray(original) ? original[index] : undefined;
      return mergeInversionUpdates(originalItem, item1, item2);
    });
  }
  const isObj1 = update1 != null && typeof update1 === 'object' && !isArray1;
  const isObj2 = update2 != null && typeof update2 === 'object' && !isArray2;
  if (!isObj1 || !isObj2) {
    if (isEqual(update1, update2)) {
      return update1;
    }
    throw new Error(`Cannot invert with conflicting values ${JSON.stringify(update1)} and ${JSON.stringify(update2)}`);
  }
  const keys1 = Object.keys(update1);
  const keys2 = Object.keys(update2);
  const result = {};
  keys1.forEach((key) => {
    const originalValue = original != null ? original[key] : undefined;
    result[key] = keys2.includes(key)
      ? mergeInversionUpdates(originalValue, update1[key], update2[key])
      : update1[key];
  });
  keys2.forEach((key) => {
    if (!keys1.includes(key)) {
      result[key] = update2[key];
    }
  });
  return result;
}

function evaluateInversionValue(next, context) {
  const [type] = next;
  if (type === 'a') {
    // Array constructions are evaluated recursively
    return next.slice(1).map(item => evaluateInversionValue(item, context));
  }
  if (type === 'p') {
    const [, fn, paramContextNames, invert] = next;
    const wrap = (...args) => fn(...args);
    if (context) {
      wrap.invert = (nestedParams, nestedResult) => {
        const nestedContext = { ...context };
        paramContextNames.forEach((name, index) => {
          nestedContext[name] = nestedParams[index];
        });
        const nestedNext = invert(...nestedParams);
        const updates = { ...applyInverse(nestedResult, nestedNext, nestedContext) };
        const invertedParams = paramContextNames.map((name, index) => {
          const paramValue = Object.prototype.hasOwnProperty.call(updates, name)
            ? updates[name] : nestedParams[index];
          delete updates[name];
          return paramValue;
        });
        return [invertedParams, updates];
      };
    }
    return wrap;
  }
  // Otherwise assuming the concrete value at the 2nd item
  return next[1];
}

function applyInverse(result, next, context) {
  const [type, ...rest] = next;
  if (type === 'f') {
    return rest[1](result, context);
  }
  if (type === 'r') {
    // End of inverse chain
    const rootName = rest[1];
    return { [rootName]: result };
  }
  if (type === 'a') {
    // Inverse array construct [...]
    if (!Array.isArray(result)) {
      throw new Error('Cannot invert a non-list value to a list');
    }
    if (result.length !== rest.length) {
      throw new Error(`Cannot change the static list length from ${rest.length} to ${result.length}`);
    }
    let allUpdates = empty;
    rest.forEach((sub, index) => {
      const update = applyInverse(result[index], sub, context);
      allUpdates = mergeInversionUpdates(context, allUpdates, update);
    });
    return allUpdates;
  }
  if (type === 'o') {
    // Inverse object construct {...}
    if (typeof result !== 'object' || result == null || Array.isArray(result)) {
      throw new Error('Cannot invert a non-object value to an object');
    }
    const [obj] = rest;
    const keys = Object.keys(obj);
    const missingKeys = [];
    const allUpdates = keys.reduce((updates, key) => {
      const sub = obj[key];
      if (Object.prototype.hasOwnProperty.call(result, key)) {
        const update = applyInverse(result[key], sub, context);
        return mergeInversionUpdates(context, updates, update);
      }
      missingKeys.push(key);
      return updates;
    }, empty);
    if (missingKeys.length) {
      throw new Error(`Cannot invert with object missing required properties: ${missingKeys.map(key => JSON.stringify(key)).join(', ')}`);
    }
    return allUpdates;
  }
  if (type === 'c') {
    const [constant] = rest;
    if (typeof constant === 'function' || isEqual(constant, result)) {
      return empty;
    }
    throw new Error(`Cannot invert by altering a constant value ${JSON.stringify(constant)} to ${JSON.stringify(result)}`);
  }
  if (type === 'p') {
    return empty;
  }
  throw new Error('Invert failed due to invalid formula');
}

function createFunctionInverter(functionName, execute, inverter) {
  return (...paramTargets) => {
    if (!inverter) {
      throw new Error(`Function ${functionName} does not support inverse`);
    }
    const parameters = paramTargets.map(p => evaluateInversionValue(p));
    const invertIndexes = [];
    paramTargets.forEach(([type], index) => {
      if (type !== 'c' && type !== 'p') {
        invertIndexes.push(index);
      }
    });
    const value = execute(parameters);
    return ['f', value, (expectedResult, context) => {
      const params = paramTargets.map(p => evaluateInversionValue(p, context));
      const inversion = new FunctionInversion(params, expectedResult, invertIndexes);
      const { params: invertedParams, sideEffects } = inverter(inversion);
      let allUpdates = empty;
      if (sideEffects != null) {
        sideEffects.forEach((sideEffect) => {
          allUpdates = mergeInversionUpdates(context, allUpdates, sideEffect);
        });
      }
      paramTargets.forEach((target, index) => {
        const paramValue = invertedParams[index];
        const updates = applyInverse(paramValue, target, context);
        allUpdates = mergeInversionUpdates(context, allUpdates, updates);
      });
      return allUpdates;
    }];
  };
}

module.exports.applyInverse = applyInverse;
module.exports.createFunctionInverter = createFunctionInverter;
