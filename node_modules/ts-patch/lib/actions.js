"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.disablePersistence = exports.enablePersistence = exports.unpatch = exports.patch = exports.check = exports.uninstall = exports.install = exports.setOptions = exports.parseFiles = exports.HOOKS_FILES = exports.RESOURCES_PATH = exports.BACKUP_DIRNAME = exports.SRC_FILES = exports.tsDependencies = void 0;
var path = __importStar(require("path"));
var fs = __importStar(require("fs"));
var glob_1 = __importDefault(require("glob"));
var chalk_1 = __importDefault(require("chalk"));
var shell = __importStar(require("shelljs"));
var patcher_1 = require("./patcher");
var file_utils_1 = require("./file-utils");
var system_1 = require("./system");
var resolve_1 = __importDefault(require("resolve"));
/* ********************************************************************************************************************
 * Config
 * ********************************************************************************************************************/
// region Config
exports.tsDependencies = ['ts-node'];
shell.config.silent = true;
exports.SRC_FILES = ['tsc.js', 'tsserverlibrary.js', 'typescript.js', 'typescriptServices.js'];
exports.BACKUP_DIRNAME = 'lib-backup';
exports.RESOURCES_PATH = path.join(system_1.appRoot, system_1.tspPackageJSON.directories.resources);
exports.HOOKS_FILES = ['postinstall', 'postinstall.cmd'];
// endregion
/* ********************************************************************************************************************
 * Helpers
 * ********************************************************************************************************************/
// region Helpers
/**
 * Parse file, array of files, or glob of files and get TSModule info for each
 */
function parseFiles(fileOrFilesOrGlob, dir, includeSrc) {
    if (includeSrc === void 0) { includeSrc = false; }
    var files = Array.isArray(fileOrFilesOrGlob) ? fileOrFilesOrGlob :
        fs.existsSync(file_utils_1.getModuleAbsolutePath(fileOrFilesOrGlob, dir)) ? [fileOrFilesOrGlob] :
            glob_1.default.sync(fileOrFilesOrGlob);
    var ret = files.map(function (f) { return file_utils_1.getTSModule(file_utils_1.getModuleAbsolutePath(f, dir), includeSrc); });
    return system_1.defineProperties(ret, {
        patched: { get: function () { return ret.filter(function (f) { return f.patchVersion; }); } },
        unPatchable: { get: function () { return ret.filter(function (f) { return !f.canPatch; }); } },
        canUpdateOrPatch: { get: function () { return ret.filter(function (f) { return f.canPatch && f.outOfDate; }); } },
        patchable: { get: function () { return ret.filter(function (f) { return f.canPatch; }); } },
    });
}
exports.parseFiles = parseFiles;
/**
 * Create backup of TS Module file
 */
function backup(tsModule, tsPackage) {
    var backupDir = path.join(tsPackage.packageDir, exports.BACKUP_DIRNAME);
    if (tsModule.patchVersion)
        throw new Error("Cannot backup an already patched module. You may need to reinstall typescript.");
    try {
        file_utils_1.mkdirIfNotExist(backupDir);
    }
    catch (e) {
        throw new system_1.BackupError(tsModule.filename, "Couldn't create backup directory. " + e.message);
    }
    if (shell.cp(tsModule.file, backupDir) && shell.error())
        throw new system_1.BackupError(tsModule.filename, shell.error());
    if (tsModule.filename === 'typescript.js')
        if (shell.cp(path.join(tsModule.dir, 'typescript.d.ts'), backupDir) && shell.error())
            throw new system_1.BackupError('typescript.d.ts', shell.error());
}
/**
 * Restore module from backup
 */
function restore(currentModule, tsPackage, noDelete) {
    var copyOrMove = function (fileName, dest) {
        return shell[noDelete ? 'cp' : 'mv'](fileName, dest);
    };
    var backupDir = path.join(tsPackage.packageDir, exports.BACKUP_DIRNAME);
    var _a = file_utils_1.getTSModule(path.join(backupDir, currentModule.filename)), file = _a.file, filename = _a.filename, canPatch = _a.canPatch, patchVersion = _a.patchVersion, dir = _a.dir;
    /* Verify backup file */
    if (!canPatch)
        throw new system_1.RestoreError(filename, "Backup file is not a valid typescript module!");
    if (patchVersion)
        throw new system_1.RestoreError(filename, "Backup file is not an un-patched ts module");
    /* Restore files */
    if (copyOrMove(file, tsPackage.libDir) && shell.error())
        throw new system_1.RestoreError(filename, "Couldn't restore file - " + shell.error());
    if (filename === 'typescript.js')
        if (copyOrMove(path.join(dir, 'typescript.d.ts'), tsPackage.libDir) && shell.error())
            throw new system_1.RestoreError(filename, "Couldn't restore file - " + shell.error());
    /* Verify restored file */
    var restoredModule = file_utils_1.getTSModule(currentModule.file);
    if (!restoredModule.canPatch)
        throw new system_1.RestoreError(filename, "Restored file is not a valid typescript module! You will need to reinstall typescript.");
    if (restoredModule.patchVersion)
        throw new system_1.RestoreError(filename, "Restored file still has patch! You will need to reinstall typescript.");
    // Remove backup dir if empty
    if ((fs.readdirSync(backupDir).length < 1) && shell.rm('-rf', backupDir) && shell.error())
        system_1.Log(['!', "Error deleting backup directory" + chalk_1.default.grey("[" + backupDir + "]")], system_1.Log.verbose);
}
/**
 * Remove tsNode from dependencies in typescript's package.json
 */
function removeDependencies(tsPackage) {
    var pkgFile = path.join(tsPackage.packageDir, 'package.json');
    try {
        var pkgData = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
        for (var _i = 0, tsDependencies_1 = exports.tsDependencies; _i < tsDependencies_1.length; _i++) {
            var d = tsDependencies_1[_i];
            delete pkgData.dependencies[d];
        }
        fs.writeFileSync(pkgFile, JSON.stringify(pkgData, null, 2));
    }
    catch (e) {
        throw new system_1.PatchError(e.message);
    }
}
/**
 * Add tsNode to typescript's dependencies
 */
function installDependencies(tsPackage) {
    var pkgFile = path.join(tsPackage.packageDir, 'package.json');
    /* Read TS package json */
    var pkgData;
    try {
        pkgData = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
    }
    catch (e) {
        throw new system_1.PatchError(e.message);
    }
    /* Find existing installations of dependencies */
    var getDependenciesDetail = function () {
        return exports.tsDependencies
            .map(function (name) {
            var location;
            var version;
            try {
                location = resolve_1.default.sync(name + "/package.json", { basedir: tsPackage.packageDir });
                version = require(location).version;
            }
            catch (e) { }
            return ({ name: name, location: location, version: version });
        });
    };
    /* Install missing dependencies */
    var missingDeps = getDependenciesDetail().filter(function (_a) {
        var version = _a.version;
        return !version;
    });
    if (missingDeps.length > 0) {
        system_1.Log(['~', "Installing dependencies: " + missingDeps.map(function (_a) {
                var name = _a.name;
                return name;
            }).join(', ') + " (via npm)..."], system_1.Log.verbose);
        /*
         * Note: The environment variable is used here to compensate for an issue within istanbuljs/spawn-wrap
         *  When nyc coverage is run, spawn-wrap replaces any instance of the word 'node' in command string with an absolute
         *  path to its node installation. As a result, ts-node cannot install.
         *
         *  This workaround will be replaced shortly.
         */
        shell.exec("npm i --no-audit " + (process.platform === 'win32' ? '%PACKAGES%' : '$PACKAGES'), {
            cwd: path.resolve(tsPackage.packageDir, '..'),
            env: __assign(__assign({}, process.env), { PACKAGES: missingDeps.map(function (_a) {
                    var name = _a.name;
                    return name;
                }).join(' ') })
        });
        if (shell.error())
            throw new system_1.NPMError("Error while installing dependencies: " + shell.error());
    }
    /* Write versions to TS dependencies */
    for (var _i = 0, _a = getDependenciesDetail(); _i < _a.length; _i++) {
        var _b = _a[_i], name = _b.name, version = _b.version;
        if (!pkgData.hasOwnProperty('dependencies'))
            pkgData.dependencies = {};
        pkgData.dependencies[name] = "^" + version;
    }
    try {
        fs.writeFileSync(pkgFile, JSON.stringify(pkgData, null, 2));
    }
    catch (e) {
        throw new system_1.PatchError(e.message);
    }
}
// endregion
/* ********************************************************************************************************************
 * Actions
 * ********************************************************************************************************************/
// region Actions
/**
 * Set app options (superimposes opts onto defaultOptions)
 */
var setOptions = function (opts) { return system_1.resetOptions(opts); };
exports.setOptions = setOptions;
/**
 * Patch TypeScript modules
 */
function install(opts) {
    var ret = patch(exports.SRC_FILES, opts);
    if (ret)
        system_1.Log(['+', chalk_1.default.green("ts-patch installed!")]);
    return ret;
}
exports.install = install;
/**
 * Remove patches from TypeScript modules
 */
function uninstall(opts) {
    var ret = unpatch(exports.SRC_FILES, opts);
    if (ret)
        system_1.Log(['-', chalk_1.default.green("ts-patch removed!")]);
    return ret;
}
exports.uninstall = uninstall;
/**
 * Check if files can be patched
 */
function check(fileOrFilesOrGlob, opts) {
    if (fileOrFilesOrGlob === void 0) { fileOrFilesOrGlob = exports.SRC_FILES; }
    var basedir = system_1.parseOptions(opts).basedir;
    var _a = file_utils_1.getTSPackage(basedir), libDir = _a.libDir, packageDir = _a.packageDir, version = _a.version;
    system_1.Log("Checking TypeScript " + chalk_1.default.blueBright("v" + version) + " installation in " + chalk_1.default.blueBright(packageDir) + "\r\n");
    var modules = parseFiles(fileOrFilesOrGlob, libDir);
    for (var _i = 0, modules_1 = modules; _i < modules_1.length; _i++) {
        var module_1 = modules_1[_i];
        var filename = module_1.filename, patchVersion = module_1.patchVersion, canPatch = module_1.canPatch, outOfDate = module_1.outOfDate;
        if (patchVersion)
            system_1.Log(['+', chalk_1.default.blueBright(filename) + " is patched with ts-patch version " +
                    (chalk_1.default[outOfDate ? 'redBright' : 'blueBright'](patchVersion) + " " + (outOfDate ? '(out of date)' : ''))
            ]);
        else if (canPatch)
            system_1.Log(['-', chalk_1.default.blueBright(filename) + " is not patched."]);
        else
            system_1.Log(['-', chalk_1.default.red(chalk_1.default.redBright(filename) + " is not patched and cannot be patched!")]);
        system_1.Log('', system_1.Log.verbose);
    }
    return modules;
}
exports.check = check;
/**
 * Patch a TypeScript module
 */
function patch(fileOrFilesOrGlob, opts) {
    if (!fileOrFilesOrGlob)
        throw new system_1.PatchError("Must provide a file path, array of files, or glob.");
    var basedir = system_1.parseOptions(opts).basedir;
    var tsPackage = file_utils_1.getTSPackage(basedir);
    var modules = parseFiles(fileOrFilesOrGlob, tsPackage.libDir, true);
    if (!modules.canUpdateOrPatch.length) {
        system_1.Log(['!', "File" + (modules.length - 1 ? 's' : '') + " already patched with the latest version. For details, run: " +
                chalk_1.default.bgBlackBright('ts-patch check')
        ]);
        return false;
    }
    /* Patch files */
    for (var _i = 0, _a = modules.canUpdateOrPatch; _i < _a.length; _i++) {
        var m = _a[_i];
        var file = m.file, filename = m.filename;
        system_1.Log(['~', "Patching " + chalk_1.default.blueBright(filename) + " in " + chalk_1.default.blueBright(path.dirname(file))], system_1.Log.verbose);
        // If already patched, load backup module source. Otherwise, backup un-patched
        if (m.patchVersion)
            m.moduleSrc =
                file_utils_1.getTSModule(path.join(tsPackage.packageDir, exports.BACKUP_DIRNAME, m.filename), /* includeSrc */ true).moduleSrc;
        else
            backup(m, tsPackage);
        patcher_1.patchTSModule(m, tsPackage);
        tsPackage.config.modules[filename] = fs.statSync(file).mtimeMs;
        system_1.Log(['+', chalk_1.default.green("Successfully patched " + chalk_1.default.bold.yellow(filename) + ".\r\n")], system_1.Log.verbose);
    }
    tsPackage.config.save();
    installDependencies(tsPackage);
    if (modules.unPatchable.length > 1) {
        system_1.Log(['!', "Some files can't be patched! Try updating to a newer version of ts-patch. The following files are unable to be " +
                ("patched. [" + modules.unPatchable.map(function (f) { return f.filename; }).join(', ') + "]")
        ]);
        return false;
    }
    return true;
}
exports.patch = patch;
function unpatch(fileOrFilesOrGlob, opts) {
    if (!fileOrFilesOrGlob)
        throw new system_1.PatchError("Must provide a file path, array of files, or glob.");
    var _a = system_1.parseOptions(opts), basedir = _a.basedir, verbose = _a.verbose, instanceIsCLI = _a.instanceIsCLI;
    var tsPackage = file_utils_1.getTSPackage(basedir);
    var modules = parseFiles(fileOrFilesOrGlob, tsPackage.libDir, true);
    if (modules.patched.length < 1) {
        system_1.Log(['!', "File" + (modules.length - 1 ? 's' : '') + " not patched. For details, run: " + chalk_1.default.bgBlackBright('ts-patch check')]);
        return false;
    }
    /* Restore files */
    var errors = {};
    for (var _i = 0, _b = modules.patched; _i < _b.length; _i++) {
        var tsModule = _b[_i];
        var file = tsModule.file, filename = tsModule.filename;
        system_1.Log(['~', "Restoring " + chalk_1.default.blueBright(filename) + " in " + chalk_1.default.blueBright(path.dirname(file))], system_1.Log.verbose);
        try {
            restore(tsModule, tsPackage);
            delete tsPackage.config.modules[filename];
            system_1.Log(['+', chalk_1.default.green("Successfully restored " + chalk_1.default.bold.yellow(filename) + ".\r\n")], system_1.Log.verbose);
        }
        catch (e) {
            errors[filename] = e;
        }
    }
    /* Save config, or handle if no patched files left */
    if (Object.keys(tsPackage.config.modules).length > 0)
        tsPackage.config.save();
    else {
        // Remove ts-patch.json file
        shell.rm('-rf', tsPackage.config.file);
        // Remove ts-node from package.json
        removeDependencies(tsPackage);
    }
    /* Handle errors */
    if (Object.keys(errors).length > 0) {
        Object.values(errors).forEach(function (e) {
            if (!instanceIsCLI)
                console.warn(e);
            else
                system_1.Log(['!', e.message], system_1.Log.verbose);
        });
        system_1.Log('');
        throw new system_1.RestoreError("[" + Object.keys(errors).join(', ') + "]", 'Try reinstalling typescript via npm.' +
            (!verbose ? ' (Or, run uninstall again with --verbose for specific error detail)' : ''));
    }
    return true;
}
exports.unpatch = unpatch;
/**
 * Enable persistence hooks
 */
function enablePersistence(opts) {
    var basedir = system_1.parseOptions(opts).basedir;
    var _a = file_utils_1.getTSPackage(basedir), config = _a.config, packageDir = _a.packageDir;
    system_1.Log(['~', "Enabling persistence in " + chalk_1.default.blueBright(packageDir)], system_1.Log.verbose);
    config.persist = true;
    config.save();
    /* Copy hooks */
    var hooksDir = path.join(packageDir, '../.hooks');
    var hooksFiles = exports.HOOKS_FILES.map(function (f) { return path.join(exports.RESOURCES_PATH, f); });
    try {
        file_utils_1.mkdirIfNotExist(hooksDir);
    }
    catch (e) {
        throw new system_1.PersistenceError("Could not create hooks directory in node_modules: " + e.message);
    }
    if (shell.cp(hooksFiles, hooksDir) && shell.error())
        throw new system_1.PersistenceError("Error trying to copy persistence hooks: " + shell.error());
    /* Write absolute path to ts-patch in hooks */
    var tspPath;
    try {
        tspPath = path.dirname(resolve_1.default.sync('ts-patch/package.json', { basedir: packageDir }));
    }
    catch (e) { }
    if (tspPath)
        for (var _i = 0, _b = hooksFiles.map(function (f) { return path.join(hooksDir, path.basename(f)); }); _i < _b.length; _i++) {
            var file = _b[_i];
            shell.sed('-i', /(?<=^(@SET\s)?tspdir\s*=\s*").+?(?="$)/m, tspPath.split(path.sep).join((path.extname(file) === '.cmd') ? '\\' : '/'), file);
            if (shell.error())
                throw new system_1.PersistenceError("Error writing to hooks file '" + path.basename(file) + "': " + shell.error());
        }
    system_1.Log(['+', chalk_1.default.green("Enabled persistence for " + chalk_1.default.blueBright(packageDir))]);
}
exports.enablePersistence = enablePersistence;
/**
 * Disable persistence hooks
 */
function disablePersistence(opts) {
    var basedir = system_1.parseOptions(opts).basedir;
    var _a = file_utils_1.getTSPackage(basedir), config = _a.config, packageDir = _a.packageDir;
    system_1.Log(['~', "Disabling persistence in " + chalk_1.default.blueBright(packageDir)], system_1.Log.verbose);
    config.persist = false;
    config.save();
    /* Remove hooks */
    var hooksDir = path.join(packageDir, '../.hooks');
    var hooksFiles = exports.HOOKS_FILES.map(function (f) { return path.join(hooksDir, f); });
    if (shell.rm('-rf', hooksFiles) && shell.error())
        throw new system_1.PersistenceError("Error trying to remove persistence hooks: " + shell.error());
    system_1.Log(['-', chalk_1.default.green("Disabled persistence for " + chalk_1.default.blueBright(packageDir))]);
}
exports.disablePersistence = disablePersistence;
// endregion
//# sourceMappingURL=actions.js.map