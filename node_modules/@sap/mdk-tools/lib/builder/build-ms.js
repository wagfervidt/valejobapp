const logger = require('../logger');
const exec = require('child_process').exec;
const execSync = require('child_process').execSync;
const fs = require('fs-extra');
const path = require('path');
const os = require('os');
const timestamp = require('console-timestamp');
const extHelper = require('./extension-helper')

const { getMDKTools, getRootPath, BUILD_TARGET, BUILD_TEMP_FOLDER, MDK_IDENTITY_FILE, APPLICATION_FILE, BUNDLE_JS_FILE, BUNDLE_ZIP_FILE, MDK_CONFIG_JSON, getAppName } = require('../utils');

const APPLICATION_TYPE = {
    Base: "Base",
    Extension: "Extension",
    Standard: "Standard"
};

const MERGE_TYPE = {
    Json: "json",
    I18n: "i18n",
    Style: "style",
    Js: "js"
};

const MERGE_MAP_SUFFIX = ".mergemap";
const PASS_IDENTIFIER = "Pass:\n";
const FAIL_IDENTIFIER = "Fail:\n";
const VSCODE_SETTING_FOLDER = ".vscode";
const VSCODE_SETTING_FILE = "settings.json";

let instance;
class Builder {

    constructor(args) {
        this.buildArgs = args;
        instance = this;
        instance.extProjects = [];
        instance.logFile = instance.buildArgs.logFile();
        instance.log = instance.buildArgs.log();
        const aProjectPath = instance.buildArgs.project().split(path.sep);
        instance.baseProjectName = aProjectPath.pop();
        instance.buildRoot = aProjectPath.join(path.sep);
        instance.mergedFiles = [];
        instance.mergedError = "";
        instance.sBundleTempFolder= instance.buildArgs.bundleZipTargetPath() ? instance.buildArgs.bundleZipTargetPath() : path.join(instance.buildArgs.project(), BUILD_TEMP_FOLDER);

    }
    /**
     * This is the main entry point into the build ms functionality
     */
    build() {
       
        if (instance._checkExtension()) {
            if (instance._validate()) {
                if (instance._mergeExtensionFiles()) {
                    return instance._bundleFile();
                }
            }
        } else {
            return instance._bundleFile();
        }
    }

    _validate() {
        if (instance.buildArgs.validate()) {
            for (var i=0; i<instance.extProjects.length; i++) {
                let sMDKTools = getMDKTools();
                let sCommand = `${sMDKTools} validate-mergemap --extProject "${path.join(instance.buildRoot, instance.extProjects[i])}" --baseProject "${instance.buildArgs.project()}" `;
                if (instance.logFile) {
                    sCommand =sCommand + ` --logFile ${instance.logFile} `;
                }
                let  sOutput;
                try {
                    sOutput = execSync(sCommand).toString();
                } catch(e) {
                    if (instance.logFile) {        
                        fs.writeFileSync(instance.logFile, `${FAIL_IDENTIFIER}Validate mergemap failed with ${e.message}`);
                    }
                    return false;
                }
                console.log(sOutput);
                if (!sOutput.startsWith(PASS_IDENTIFIER)) {
                    return false;
                } 
            }
            return true;
        } else {
            return true;
        } 
    }

    _checkExtension() {
        instance.extProjects = instance._getExtensionProjects();
        let aProjects = instance.extProjects.map(prj => {return path.join(instance.buildRoot, prj);});
        aProjects.push(instance.buildArgs.project());
        instance._initExternals(aProjects);
        return instance.extProjects.length>0;
    }

    _mergeExtensionFiles() {
        if (instance.extProjects.length > 0) {
            let finalError = "";
            instance.extProjects.forEach(extProject => {
                instance._applyMergeMaps(extProject);
            });

            if (instance.mergedError !== "") {
                finalError = `${FAIL_IDENTIFIER}${instance.mergedError}`;
                console.error(finalError);

                if (instance.logFile) {
                    fs.writeFileSync(instance.logFile, finalError);
                }
                return false;
            } else {
                let tempFiles = [];
                try {
                    instance.mergedFiles.forEach(mergeFile => {
                        fs.writeFileSync(mergeFile.name, mergeFile.content);
                        tempFiles.push(mergeFile.name.substring(instance.buildRoot.length));
                    });
                } catch (e) {
                    finalError = `${FAIL_IDENTIFIER}Failed to update base file with error: ${e.message}`;
                    console.error(finalError);
                    if (instance.logFile) {
                        fs.writeFileSync(instance.logFile, finalError);
                    }
                    return false;
                }
                console.log(`Merge below files successfully.\n${tempFiles.join("\n")}`);
            }
        }
        return true;
    }

    _bundleFile() {
        return new Promise(function (resolve, reject) {
            if (fs.existsSync(instance.sBundleTempFolder)) {
                fs.removeSync(instance.sBundleTempFolder);
            }

            //synch _SchemaVersion from application to project.json
            let sProjectPath = instance.buildArgs.project();
            let destCheProjectPath = path.join(sProjectPath, '.che', MDK_IDENTITY_FILE);
            if (!fs.existsSync(destCheProjectPath)) {
                let srcCheProjectPath = path.join(getRootPath(), 'builder', 'template', MDK_IDENTITY_FILE);
                let definistionsVersion = instance._getAppUpdateVersion(sProjectPath);
                let configContent = fs.readFileSync(srcCheProjectPath, {
                    encoding: "utf8"
                });
                configContent = configContent.replace("{definitionsVersion}", definistionsVersion);
                fs.ensureDirSync(path.dirname(destCheProjectPath));
                fs.writeFileSync(destCheProjectPath, configContent);
            }
            
            let sAppName = getAppName(sProjectPath);
            let aExternals = instance.externals;
            let aFilters = [`${path.sep}Web${path.sep}`].concat(instance.buildArgs.filters());
            for (let i = 0; i < aFilters.length; i++) {
                aFilters[i] = `${path.sep}${sAppName}${aFilters[i]}`;
            }

           
            let sMDKTools = getMDKTools();
            let sCommand = `${sMDKTools} bundle --nativescript-project "${instance.sBundleTempFolder}" --seam-project "${sProjectPath}" `
                + `--externals ${aExternals.join(" ")} `
                + `--filters ${aFilters.join(" ")} `
                + `--bundle-zip-target-path "${instance.sBundleTempFolder}" `;

            if (instance.buildArgs.devtool()) {
                sCommand = `${sCommand} --devtool "${instance.buildArgs.devtool()}"`;
            }

            if (instance.buildArgs.target() == BUILD_TARGET.ZIP) {
                sCommand = sCommand + " --create-bundle";
            }
            if (instance.buildArgs.tsTarget()) {
                sCommand = `${sCommand} --ts-target "${instance.buildArgs.tsTarget()}"`;
            }

            if (instance.buildArgs.useWmf()) {
                sCommand = `${sCommand} --wmf`;
            }

            if (instance.buildArgs.web()) {
                sCommand = `${sCommand} --web`;
            }

            console.log('[hh:mm:ss]'.timestamp + ` execute bundle command:\n ${sCommand}`);
            exec(sCommand, (error, stdout, stderr) => {
                if (error) {
                    if (instance.logFile) {
                        fs.writeFileSync(instance.logFile, `${FAIL_IDENTIFIER}Failed to bundle project with error: ${error.message}`);
                    }
                    reject(error.message);
                } else {
                    instance._checkResult(stdout)
                    resolve();
                }
            }).stdout.pipe(process.stdout);
        });
    }

    _checkResult(output) {
        let bundleFile = "";
        if (instance.buildArgs.target() == BUILD_TARGET.ZIP) {
            bundleFile = path.join(instance.sBundleTempFolder, BUNDLE_ZIP_FILE);
        } else {
            bundleFile = path.join(instance.sBundleTempFolder, BUNDLE_JS_FILE);
        }

        if (fs.existsSync(bundleFile)) {
            if (instance.logFile) {
                fs.writeFileSync(instance.logFile, `${PASS_IDENTIFIER}Generated bundle file ${bundleFile}`);
            }
            console.log(logger.getSuccess(`Generate bundle file ${bundleFile} successfully`));
            return true;
        } else {
            if (instance.logFile) {
                fs.writeFileSync(instance.logFile, `${FAIL_IDENTIFIER}Failed to generate bundle file ${bundleFile}\n${output}`);
            }
            console.error(logger.getError(`Failed to generate bundle file ${bundleFile}`));
            return false;
        }
    }

    _getExtensionProjects() {
        let extProjects = [];
        const sProjectPath = instance.buildArgs.project();

        const oApp = fs.readJSONSync(path.join(sProjectPath, APPLICATION_FILE));
        if (oApp["_Type"] === APPLICATION_TYPE.Base) {
            const files = fs.readdirSync(sProjectPath);
            const cimFiles = files.filter(file => file.endsWith('.cim'));
            cimFiles.forEach(cimFile => {
                const cimContent = fs.readJSONSync(path.join(sProjectPath, cimFile));
                if (cimContent["ProjectName"]) {
                    const rootPath = sProjectPath.substring(0, sProjectPath.lastIndexOf(path.sep));
                    const extProjectPath = path.join(rootPath, cimContent["ProjectName"], APPLICATION_FILE);
                    const oExtApp = fs.readJSONSync(extProjectPath);
                    if (oExtApp["_Type"] === APPLICATION_TYPE.Extension) {
                        extProjects.push(cimContent["ProjectName"]);
                        if (cimContent["IntegrationPoints"] && cimContent["IntegrationPoints"].length>0) {
                            if (instance.logFile) {
                                fs.writeFileSync(instance.logFile, `${FAIL_IDENTIFIER}CIM IntegrationPoints are not allowed for extension development.`);
                            }
                            throw Error('CIM IntegrationPoints are not allowed for extension development.')
                        }
                    }
                }
            });
        }
        
        return extProjects;
    }

    _applyMergeMaps(extProject) {
        const mergeMapFiles = instance._getMergeMapFiles(path.join(instance.buildRoot, extProject));
        mergeMapFiles.forEach(mergeMapFile => {
            instance._applyOneMergeMap(mergeMapFile);
        });
    }

    _getMergeMapFiles(extProject) {
        const files = instance._getAllFiles(extProject);
        const mergeMapFiles = files.filter(file => file.endsWith('.mergemap') || file.endsWith('.properties') || file.endsWith('.less') || file.endsWith('.nss'));
        return mergeMapFiles;
    }

    _applyOneMergeMap(mergeMapFile) {
        let relativePath = mergeMapFile.substring(instance.buildRoot.length + 1);
        let targetBaseFile;
        relativePath = relativePath.substring(relativePath.indexOf(path.sep) + 1);
        if (relativePath === "Application.mergemap") {
            targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, APPLICATION_FILE);
            instance._mergeJsonFile(mergeMapFile, targetBaseFile);
        } else {
            const rootFolder = relativePath.substring(0, relativePath.indexOf(path.sep));

            switch (rootFolder) {
                case "Actions":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".action"));
                    instance._mergeJsonFile(mergeMapFile, targetBaseFile);
                    break;
                case "Globals":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".global"));
                    instance._mergeJsonFile(mergeMapFile, targetBaseFile);
                    break;
                case "Services":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".service"));
                    instance._mergeJsonFile(mergeMapFile, targetBaseFile);
                    break;
                case "Fragments":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".fragment"));
                    instance._mergeJsonFile(mergeMapFile, targetBaseFile);
                    break;
                case "Pages":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".page"));
                    if (fs.existsSync(targetBaseFile)) {
                        instance._mergeJsonFile(mergeMapFile, targetBaseFile);
                    } else {
                        targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".fragment"));
                        if (fs.existsSync(targetBaseFile)) {
                            instance._mergeJsonFile(mergeMapFile, targetBaseFile);
                        } else {
                            throw new Error(`Failed to find target base page or fragment from ${mergeMapFile.substring(instance.buildRoot.length)}`);
                        }
                    }

                    break;

                case "i18n":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath);
                    instance._mergeI18nFile(mergeMapFile, targetBaseFile);
                    break;
                case "Styles":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath);
                    instance._mergeStyleFile(mergeMapFile, targetBaseFile);
                    break;
                case "Rules":
                    targetBaseFile = path.join(instance.buildRoot, instance.baseProjectName, relativePath.replace(MERGE_MAP_SUFFIX, ".js"));
                    instance._mergeRuleFile(mergeMapFile, targetBaseFile);
                    break;
                default:
                    console.error(`Unsupported mergemap file from root folder ${rootFolder}`);
                    break;
            }
        }
        //const targetBaseFile = 
    }

    _getAllFiles(dirPath, arrayOfFiles) {
        const files = fs.readdirSync(dirPath)

        arrayOfFiles = arrayOfFiles || []

        files.forEach(function (file) {
            if (fs.statSync(dirPath + path.sep + file).isDirectory()) {
                arrayOfFiles = instance._getAllFiles(dirPath + path.sep + file, arrayOfFiles)
            } else {
                arrayOfFiles.push(path.join(dirPath, path.sep, file))
            }
        })

        return arrayOfFiles
    }

    _mergeJsonFile(sourceFile, targetFile) {
        if (!fs.existsSync(targetFile)) {
            instance.mergedError += `Failed to find target base file ${targetFile.substring(instance.buildRoot.length)}\n`;
            return;
        }
        if (instance.log) {
            console.log(`merge json from ${sourceFile.substring(instance.buildRoot.length)} to ${targetFile.substring(instance.buildRoot.length)}`);
        }
        try {
            let oTarget = fs.readJSONSync(targetFile);
            let oMap = fs.readJSONSync(sourceFile);
            let oResult = extHelper.mergeJson(oMap, oTarget);
            instance.mergedFiles.push(
                {
                    name: targetFile,
                    content: JSON.stringify(oResult, "", "\t")
                }
            );
            if (instance.log) {
                console.log(JSON.stringify(oResult, "", "\t"));
            }
        } catch (e) {
            instance.mergedError = instance.mergedError + `Failed to merge ${sourceFile.substring(instance.buildRoot.length)} with error: ${e.message}.\n`;
            return;
        }
    }

    _mergeI18nFile(sourceFile, targetFile) {
        if (!fs.existsSync(targetFile)) {
            instance.mergedError += `Failed to find target base file ${targetFile.substring(instance.buildRoot.length)}\n`;
            return;
        }
        if (instance.log) {
            console.log(`merge i18n from ${sourceFile.substring(instance.buildRoot.length)} to ${targetFile.substring(instance.buildRoot.length)}`);
        }
        try {
            let sSouce = fs.readFileSync(sourceFile).toString();
            let sTarget = fs.readFileSync(targetFile).toString();
            let sResult = extHelper.mergeI18n(sSouce, sTarget);
            instance.mergedFiles.push(
                {
                    name: targetFile,
                    content: sResult
                }
            );
            if (instance.log) {
                console.log(sResult);
            }
        } catch (e) {
            instance.mergedError = instance.mergedError + `Failed to merge ${sourceFile.substring(instance.buildRoot.length)} with error: ${e.message}.\n`;
            return;
        }
    }

    _mergeStyleFile(sourceFile, targetFile) {
        if (!fs.existsSync(targetFile)) {
            instance.mergedError += `Failed to find target base file ${targetFile.substring(instance.buildRoot.length)}\n`;
            return;
        }
        if (instance.log) {
            console.log(`merge style from ${sourceFile.substring(instance.buildRoot.length)} to ${targetFile.substring(instance.buildRoot.length)}`);
        }
        try {
            let sSouce = fs.readFileSync(sourceFile).toString();
            let sTarget = fs.readFileSync(targetFile).toString();
            let sResult = extHelper.mergeStyle(sSouce, sTarget);
            instance.mergedFiles.push(
                {
                    name: targetFile,
                    content: sResult
                }
            );
            if (instance.log) {
                console.log(sResult);
            }
        } catch (e) {
            instance.mergedError = instance.mergedError + `Failed to merge ${sourceFile.substring(instance.buildRoot.length)} with error: ${e.message}.\n`;
            return;
        }
    }

    _mergeRuleFile(sourceFile, targetFile) {
        if (!fs.existsSync(targetFile)) {
            instance.mergedError += `Failed to find target base file ${targetFile.substring(instance.buildRoot.length)}\n`;
            return;
        }
        try {
            if (instance.log) {
                console.log(`merge rule from ${sourceFile.substring(instance.buildRoot.length)} to ${targetFile.substring(instance.buildRoot.length)}`);
            }
            let sTarget = fs.readFileSync(targetFile).toString();
            let oMap = fs.readJSONSync(sourceFile);

            let sResult = extHelper.mergeJs(oMap, sTarget);
            instance.mergedFiles.push(
                {
                    name: targetFile,
                    content: sResult
                }
            );
            if (instance.log) {
                console.log(sResult);
            }
        } catch (e) {
            instance.mergedError = instance.mergedError + `Failed to merge ${sourceFile.substring(instance.buildRoot.length)} with error: ${e.message}.\n`;
            return;
        }
    }

    _initExternals(aProjects) {
        let aExternals = instance.buildArgs.externals();
        if (aExternals && aExternals.length > 0) {
            instance.externals = aExternals;
            return;
        } else {
            instance.externals = [];
            aProjects.forEach(sProjectPath => {
                const aExternals = instance._getExternalsFromProject(sProjectPath);
                aExternals.forEach(sExternal => {
                    if (!instance.externals.includes(sExternal)) {
                        instance.externals.push(sExternal);
                    }
                })
            })
        }
    }

    _getExternalsFromProject(sProjectPath) {
        let aExternals = [];
        let vsSettingFile = path.join(sProjectPath, VSCODE_SETTING_FOLDER, VSCODE_SETTING_FILE);
        if (fs.existsSync(vsSettingFile)) {
            try {
                const oVSSetting = fs.readJSONSync(vsSettingFile);
                if (oVSSetting && oVSSetting["mdk.bundlerExternals"]) {
                    aExternals = oVSSetting["mdk.bundlerExternals"];
                }
            } catch (e) {
                console.log(`failed to read ${vsSettingFile} with error ${e.message}`);
            }
        }
        let mdkSettingFile = path.join(sProjectPath, MDK_CONFIG_JSON);
        if (fs.existsSync(mdkSettingFile)) {
            try {
                const oMDKSetting = fs.readJSONSync(mdkSettingFile);
                if (oMDKSetting && oMDKSetting["Build"] && oMDKSetting["Build"]["Externals"]) {
                    oMDKSetting["Build"]["Externals"].forEach(item => {
                        if (!aExternals.includes(item)) {
                            aExternals.push(item);
                        }
                    })
                }
            } catch (e) {
                console.log(`failed to read ${vsSettingFile} with error ${e.message}`);
            }
        }
        return aExternals;
    }

    _getAppUpdateVersion(sProjectPath) {
        let versionPattern = "<appVersion> (MDK <schemaVersion>)";
        let appVersion = "";
        let schemaVersion = "5.2";
        const applicationFile = path.join(sProjectPath, APPLICATION_FILE);
        if (fs.existsSync(applicationFile)) {
            const applicationJson = fs.readJSONSync(applicationFile);
            schemaVersion = applicationJson["_SchemaVersion"] ? applicationJson["_SchemaVersion"] : "5.2";
            appVersion = applicationJson["Version"] ? applicationJson["Version"] : "";
            if (appVersion.endsWith(".js")) {
                appVersion = "Rule";
            } else if (appVersion.endsWith(".global")) {
                let globalPathArr =  appVersion.split("/");
                if (globalPathArr.length>2) {
                    globalPathArr.shift();
                    globalPathArr.shift();
                }
                let globalFilePath = path.join(sProjectPath, globalPathArr.join(path.sep));
                if (fs.existsSync(globalFilePath)) {
                    const globalJson = fs.readJSONSync(globalFilePath);
                    appVersion = globalJson["Value"] ? globalJson["Value"] : "";
                }
            }
        }
        
        return versionPattern.replace("<appVersion>", appVersion).replace("<schemaVersion>", schemaVersion);
    }
};

exports.Builder = Builder;
