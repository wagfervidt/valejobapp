/* eslint-disable no-bitwise */
const gammaLN = require('./GAMMALN.runtime');

const lowRegGamma = (a, x) => {
  const aln = gammaLN([a]);
  let ap = a;
  let sum = 1 / a;
  let del = sum;
  let b = x + 1 - a;
  let c = 1 / 1.0e-30;
  let d = 1 / b;
  let h = d;
  let i = 1;
  // calculate maximum number of itterations required for a
  const ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  let an;

  if (x < 0 || a <= 0) {
    return null;
  }
  if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      ap += 1;
      del *= (x / ap);
      sum += del;
    }
    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= (d * c);
  }
  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));
};

const distributionGamma = (x, shape, scale) => {
  if (x < 0) {
    return 0;
  }
  return (x === 0 && shape === 1)
    ? 1 / scale
    : Math.exp((shape - 1) * Math.log(x) - x / scale
      - gammaLN([shape]) - shape * Math.log(scale));
};

const cumulativeGamma = (x, shape, scale) => {
  if (x < 0) {
    return 0;
  }
  return lowRegGamma(shape, x / scale);
};

module.exports = ([num, shape, scale, cumulative]) => {
  if (!(typeof num === 'number' && Number.isFinite(num))) {
    return null;
  }
  if (!(typeof shape === 'number' && Number.isFinite(shape))) {
    return null;
  }
  if (!(typeof scale === 'number' && Number.isFinite(scale))) {
    return null;
  }
  if (!cumulative && shape <= 1) {
    if (num <= 0) {
      return null;
    }
  }
  const result = cumulative
    ? cumulativeGamma(num, shape, scale)
    : distributionGamma(num, shape, scale);
  return Number.isFinite(result) ? result : null;
};
