const { detectStringFormats } = require('./formatting');
const {
  unionValues, pickEvenly, addUnionValues, intersectionValues,
} = require('./utils/array');

/**
 * Returns a simplified schema for the given actual value.
 * @param {*} value value for which the schema is built
 * @param {object} defaultSchema schema to default on null/undefined schemas
 */
function detectValueSchema(value, defaultSchema) {
  return detectSchemaFromValues([value], defaultSchema);
}

const maxDetectedExampleValues = 10;

function detectSchemaFromValues(values, defaultSchema) {
  const hasNull = values.includes(null);
  const hasUndefined = values.includes(undefined);
  const schemas = [];
  if (values.some((value) => typeof value === 'number')) {
    const uniqueNumbers = unionValues(values.filter((value) => typeof value === 'number' || value == null));
    schemas.push({ type: 'number', examples: pickEvenly(uniqueNumbers, maxDetectedExampleValues) });
  }
  if (values.some((value) => typeof value === 'boolean')) {
    const uniqueBooleans = unionValues(values.filter((value) => typeof value === 'boolean' || value == null));
    schemas.push({ type: 'boolean', examples: uniqueBooleans });
  }
  if (values.some((value) => typeof value === 'string')) {
    const uniqueStrings = unionValues(values.filter((value) => typeof value === 'string' || value == null));
    const strFormats = [];
    uniqueStrings.forEach((str) => {
      if (str != null) addUnionValues(strFormats, detectStringFormats(str));
    });
    const stringSchema = { type: 'string', examples: pickEvenly(uniqueStrings, maxDetectedExampleValues) };
    if (strFormats.length === 1) {
      const [format] = strFormats;
      if (format !== 'blank') {
        stringSchema.format = format;
      }
    }
    schemas.push(stringSchema);
  }
  const objects = values.filter((value) => typeof value === 'object' && value != null && !Array.isArray(value));
  if (objects.length) {
    const propertyValues = {};
    let required = null;
    objects.forEach((obj) => {
      const propNames = Object.keys(obj);
      if (required) {
        required = intersectionValues(required, propNames);
      } else {
        required = propNames;
      }
      propNames.forEach((propName) => {
        const propValues = propertyValues[propName] || [];
        propValues.push(obj[propName]);
        propertyValues[propName] = propValues;
      });
    });
    const properties = {};
    const possiblePropNames = Object.keys(propertyValues);
    possiblePropNames.forEach((propName) => {
      const propValues = propertyValues[propName];
      properties[propName] = detectSchemaFromValues(propValues, defaultSchema);
    });
    const objectSchema = {
      type: 'object',
      properties,
    };
    if (required && required.length !== possiblePropNames.length) {
      objectSchema.required = required;
    }
    schemas.push(objectSchema);
  }
  const arrays = values.filter((value) => Array.isArray(value));
  if (arrays.length) {
    const items = [].concat(...arrays);
    schemas.push({
      type: 'array',
      items: items.length ? detectSchemaFromValues(items, defaultSchema) : defaultSchema || { type: 'undefined' },
    });
  }
  if (!schemas.length && !defaultSchema) {
    if (hasNull) schemas.push({ type: 'null' });
    if (hasUndefined) schemas.push({ type: 'undefined' });
  }
  if (schemas.length === 1) {
    return schemas[0];
  }
  const examples = pickEvenly(unionValues(values), maxDetectedExampleValues);
  if (!schemas.length) {
    return { ...defaultSchema, examples };
  }
  // Mixed schema
  return { type: 'json', examples };
}

module.exports.detectValueSchema = detectValueSchema;
