const gammaln = require('./GAMMALN.runtime');
const combination = require('../math/COMBIN.runtime');

const betinc = (x, a, b, eps) => {
  let a0 = 0;
  let b0 = 1;
  let a1 = 1;
  let b1 = 1;
  let m9 = 0;
  let a2 = 0;
  let c9;

  while (Math.abs((a1 - a2) / a1) > eps) {
    a2 = a1;
    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
    a0 = a1 + c9 * a0;
    b0 = b1 + c9 * b0;
    m9 += 1;
    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
    a1 = a0 + c9 * a1;
    b1 = b0 + c9 * b1;
    a0 /= b1;
    b0 /= b1;
    a1 /= b1;
    b1 = 1;
  }

  return a1 / a;
};
const distributionBINOMDIST = (k, n, p) => {
  if (p === 0 || p === 1) {
    return ((n * p) === k ? 1 : 0);
  }
  return combination([n, k]) * (p ** k) * ((1 - p) ** (n - k));
};
const comultativeBINOMDIST = (x, n, p) => {
  const EPS = 1e-10;
  if (x < 0) {
    return 0;
  }
  if (x >= n) {
    return 1;
  }
  if (p < 0 || p > 1 || n <= 0) {
    return null;
  }
  const xFlor = Math.floor(x);
  const z = p;
  const a = xFlor + 1;
  const b = n - xFlor;
  const s = a + b;
  const bt = Math.exp(gammaln([s]) - gammaln([b]) - gammaln([a])
  + a * Math.log(z) + b * Math.log(1 - z));

  const betacdf = z < (a + 1) / (s + 2)
    ? bt * betinc(z, a, b, EPS) : 1 - bt * betinc(1 - z, b, a, EPS);
  return Math.round((1 - betacdf) * (1 / EPS)) / (1 / EPS);
};

module.exports = ([num, numTrials, numProb, cumulative]) => {
  if (!(typeof num === 'number' && Number.isFinite(num))) {
    return null;
  }
  if (!(typeof numTrials === 'number' && Number.isFinite(numTrials))) {
    return null;
  }
  if (!(typeof numProb === 'number' && Number.isFinite(numProb))) {
    return null;
  }
  if ((numProb < 0 || numProb > 1) || num < 0 || numTrials < 0) {
    return null;
  }
  const result = cumulative
    ? comultativeBINOMDIST(num, numTrials, numProb)
    : distributionBINOMDIST(num, numTrials, numProb);
  return Number.isFinite(result) ? result : null;
};
