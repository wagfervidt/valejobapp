/**
 * Helpers for working with arrays.
 * @module utils/array
 */
const { isEqual } = require('./equality');

/**
 * Returns the first index of the value in the array that would equal to the
 * given value.
 * @param {Array} array array of values
 * @param {*} value value to search from the array
 * @returns {number} index of the value in the array, or -1 if not found
 */
function indexOfValue(array, value) {
  if (value == null || (typeof value !== 'object' && (typeof value !== 'number' || !Number.isNaN(value)))) {
    // Use faster indexOf for primitive values (that are not NaN)
    return array.indexOf(value);
  }
  // Iterate and perform deep comparison for complex values
  return array.findIndex((item) => isEqual(item, value));
}

/**
 * Returns whether or not a value equal to the given one is found
 * from the given array.
 * @param {Array} array array of values
 * @param {*} value value to search from the array
 * @returns {boolean} whether the value exists in the array or not
 */
function includesValue(array, value) {
  return indexOfValue(array, value) >= 0;
}

/**
 * Performs a map operation similar to the `Array.map` except that
 * it returns the original array if the map would result in exact items
 * with the original array.
 * @param {Array} array array of values
 * @param {function} callback mapping function
 * @returns {Array} array of mapped values
 */
function immutableMap(array, callback) {
  let hasChanged = false;
  const newArray = array.map((item, index, arr) => {
    const newItem = callback(item, index, arr);
    if (!Object.is(item, newItem)) {
      hasChanged = true;
    }
    return newItem;
  });
  return hasChanged ? newArray : array;
}

/**
 * Mutates the first given array parameter by adding
 * all the values from the following parameter arrays that
 * do not exist in the original array.
 * @param {Array} results result array
 * @param {...Array} arrays arrays of added values
 * @returns {Array} array of unique values
 */
function addUnionValues(results, ...arrays) {
  arrays.forEach((items) => {
    items.forEach((item) => {
      if (!includesValue(results, item)) {
        results.push(item);
      }
    });
  });
  return results;
}

/**
 * Returns an array containing unique values
 * from each of the given arrays.
 * @param  {...Array} arrays arrays of values
 * @returns {Array} array of union values
 */
function unionValues(...arrays) {
  return addUnionValues([], ...arrays);
}

/**
 * Returns values that exist in each of the given array.
 * @param {...Array} arrays arrays of values
 * @returns {Array} array of intersection values
 */
function intersectionValues(array, ...arrays) {
  const results = array ? array.slice() : [];
  arrays.forEach((items) => {
    for (let i = results.length - 1; i >= 0; i -= 1) {
      const item = results[i];
      if (!includesValue(items, item)) {
        results.splice(i, 1);
      }
    }
  });
  return results;
}

/**
 * Returns all possible combinations from the given arrays of arrays.
 * @param {Array} optionArrays array of arrays
 * @returns {Array} array of all combinations
 */
function combinations(optionArrays) {
  if (!optionArrays.length) {
    return [];
  }
  if (optionArrays.length < 2) {
    return optionArrays[0].map((option) => [option]);
  }
  const [options, ...rest] = optionArrays;
  const results = [];
  const others = combinations(rest);
  for (let i = 0; i < options.length; i += 1) {
    const option = options[i];
    for (let j = 0; j < others.length; j += 1) {
      results.push([option, ...others[j]]);
    }
  }
  return results;
}

/**
 * Ensures that the given array is no larger than the given count.
 * If the array is larger, then returns an array where existing values
 * are picked as evenly as possible from the original array. Otherwise
 * returns the original array.
 * @param {Array} values array of values
 * @param {number} count max number of items
 * @returns {Array} array of max `count` items
 */
function pickEvenly(values, count) {
  if (values.length <= count) {
    return values;
  }
  const results = [];
  for (let n = 0; n < count; n += 1) {
    const index = Math.floor((n * (values.length - 1)) / (count - 1));
    results.push(values[index]);
  }
  return results;
}

/**
 * Sorts the given array of items. If the iteratee function is provided,
 * then this is called for each item and those values are compared.
 * The sort is stable: equal items preserve their original order (even if descending).
 * The return value is an array of special slot objects with the following properties:
 * - "item" the value from the original array
 * - "index" the original index
 * - "key" the value used to compare the items
 * @param {Array} array items to sort
 * @param {string} direction either "asc" or "desc"
 * @param {function} key function returning the key for each item to compare, or a key name
 * @param {boolean} caseSensitive whether to use case-sensitive sorting
 * @returns {Array} sorted slots
 */
function performSort(array, direction, key, caseSensitive) {
  if (!array.length) {
    return array;
  }
  let extractRawKey;
  if (typeof key === 'function') {
    extractRawKey = key;
  } else if (key == null) {
    extractRawKey = (value) => value;
  } else {
    extractRawKey = (item) => (item == null ? undefined : item[key]);
  }
  const extractKey = caseSensitive
    ? extractRawKey
    : (item, index) => {
      const rawKey = extractRawKey(item, index);
      return typeof rawKey === 'string' ? rawKey.toLowerCase() : rawKey;
    };
  const slots = array.map((item, index) => ({ item, index, key: extractKey(item, index) }));
  const factor = direction === 'desc' ? -1 : 1;
  // eslint-disable-next-line no-nested-ternary
  const genericComparator = (a, b) => (a < b ? -factor : a > b ? factor : 0);
  const keyComparator = caseSensitive
    ? genericComparator
    : (a, b) => {
      if (typeof a === 'string' && typeof b === 'string') {
        return (a.localeCompare(b) * factor);
      }
      return genericComparator(a, b);
    };
  const comparator = (a, b) => keyComparator(a.key, b.key) || (a.index - b.index);
  // Sort using the native sort
  slots.sort(comparator);
  return slots;
}

/**
 * Sorts the given array of items. If the iteratee function is provided,
 * then this is called for each item and those values are compared.
 * The sort is stable: equal items preserve their original order (even if descending).
 * The return value is an array of special slot objects with the following properties:
 * - "item" the value from the original array
 * - "index" the original index
 * - "key" the value used to compare the items
 * @param {Array} array items to sort
 * @param {string} direction either "asc" or "desc"
 * @param {function} key function returning the key for each item to compare, or a key name
 * @param {boolean} caseSensitive whether to use case-sensitive sorting
 * @returns {Array} sorted items
 */
function sort(array, direction, key, caseSensitive) {
  return performSort(array, direction, key, caseSensitive).map((slot) => slot.item);
}

/**
 * Filters the given array of items, similar to `filter` method, but instead
 * of returning an array of filtered items, it returns an array of slot objects
 * containing information about the indexes at the original array::
 * - "item" the value from the original array
 * - "index" the original index
 * @param {Array} array items to sort
 * @param {function} criteria function for selecting items
 * @returns {Array} filtered item slots
 */
function performFilter(array, criteria) {
  if (!array.length) {
    return array;
  }
  return array
    .map((item, index) => ({ item, index }))
    .filter((slot) => criteria(slot.item, slot.index));
}

/**
 * Returns the median of the given array of sortable values.
 * @param {Array} array array of sortable values
 * @returns {*} median value
 */
function median(array) {
  const arr = performSort(array, 'asc', null, true);
  const { length } = arr;
  return (length % 2 === 0)
    ? (arr[length / 2 - 1].item + arr[length / 2].item) / 2
    : arr[(length - 1) / 2].item;
}

/**
 * Returns an array containing the given value repeated the
 * given number of times.
 * @param {*} item any value
 * @param {number} count how many times to repeat the value
 * @returns {Array} array of repeated item
 */
function repeat(item, count) {
  const result = [];
  if (typeof count === 'number' && Number.isFinite(count)) {
    for (let i = 0; i < count; i += 1) {
      result.push(item);
    }
  }
  return result;
}

module.exports.addUnionValues = addUnionValues;
module.exports.combinations = combinations;
module.exports.immutableMap = immutableMap;
module.exports.includesValue = includesValue;
module.exports.indexOfValue = indexOfValue;
module.exports.intersectionValues = intersectionValues;
module.exports.median = median;
module.exports.performFilter = performFilter;
module.exports.performSort = performSort;
module.exports.pickEvenly = pickEvenly;
module.exports.repeat = repeat;
module.exports.sort = sort;
module.exports.unionValues = unionValues;
