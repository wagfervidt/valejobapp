const logger = require('../logger');
const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');


const { REPORT_CONTENT, APPLICATION_FILE, getAppName } = require('../utils');
const JSON_FILE_EXT = [".service", ".global", ".action", ".page", ".fragment"];
const RULE_FILE_EXT = ".js";
const EXTENSION_POINT_KEY = "_ExtensionPoint";
const MERGE_MAP_EXT = ".mergemap";


const KEY_ARRAY_REMOVE = "Remove";
const KEY_ARRAY_REORDER = "Reorder";
const KEY_ARRAY_ADD = "Add";

const KEY_ARRAY_INSERT_BEGIN = "InsertBegin";
const KEY_ARRAY_INSERT_END = "InsertEnd";
const KEY_ARRAY_INSERT_ANY = "InsertAny";

const KEY_ARRAY_INSERT_AFTER_NAME = "NameAfter";
const KEY_ARRAY_INSERT_AFTER_INDEX = "IndexAfter";
const KEY_ARRAY_INSERT_BEFORE_NAME = "NameBefore";
const KEY_ARRAY_INSERT_BEFORE_INDEX = "IndexBefore";

const Predefined_ArrayKey = [
  KEY_ARRAY_REORDER,
  KEY_ARRAY_REMOVE,
  KEY_ARRAY_ADD
];


let instance;
let childProcessExecOption;
class Builder {

  constructor(args) {
    this.buildArgs = args;
    instance = this;
    instance._aReport = [];
  }
  /**
   * This is the main entry point into the build report functionality
   */
  build() {
    return new Promise(function (resolve, reject) {
      try {

        instance._sProjectPath = instance.buildArgs.project();
        if (!instance.buildArgs.file()) {
          console.error(logger.getError('Please specify report file by --file'));
          reject('Please specify report file by --file');
        }

        instance._sAppName = getAppName(instance._sProjectPath);

        if (instance.buildArgs.content() === REPORT_CONTENT.EXTENSION_DEFINE) {
          instance.generateDefinitionReport(instance._sProjectPath);

        } else if (instance.buildArgs.content() === REPORT_CONTENT.EXTENSION_USING) {
          instance.generateUsageReport(instance._sProjectPath);
        } else if (instance.buildArgs.content() === REPORT_CONTENT.COMPARE_BASE) {
          instance.generateDefinitionReport(instance._sProjectPath);
          const currentDefinition = _.cloneDeep(instance._aReport);
          let fromDefinition;
          instance._sFromProject = instance.buildArgs.fromProject();
         
          if (fs.statSync(instance._sFromProject).isDirectory()) {
            let fromAppFile = path.join(instance._sFromProject, APPLICATION_FILE);
            if (!fs.existsSync(fromAppFile)) {
              console.error(logger.getError(`No ${fromAppFile}.`));
              reject(`No ${fromAppFile}.`);
            }
            instance._aReport = [];
            instance.generateDefinitionReport(instance._sFromProject);
            fromDefinition = _.cloneDeep(instance._aReport);
          } else {
            fromDefinition = fs.readJSONSync(instance._sFromProject);
          }

          const isCompatile = instance.checkDefinitionCompatible(fromDefinition, currentDefinition);
          if (isCompatile === true) {
            console.log(logger.getInfo("OK"));
          } else {
            console.error(logger.getError("Fail"));
            console.error(logger.getError(instance._aReport.detail));
          }
        }

        fs.ensureDirSync(path.dirname(instance.buildArgs.file()));
        fs.writeFileSync(instance.buildArgs.file(), JSON.stringify(instance._aReport, null, "\t"));
        resolve();
      } catch (error) {
        reject(error);
      }

    });
  }

  checkDefinitionCompatible(current, target) {
    let sError = "";

    current.forEach(curItem => {
      const targetItem = target.find(item => {
        return item.file === curItem.file;
      });

      if (targetItem) {
        curItem.ext.forEach(ext => {
          const targetExt = targetItem.ext.find(e => {
            return e.name === ext.name;
          });
          
          const extName = ext.name ? ext.name : "";
          if (targetExt) { 
            for (const key in ext.properties) {
              if (ext.properties.hasOwnProperty(key)) {
                if (ext.properties[key] === true) {
                  if (targetExt.properties[key] !== true) {
                    if (targetExt.properties[key]) {
                      sError += `Unmatch "${extName}/${key}" in ${targetItem.file}\n`;
                    } else {
                      sError += `Notfound "${extName}/${key}" in ${targetItem.file}\n`;
                    }
                  }
                } else {
                  if (targetExt.properties[key] !== true) {
                    if (Array.isArray(ext.properties[key])) {
                      ext.properties[key].forEach(v => {
                        switch (v) {
                          case KEY_ARRAY_REORDER:
                          case KEY_ARRAY_REMOVE:
                            if (!targetExt.properties[key]) {
                              sError += `Notfound "${extName}/${key}" in ${targetItem.file}\n`;
                            } else if (!targetExt.properties[key].includes(v)) {
                              sError += `Unmatch "${extName}/${key}/${v}" in ${targetItem.file}\n`;
                            }
                            break;
                          case KEY_ARRAY_INSERT_BEGIN:
                          case KEY_ARRAY_INSERT_END:
                            if (!targetExt.properties[key]) {
                              sError += `Notfound "${extName}/${key}" in ${targetItem.file}\n`;
                            }  else if (!targetExt.properties[key].includes(v) && !targetExt.properties[key].includes(KEY_ARRAY_INSERT_ANY)) {
                              sError += `Unmatch "${extName}/${key}/${v}" in ${targetItem.file}\n`;
                            }
                            break;
                          case KEY_ARRAY_INSERT_ANY:
                            if (!targetExt.properties[key]) {
                              sError += `Notfound "${extName}/${key}" in ${targetItem.file}\n`;
                            } else if (!targetExt.properties[key].includes(KEY_ARRAY_INSERT_ANY)) {
                              sError += `Unmatch "${extName}/${key}/${v}" in ${targetItem.file}\n`;
                            }
                            break;
                        }

                      });
                    }
                    //sError += `Failed to find extension points ${extName} ${key} in ${targetItem.file}\n`;
                  }
                }
              }
            }
          } else {
            sError += `Notfound "${extName}" in ${targetItem.file}\n`;
          }
        });
      } else {
        sError += `Notfound file ${curItem.file}\n`;
      }
    });

    if (sError) {
      instance._aReport = {
        "status": "fail",
        "detail": sError
      };
      return false;
    } else {
      instance._aReport = {
        "status": "pass"
      };
      return true;
    }
  }

  generateDefinitionReport(projectPath) {
    instance._aJsonFiles = [];
    instance._aJSFiles = [];

    let appFile = path.join(projectPath, APPLICATION_FILE);
    if (fs.existsSync(appFile)) {
      instance._aJsonFiles.push(appFile);
    } else {
      console.error(logger.getError(`No ${appFile}.`));
      reject(`No ${appFile}.`);
    }

    instance.getAllBaseFiles(projectPath);

    instance._aJsonFiles.forEach(file => {
      instance.getEPfromJsonFile(projectPath, file);
    });

    instance._aJSFiles.forEach(file => {
      instance.getEPfromJsFile(projectPath, file);
    });
  }

  generateUsageReport(projectPath) {
    instance._aMergeMapFiles = [];
    instance.getAllMergeMapFiles(projectPath);
    instance._aMergeMapFiles.forEach(file => {
      instance.getEPfromMergemapFile(projectPath, file);
    });
  }

  getEPfromJsonFile(projectPath, file) {
    try {
      const content = fs.readFileSync(file).toString();
      if (content.indexOf(EXTENSION_POINT_KEY) > 0) {
        const oJson = JSON.parse(content);
        let report = instance.getReportTemplate(projectPath, file);
        instance.findEPDefinition(oJson, report);
        if (report.ext.length > 0) {
          instance._aReport.push(report);
        }
      }
    } catch (e) {
      const msg = `Failed to parse file ${file} with error ${e.message}`;
      console.error(logger.getError(msg));
      reject(msg);
    }
  }

  getEPfromMergemapFile(projectPath, file) {
    try {
      const content = fs.readJSONSync(file);
      if (Array.isArray(content) && content.length > 0) {
        let report = instance.getReportTemplate(projectPath, file);
        instance.findEPUsage(content, report);
        if (report.ext.length > 0) {
          instance._aReport.push(report);
        }
      }
    } catch (e) {
      const msg = `Failed to parse file ${file} with error ${e.message}`;
      console.error(logger.getError(msg));
      reject(msg);
    }
  }

  getEPfromJsFile(projectPath, file) {
    const RegexJSExtContentStart = new RegExp(/\/\/ExtPt-(\w+):\s*==START==/, "g");
    const RegexJSExtLineStart = new RegExp(/\/\/ExtPt-(\w+):\s*==START==/, "m");
    const RegexJSExtContentEnd = new RegExp(/\/\/ExtPt-(\w+):\s*==END==/, "g");
    const RegexJSExtLineEnd = new RegExp(/\/\/ExtPt-(\w+):\s*==END==/, "m");

    const sContent = fs.readFileSync(file).toString();
    const linesWithStart = sContent.match(RegexJSExtContentStart);
    const linesWithEnd = sContent.match(RegexJSExtContentEnd);
    if (!linesWithStart && !linesWithEnd) {
      return;
    } else if (linesWithStart && linesWithEnd && linesWithStart.length === linesWithEnd.length) {
      let report = instance.getReportTemplate(projectPath, file);
      const startNames = linesWithStart?.map((line) => line.match(RegexJSExtLineStart)?.[1]);
      const endNames = linesWithEnd?.map((line) => line.match(RegexJSExtLineEnd)?.[1]);
      for (let i = 0; i < linesWithStart.length; i++) {
        if (startNames[i] === endNames[i]) {
          report.ext.push({
            "name": startNames[i]
          })
        } else {
          throw Error(`extension points start and end names are not matched in ${file}`);
        }
      }
      if (report.ext.length > 0) {
        instance._aReport.push(report);
      }

    } else {
      throw Error(`extension points start and end numbers are not matched in ${file}`);
    }
  }
  getAllBaseFiles(dirPath) {
    const files = fs.readdirSync(dirPath)
    files.forEach(function (file) {
      if (fs.statSync(dirPath + path.sep + file).isDirectory() && !file.startsWith(".")) {
        instance.getAllBaseFiles(dirPath + path.sep + file);
      } else {
        let suffix = path.extname(file);
        if (JSON_FILE_EXT.includes(suffix)) {
          instance._aJsonFiles.push(path.join(dirPath, path.sep, file));
        } else if (RULE_FILE_EXT === suffix) {
          instance._aJSFiles.push(path.join(dirPath, path.sep, file));
        }
      }
    });
  }

  getAllMergeMapFiles(dirPath) {
    const files = fs.readdirSync(dirPath)
    files.forEach(function (file) {
      if (fs.statSync(dirPath + path.sep + file).isDirectory() && !file.startsWith(".")) {
        instance.getAllMergeMapFiles(dirPath + path.sep + file);
      } else {
        let suffix = path.extname(file);
        if (suffix === MERGE_MAP_EXT) {
          instance._aMergeMapFiles.push(path.join(dirPath, path.sep, file));
        }
      }
    });
  }

  getReportTemplate(projectPath, file) {
    const relativePath = file.substring(projectPath.length + 1);
    let reportItem = {
      "file": relativePath,
      "ext": []
    };
    return reportItem;
  }

  findEPDefinition(obj, report) {
    if (obj[EXTENSION_POINT_KEY]) {
      if (obj[EXTENSION_POINT_KEY] === true) { //global
        report.ext.push({
          "properties": {
            "Value": true
          }
        });
        return;
      } else if (typeof obj[EXTENSION_POINT_KEY] === 'object') {
        if (obj._Name) {
          report.ext.push({
            "name": obj._Name,
            "properties": obj[EXTENSION_POINT_KEY]
          });
        } else {
          report.ext.push({
            "properties": obj[EXTENSION_POINT_KEY]
          });
        }
      }
    }

    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (value === null || key === EXTENSION_POINT_KEY) {
          continue;
        }

        if (Array.isArray(value)) {
          for (const item of value) {
            if (typeof item === 'object' && item !== null) {
              instance.findEPDefinition(item, report);
            }
          }
        } else if (typeof value === 'object') {
          instance.findEPDefinition(value, report);
        }
      }
    }

    return null;
  }

  getMergemapChange(value) {
    if (typeof value === 'object') {
      let hasKey = false;
      let isArray = true;
      let keys = [];
      for (const key in value) {
        hasKey = true;
        if (Predefined_ArrayKey.includes(key)) {
          if (key === KEY_ARRAY_ADD) {
            const arrayValue = value[key];
            if (Array.isArray(arrayValue)) {
              const insertEnd = arrayValue.every(item => { return item[KEY_ARRAY_INSERT_BEFORE_INDEX] !== undefined; });
              if (insertEnd) {
                if (!keys.includes("InsertEnd")) {
                  keys.push("InsertEnd");
                }
              } else {
                const insertBegin = arrayValue.every(item => { return item[KEY_ARRAY_INSERT_AFTER_INDEX] !== undefined; });
                if (insertBegin) {
                  let isInsertBegin = true;
                  for (let i = 0; i < arrayValue.length; i++) {
                    if (arrayValue[i][KEY_ARRAY_INSERT_AFTER_INDEX] === i - 1) {
                      continue;
                    } else {
                      if (!keys.includes(KEY_ARRAY_INSERT_ANY)) {
                        keys.push(KEY_ARRAY_INSERT_ANY);
                      }
                      isInsertBegin = false;
                      break;
                    }
                  }
                  if (isInsertBegin) {
                    if (!keys.includes(KEY_ARRAY_INSERT_BEGIN)) {
                      keys.push(KEY_ARRAY_INSERT_BEGIN);
                    }
                  }
                } else {
                  if (!keys.includes(KEY_ARRAY_INSERT_ANY)) {
                    keys.push(KEY_ARRAY_INSERT_ANY);
                  }
                }
              }
            } else {
              isArray = false;
            }
          } else if (!keys.includes(key)) {
            keys.push(key);
          }
        } else {
          isArray = false;
        }
      }

      if (hasKey) {
        if (isArray) {
          return keys;
        } else {
          return true;
        }
      } else {
        return true;
      }
    } else {
      return true;
    }
  }

  findEPUsage(mergemap, report) {
    const isRule = (report.file.indexOf(`Rules${path.sep}`) === 0);
    mergemap.forEach(item => {
      if (typeof item === 'object') {
        if (isRule) {
          report.ext.push({ "name": item.Name });
        } else {
          let existingItem = report.ext.find(c => { return c.name === item["_Name"]; });

          for (const key in item) {
            if (item.hasOwnProperty(key) && key !== "_Name") {
              if (existingItem) {
                existingItem.properties[key] = instance.getMergemapChange(item[key]);
              } else {
                let newItem = {
                  "properties": {}
                };
                if (item["_Name"]) {
                  newItem["name"] = item["_Name"];
                }
                newItem.properties[key] = instance.getMergemapChange(item[key]);
                report.ext.push(newItem);
              }
            }
          };
        }
      }
    });
  }
};

exports.Builder = Builder;
