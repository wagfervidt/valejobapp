function stringify(val) {
  if (val != null && typeof val === 'object') {
    // Objects (and arrays) are always JSON-encoded
    try {
      return JSON.stringify(val);
    } catch (e) {
      // Maybe a recursive reference.
      return Array.isArray(val) ? '[]' : '{}';
    }
  }
  return String(val);
}

function add(a, b) {
  const type1 = typeof a;
  const type2 = typeof b;
  if (type1 === 'string' || type2 === 'string') {
    // Actually a string concatenation
    return stringify(a) + stringify(b);
  }
  if (type1 === 'number' && type2 === 'number') {
    // Arithmetic sum
    return a + b;
  }
  return null;
}

function linearRegression(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return null;
  }
  const yValueArray = array1.filter(item => (typeof item === 'number' && Number.isFinite(item)));
  const xValueArray = array2.filter(item => (typeof item === 'number' && Number.isFinite(item)));
  if (xValueArray.length !== yValueArray.length) {
    return null;
  }
  const { length } = xValueArray;
  const result = {};

  let sumX = 0;
  let sumY = 0;
  let sumMultXiYi = 0;
  let sumSqrXi = 0;

  // eslint-disable-next-line no-plusplus
  for (let i = 0; i < length; i++) {
    const xi = xValueArray[i];
    const yi = yValueArray[i];
    sumX += xi;
    sumY += yi;
    sumMultXiYi += xi * yi;
    sumSqrXi += xi ** 2;
    const f = ((length * sumMultXiYi) - (sumX * sumY));
    const g = ((length * sumSqrXi) - (sumX * sumX));
    const cofB = f / g;
    const cofA = (sumY - (cofB * sumX)) / length;
    result.slope = Number.isNaN(cofB) ? null : cofB;
    result.intercept = Number.isNaN(cofA) ? null : cofA;
  }
  return result;
}

module.exports.add = add;
module.exports.linearRegression = linearRegression;
