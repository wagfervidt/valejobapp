#!/usr/bin/env node
const path = require('path');
const fs = require('fs-extra');
const Logger = require('../logger');
const timestamp = require('console-timestamp');
const commandLineArgs = require('command-line-args');
const valiator = require('../../language-service/out/lib/tool/MDKAppValidator');
const ChalkValidationLogger = require('./chalk-validation-logger').ChalkValidationLogger;
const DiagnosticFormatter = require('../../language-service/out/lib/tool/DiagnosticFormatter').DiagnosticFormatter;

const optionDefinitions = [
	{ name: 'seam-project', type: String, multiple: false },
	{ name: 'project', type: String, multiple: false },
	{ name: 'cim-apps', type: String, multiple: false },
	{ name: 'sdk-version', type: String, multiple: false },
	{ name: 'platform', type: String, multiple: false },
	{ name: 'validator-test', type: Boolean, multiple: false },
	{ name: 'reference-applications', type: String, multiple: false },
	{ name: 'result-file', type: String, multiple: false },
	{ name: 'allAppFullPaths', type: String, multiple: false }
];

let options = commandLineArgs(optionDefinitions);
console.log(JSON.stringify(options));
if (!options['seam-project']) {
	if (options['project']) {
		options['seam-project'] = path.resolve(options['project']);;
	} else {
		options['seam-project'] = process.cwd();
	}
}

let resultFilePath = options['result-file'];
if (!resultFilePath && !fs.existsSync(resultFilePath)) {
	resultFilePath = null;
	console.log(Logger.getWarn('Missing temp path and then cannot get the detail information about diagnostics.'));
}

function doValidate(test) {
	console.log("\n" + '[hh:mm:ss]'.timestamp + Logger.getPrompt(" -- validating --"));

	let diagnosticFormatter = new DiagnosticFormatter();
	let logger = new ChalkValidationLogger(resultFilePath, diagnosticFormatter);
	let context = {
		logger: logger,
		sdkVersion: options['sdk-version'],
		platform: options['platform']
	};
	context.diagnosticFormatter = diagnosticFormatter;

	logger.start(options['seam-project'], options['sdk-version']);

	let ok = true;
	let error = false;
	let promises = [];
	let thenable;

	let appFullPaths = options['allAppFullPaths'];
	if (appFullPaths) {
		if (isWin()) {
			appFullPaths = appFullPaths.replace(/\$/g, '"');
		}
		context.appFullPaths = JSON.parse(appFullPaths);
	}
	let referenceApplications = options['reference-applications'];
	if (referenceApplications) {
		if (isWin()) {
			referenceApplications = referenceApplications.replace(/\$/g, '"');
		}
		referenceApplications = JSON.parse(referenceApplications);
	}

	let appBasePath = options['seam-project'];
	if (referenceApplications) {
		context.referenceApps = referenceApplications[path.join(appBasePath, 'Application.app')];
	}
	thenable = valiator.validate(appBasePath, context);

	if (options['cim-apps']) {
		let cimAppPaths = options['cim-apps'].split(';');
		cimAppPaths.forEach(cimAppBasePath => {
			if (!!cimAppBasePath) {
				let contextForComponent = Object.assign({}, context);
				if (referenceApplications) {
					contextForComponent.referenceApps = referenceApplications[path.join(cimAppBasePath, 'Application.app')];
				}
				promises.push(valiator.validate(cimAppBasePath, contextForComponent));
			}
		});
	}

	promises.push(Promise.resolve());

	promises.forEach(promise => {
		thenable = thenable.then(result => {
			ok = ok && result;
			return promise;
		}, err => {
			if (err) {
				error = true;
				logger.error(Logger.getError(err));
			}
		});
	});

	return thenable.then(() => {
		if (error) {
			if (!!test) {
				return Promise.resolve(false);
			} else {
				process.exit(-1);
			}
		}

		logger.end();
		if (ok) {
			return Promise.resolve(ok);
		} else {
			if (!!test) {
				return Promise.resolve(false);
			} else {
				process.exit(1);
			}
		}
	});
}

function isWin() {
	const os = require('os');
	const platform = os.platform();
	return platform === 'win32';
}

//exports.result = doValidate(options['validator-test']);
module.exports = { doValidate };