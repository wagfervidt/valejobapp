/* eslint-disable no-param-reassign */
const functions = require('./functions');

const functionNames = Object.keys(functions);

function randomInt(max) {
  return Math.floor(Math.random() * max);
}

function choose(...args) {
  const index = randomInt(args.length);
  const value = args[index];
  if (typeof value === 'function') {
    return value();
  }
  return value;
}

function randomString(length) {
  const str = [];
  for (let i = 0; i < length; i += 1) {
    str.push((10 + randomInt(14)).toString(24));
  }
  return str.join('');
}

function dice(complexity, errorCount) {
  return Math.random() * complexity < errorCount;
}

function generateWhitespace() {
  return choose('', ' ', '  ');
}

function generateConstant() {
  return choose(
    () => (Math.random() * 100).toFixed(2),
    () => String(Math.round(Math.random() * 100)),
    0,
    () => `"${randomString(randomInt(6))}"`,
    () => `'${randomString(randomInt(6))}'`,
    'true',
    'false',
    'null',
    'undefined',
    'NaN',
  );
}

function generateParameters(complexity, errorCount) {
  if (errorCount > 0 && complexity < 2) {
    complexity = 2;
  }
  const parts = [generateWhitespace()];
  let index = 0;
  while (complexity > 0) {
    if (index > 0) {
      parts.push(',');
      parts.push(generateWhitespace());
    }
    const paramComplexity = 1 + randomInt(complexity);
    const paramErrorCount = Math.min(randomInt(paramComplexity + 1), errorCount);
    parts.push(generateFormula(paramComplexity, paramErrorCount));
    parts.push(generateWhitespace());
    complexity -= paramComplexity;
    errorCount -= paramErrorCount;
    index += 1;
  }
  return parts.join('');
}

function generateAliases(complexity, errorCount) {
  const parts = [generateWhitespace()];
  for (let index = 0; index < complexity; index += 1) {
    if (index > 0) {
      parts.push(',');
      parts.push(generateWhitespace());
    }
    const hasError = dice(complexity - index, errorCount);
    if (hasError) {
      errorCount -= 1;
      if (index > 0 && Math.random() < 0.5) {
        parts.push(`alias${index - 1}`);
        parts.push(generateWhitespace());
      }
    } else {
      parts.push(`alias${index}`);
      parts.push(generateWhitespace());
    }
  }
  return parts.join('');
}

function generateEntries(complexity, errorCount) {
  const parts = [generateWhitespace()];
  let index = 0;
  while (complexity > 0) {
    if (index > 0) {
      parts.push(',');
      parts.push(generateWhitespace());
    }
    const paramComplexity = 1 + randomInt(complexity);
    const paramErrorCount = Math.min(randomInt(paramComplexity + 1), errorCount);
    let omit = 0;
    if (dice(paramComplexity, paramErrorCount)) {
      omit = 1 + randomInt(2);
    }
    if (omit !== 1) {
      parts.push(choose(
        () => randomString(1 + randomInt(5)),
        () => `"${randomString(6)}"`,
        () => `'${randomString(6)}'`,
      ));
      // parts.push(generateWhitespace());
    }
    parts.push(':');
    if (omit !== 2) {
      parts.push(generateWhitespace());
      parts.push(generateFormula(paramComplexity, paramErrorCount - (omit ? 1 : 0)));
      parts.push(generateWhitespace());
    }
    complexity -= paramComplexity;
    errorCount -= paramErrorCount;
    index += 1;
  }
  return parts.join('');
}

function generateFunctionCall(complexity, errorCount) {
  const funcName = choose(...functionNames);
  const parts = [funcName];
  if (Math.random() < 0.4) {
    const aliasCount = 1 + randomInt(complexity);
    let aliasErrorCount = randomInt(Math.min(errorCount, aliasCount) + 1);
    let open = false;
    if (dice(aliasCount, aliasErrorCount)) {
      aliasErrorCount -= 1;
      open = true;
    }
    parts.push('<', generateAliases(aliasCount, aliasErrorCount));
    if (!open) {
      parts.push('>');
    }
  }
  if (dice(complexity, errorCount)) {
    parts.push(`(${generateParameters(complexity - 1, errorCount - 1)}`);
  } else {
    parts.push(`(${generateParameters(complexity - 1, errorCount)})`);
  }
  return parts.join('');
}

function generateArray(complexity, errorCount) {
  if (dice(complexity, errorCount)) {
    return `[${generateParameters(complexity - 1, errorCount - 1)}`;
  }
  return `[${generateParameters(complexity - 1, errorCount)}]`;
}

function generateObject(complexity, errorCount) {
  if (dice(complexity, errorCount)) {
    return `{${generateEntries(complexity - 1, errorCount - 1)}`;
  }
  return `{${generateEntries(complexity - 1, errorCount)}}`;
}

function generateGroup(complexity, errorCount) {
  if (dice(complexity, errorCount)) {
    return `(${generateFormula(complexity - 1, errorCount - 1)}`;
  }
  return `(${generateFormula(complexity - 1, errorCount)})`;
}

const binaryOperators = ['+', '-', '/', '*', '%', '<', '>', '<=', '>=', '==', '!=', '===', '!==', '&&', '||'];
const unaryOperators = ['!!', '!', '-', '+'];

function generateBinaryOperation(complexity, errorCount, noUnary) {
  const operator = choose(...binaryOperators);
  const complexity1 = 1 + randomInt(complexity - 1);
  const complexity2 = complexity - complexity1;
  const errorCount1 = Math.min(randomInt(complexity1 + 1), errorCount);
  const errorCount2 = errorCount - errorCount1;
  return `${generateFormula(complexity1, errorCount1, noUnary)}${generateWhitespace()}${operator}${generateWhitespace()}${generateFormula(complexity2, errorCount2)}`;
}

function generateUnaryOperation(complexity, errorCount) {
  const operator = choose(...unaryOperators);
  return `${operator}${generateFormula(complexity - 1, errorCount, true)}`;
}

function generateFormula(complexity, errorCount, noUnary) {
  if (!complexity) {
    return '';
  }
  if (complexity <= 1) {
    return choose(
      () => (errorCount ? '' : generateConstant()),
      () => generateFunctionCall(complexity, errorCount),
    );
  }
  return choose(
    () => generateFunctionCall(complexity, errorCount),
    () => generateBinaryOperation(complexity, errorCount, noUnary),
    () => generateArray(complexity, errorCount),
    () => generateObject(complexity, errorCount),
    () => generateGroup(complexity, errorCount),
    ...noUnary ? [] : [() => generateUnaryOperation(complexity, errorCount)],
  );
}

module.exports.generateFormula = generateFormula;
