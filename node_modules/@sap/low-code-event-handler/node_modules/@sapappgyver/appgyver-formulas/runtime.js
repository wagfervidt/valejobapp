const { includesValue, unionValues } = require('@sapappgyver/appgyver-schemas/utils/array');
const functionImplementations = require('./functions/runtime');
const functionReverts = require('./functions/inverts');
const { transform } = require('./utils/object');
const { createFunctionInverter, applyInverse } = require('./utils/inverse');
const { assertNotTimedOut } = require('./timeout');

function invalidExpressionExecutor() {
  throw Error('Invalid expression');
}

function inverseNotSupported() {
  throw Error('Expression is not inversible');
}

/**
 * We disallow accessing these global variables explicitly in the runtime function.
 * This is not a comprehensive list, especially in the browser environment. We could
 * determine practically all global variables by itertating through window prorotype chain
 * and getting all the properties, but the number of items may become a performance issue,
 * so let's keep this simple and just blacklist the most common global variables.
 */
const globalKeyBlacklist = [
  'Array',
  'ArrayBuffer',
  'Atomics',
  'BigInt',
  'BigInt64Array',
  'BigUint64Array',
  'Boolean',
  'Buffer',
  'clearImmediate',
  'clearInterval',
  'clearTimeout',
  'console',
  'DataView',
  'Date',
  'decodeURI',
  'decodeURIComponent',
  'DTRACE_HTTP_CLIENT_REQUEST',
  'DTRACE_HTTP_CLIENT_RESPONSE',
  'DTRACE_HTTP_SERVER_REQUEST',
  'DTRACE_HTTP_SERVER_RESPONSE',
  'DTRACE_NET_SERVER_CONNECTION',
  'DTRACE_NET_STREAM_END',
  'encodeURI',
  'encodeURIComponent',
  'Error',
  'escape',
  'eval',
  'EvalError',
  'Float32Array',
  'Float64Array',
  'Function',
  'global',
  'hasOwnProperty',
  'Infinity',
  'Int16Array',
  'Int32Array',
  'Int8Array',
  'Intl',
  'isFinite',
  'isNaN',
  'isPrototypeOf',
  'JSON',
  'Map',
  'Math',
  'Number',
  'Object',
  'parseFloat',
  'parseInt',
  'process',
  'Promise',
  'propertyIsEnumerable',
  'Proxy',
  'RangeError',
  'ReferenceError',
  'Reflect',
  'RegExp',
  'Set',
  'setImmediate',
  'setInterval',
  'setTimeout',
  'SharedArrayBuffer',
  'String',
  'Symbol',
  'SyntaxError',
  'toLocaleString',
  'toString',
  'TypeError',
  'Uint16Array',
  'Uint32Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'unescape',
  'URIError',
  'URL',
  'URLSearchParams',
  'valueOf',
  'WeakMap',
  'WeakSet',
  'WebAssembly',
  'window',
];

const functionInverters = transform(functionImplementations, (fn, functionName) => {
  const inverter = functionReverts[functionName];
  return createFunctionInverter(functionName, fn, inverter);
});

const emptyContext = {};

class ExecutableExpression {
  constructor({
    script, inverse, dependencies, functions, inverts,
  }, context) {
    // Some runtime context to be passed as each function every call.
    // It will be pre-bound for each function call and is therefore _mutated_
    // whenever the execution starts.
    this.runtime = {
      timeout: null, // To be set on execution
      timestamp: null, // To be set on execution
      checkTimeout: () => {
        const { timestamp, timeout } = this.runtime;
        assertNotTimedOut(timestamp, timeout);
      },
    };
    // Determine from dependencies which keys from the context we need to use.
    const allContextKeys = dependencies
      ? unionValues(dependencies.map(([rootKey]) => rootKey))
      : Object.keys(context);
    // Never provide 'this' as a parameter name
    const contextKeys = allContextKeys.filter(key => key !== 'this');
    // Choose functions that will be used by the expression.
    // If no functions are defined then use all the functions.
    const functionContextKeys = functions || Object.keys(functionImplementations);
    const functionContext = {};
    functionContextKeys.forEach((functionName) => {
      // Create a wrapper function for this function name,
      // which will call the actual implementation.
      const fn = functionImplementations[functionName];
      if (fn) {
        const wrapper = (...args) => fn(args, this.runtime);
        wrapper.inv = functionInverters[functionName];
        functionContext[functionName] = wrapper;
      }
      // NOTE: Otherwise, if function is not defined, the runtime will fail
      // with a native "XXXX is not a function" error
    });
    // TODO: Ensure that there are no duplicates!
    const parameterNames = contextKeys.concat(functionContextKeys);
    // Mask all known global variables by adding them as additional, undefined parameters
    globalKeyBlacklist.forEach((globalVar) => {
      if (!includesValue(parameterNames, globalVar)) {
        parameterNames.push(globalVar);
      }
    });
    try {
      this.executor = script
        // eslint-disable-next-line no-new-func
        ? new Function(...parameterNames, `return (${script});`)
        : invalidExpressionExecutor;
      this.syntaxError = null;
    } catch (error) {
      this.syntaxError = error;
      this.executor = () => { throw error; };
    }
    try {
      this.inverter = inverse
        // eslint-disable-next-line no-new-func
        ? new Function(...parameterNames, `return (${inverse});`)
        : inverseNotSupported;
    } catch (error) {
      this.inverter = () => { throw error; };
    }
    this.context = context;
    this.functionContext = functionContext;
    this.contextKeys = contextKeys;
    this.functionContextKeys = functionContextKeys;
    this.functionParams = functionContextKeys.map(key => functionContext[key]);
    this.script = script;
    this.dependencies = dependencies;
    this.inverts = inverse ? inverts || dependencies : null;
    this.defaultThis = {};
  }

  execute(context = this.context || emptyContext, options) {
    const contextParams = this.contextKeys.map(key => context[key]);
    // Custom object for `this` to prevent access the global scope throught it
    const execThis = context.this != null ? context.this : this.defaultThis;
    this.runtime.timeout = options ? options.timeout : null;
    this.runtime.timestamp = +new Date();
    return this.executor.apply(execThis, contextParams.concat(this.functionParams));
  }

  invertDiff(result, context = this.context || emptyContext) {
    const contextParams = this.contextKeys.map(key => context[key]);
    // Custom object for `this` to prevent access the global scope throught it
    const execThis = context.this != null ? context.this : this.defaultThis;
    const next = this.inverter.apply(execThis, contextParams.concat(this.functionParams));
    return applyInverse(result, next, context);
  }

  invert(result, context = this.context || emptyContext) {
    const contextUpdate = this.invertDiff(result, context);
    return { ...context, ...contextUpdate };
  }
}

/**
 * Prepares previously exported expression for evaluation.
 * @param {object} expression An exported expression object
 * @param {object} context Runtime context available for the expression
 */
function prepareExecutable(expression, context) {
  return new ExecutableExpression(expression, context == null ? emptyContext : context);
}

module.exports.prepareExecutable = prepareExecutable;
