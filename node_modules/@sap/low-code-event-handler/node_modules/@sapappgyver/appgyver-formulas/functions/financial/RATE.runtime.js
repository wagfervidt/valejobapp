module.exports = ([periods, payment, present, future = 0, isOnBeginning = false, guess = 0.1]) => {
  const guessSaved = (guess === undefined) ? 0.01 : guess;
  const futureSaved = (future === undefined) ? 0 : future;
  const isOnBeginningSaved = isOnBeginning || false;

  if (typeof periods === 'number' && Number.isFinite(periods)
    && typeof payment === 'number' && Number.isFinite(payment)
    && typeof present === 'number' && Number.isFinite(present)
    && typeof futureSaved === 'number' && Number.isFinite(futureSaved)
    && typeof isOnBeginningSaved === 'boolean'
    && typeof guessSaved === 'number' && Number.isFinite(guessSaved)) {
    const type = Number(isOnBeginningSaved);
    // Set maximum epsilon for end of iteration
    const epsMax = 1e-6;

    // Set maximum number of iterations
    const iterMax = 100;
    let iter = 0;
    let close = false;
    let rate = guessSaved;

    while (iter < iterMax && !close) {
      const t1 = (rate + 1) ** periods;
      const t2 = (rate + 1) ** (periods - 1);

      const f1 = futureSaved + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
      const f2 = periods * t2 * present - payment * (t1 - 1) * (rate * type + 1) / (rate ** 2);
      const f3 = periods * payment * t2 * (rate * type + 1)
        / rate + payment * (t1 - 1) * type / rate;

      const newRate = rate - f1 / (f2 + f3);

      if (Math.abs(newRate - rate) < epsMax) close = true;
      // eslint-disable-next-line no-plusplus
      iter++;
      rate = newRate;
    }

    if (!close) return null;
    return rate;
  }
  return null;
};
