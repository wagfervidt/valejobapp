#!/usr/bin/env node

const os = require("os");
const fs = require('fs-extra');
const dir = require('node-dir');
const path = require('path');
const program = require('commander');
const inquirer = require('inquirer');
const toolUtils = require('../../tool-utils');
const utils = require('../../utils');
const fail = toolUtils.fail;
const isDirectory = toolUtils.isDirectory;
const shelljs = require('shelljs');
const migrateJson = require('./migrate.json');

class MetadataMigrate {
  constructor() {
    let argvCommand = program
      .version('6.0.0')
      .option('-v, --verbose', 'show the file changes information (Mac OS only)')
      .option('-l, --log <file-path>', 'log to the file')
      .option('-s, --srcdir <dir-path>', 'path to source directory')
      .option('-o, --outdir <dir-path>', 'path to output directory (the source directory will be copied to this output directory then migrate files inside); if it is not specified, migrate files in the source directory directly')
      ;
    argvCommand.parse(process.argv);

    this.isMac = (os.type() === "Darwin");
    this.NSPlugins = null;
    this.sSdkPath = utils.getRootPath();
    this.defaultSourceFolder = 'template.mdkproject';
    this.sInitMdkProject = program.srcdir;
    this.sMdkProject = program.srcdir;
    this.sOutDir = program.outdir;
    this.sLogFilePath = program.log;
    this.verbose = program.verbose;
    this.udaptedFiles = [];
    this.removedFiles = [];

    if (this.sLogFilePath) {
      fs.closeSync(fs.openSync(this.sLogFilePath, 'w'));
    }

    this.replaceItems = migrateJson.REPLACED_ITEMS;
    for (let item of migrateJson.REPLACED_EXTERNALS) {
      let newItem = item;
      newItem.startsWith = true;

      this.replaceItems.push(newItem);
    }
  }

  getMDKProjectPath() {
    function testMDKProjectPath(sValue) {
      sValue = path.resolve(sValue
        .trim()
        .replace(/\/$/, '')
        .replace('~', process.env.HOME));
      if (!isDirectory(sValue)) {
        return `Could not find the source directory: ${sValue}`;
      }

      // Use the transformed value going forward
      this.sMdkProject = path.resolve(sValue);
      return true;
    }
    if (this.sMdkProject) {
      if (testMDKProjectPath.bind(this)(this.sMdkProject)) {
        this.log(`Using ${this.sMdkProject}`);
        return Promise.resolve();
      } else {
        return Promise.reject();
      }
    } else {
      const oMDKProjectQuestion = {
        type: 'input',
        name: 'mdkproject',
        message: 'Enter the path of the source directory.',
        default: path.resolve(this.sSdkPath, this.defaultSourceFolder),
        validate: testMDKProjectPath.bind(this),
      };
      return inquirer.prompt([oMDKProjectQuestion])
        .then(() => {
          this.log(`Using ${this.sMdkProject}`);
        });
    }
  }

  getOutDir() {
    function testOutPath(sValue) {
      sValue = path.resolve(sValue
        .trim()
        .replace(/\/$/, '')
        .replace('~', process.env.HOME));
      if (sValue && !isDirectory(sValue)) {
        return `Could not find the output directory: ${sValue}`;
      }
      // Use the transformed value going forward
      this.sOutDir = sValue ? path.resolve(sValue) : null;
      return true;
    }

    if (this.sOutDir) {
      if (testOutPath.bind(this)(this.sOutDir)) {
        this.log(`Using ${this.sOutDir} for output directory`);
        return Promise.resolve();
      } else {
        return Promise.reject();
      }
    } else if (!this.sInitMdkProject) {
      const oOutDirQuestion = {
        type: 'input',
        name: 'outdir',
        message: 'Enter the path of the output directory.',
        validate: testOutPath.bind(this),
      };
      return inquirer.prompt([oOutDirQuestion])
        .then(() => {
          if (this.sOutDir) {
            this.log(`Using ${this.sOutDir}`);
          } else {
            this.log(`Using ${this.sMdkProject}`);
          }
        });
    }
  }

  run() {
    this.log('');
    return this.getMDKProjectPath()
      .then(this.getOutDir.bind(this))
      .then(this.migrate.bind(this))
      .then(this.showInfo.bind(this))
      .catch(e => {
        fail(e);
      });
  }

  showInfo() {
    if (this.NSPlugins && this.NSPlugins && this.NSPlugins.length > 0) {
      this.log('NOTE: Please check the following NativeScript plugins are compatible with NativeScript 8:');

      for (let i = 0; i < this.NSPlugins.length; i++) {
        this.log(`   ${i + 1}) ${this.NSPlugins[i]}`);
      }

      this.log('');
    }

    if (this.verbose && this.sOrgMdkProject && (this.sOrgMdkProject !== this.sMdkProject)) {
      if (this.isMac) {
        this.log('File Changes:');
        let logArg = '';
        if (this.sLogFilePath) {
          logArg = `2>&1 | tee -a "${this.sLogFilePath}"`
        }
        shelljs.exec(`diff -x '.*' -r "${this.sOrgMdkProject}" "${this.sMdkProject}" ${logArg}`, { silent: false });
        this.log('');
      }
    }
  }

  migrate() {
    this.sMdkProject = path.resolve(this.sMdkProject);
    if (this.sOutDir) {
      let outFolder = path.resolve(this.sOutDir, path.basename(this.sMdkProject));
      if (outFolder !== this.sMdkProject) {
        if (fs.existsSync(outFolder)) {
          this.log(`Removing existing directory ${outFolder}`);
          shelljs.rm('-rf', outFolder);
        }

        shelljs.cp('-r', this.sMdkProject, this.sOutDir);

        this.sOrgMdkProject = this.sMdkProject;
        this.sMdkProject = outFolder;
      }

      this.log(`Output to ${this.sMdkProject}`);
    }

    this.udaptedFiles = [];
    return new Promise((resolve, reject) => {
      dir.readFiles(this.sMdkProject, {
        match: /\.ts$|\.js$|\.json$/
      }, (err, content, filePath, next) => {
        let fileName = path.basename(filePath);
        let fileExt = path.extname(filePath);

        if (fileExt === '.ts') {
          this.migrateTS(filePath, content);
        } else if (fileExt === '.js') {
          if (filePath.endsWith(path.join('demo', 'demo.js'))) {
            this.migrateDemoJS(filePath, content);
          } else {
            this.migrateJS(filePath, content);
          }
        } else if (fileName === 'tsconfig.json') {
          this.removeFile(filePath);
        } else if (fileName === 'MDKProject.json') {
          this.migrateMDKProjectJson(filePath, content);
        }

        next();
      }, (err, files) => {

        if (err) {
          reject(err);
        } else {
          this.log(`\nDone: read ${files.length} files, update ${this.udaptedFiles.length} files, remove ${this.removedFiles.length} files\n`);
          resolve();
        }
      });
    });
  }

  migrateMDKProjectJson(filePath, fileData) {
    this.updateJsonFileData(filePath, fileData, (jsonObj) => {
      let fileChanged = false;

      if (jsonObj.Externals && jsonObj.Externals.length && jsonObj.Externals.length > 0) {
        let items = [];
        for (let item of jsonObj.Externals) {
          if (item) {
            let removed = false;
            for (let removedExternal of migrateJson.REMOVED_EXTERNALS) {
              if (removedExternal.startsWith) {
                if (item.startsWith(removedExternal.path)) {
                  removed = true;
                  break;
                }
              } else {
                if (item === removedExternal.path) {
                  removed = true;
                  break;
                }
              }
            }

            if (removed) {
              fileChanged = true;
            } else {
              for (let replacedExternal of migrateJson.REPLACED_EXTERNALS) {
                if (item.startsWith(replacedExternal.old)) {
                  item = item.replace(replacedExternal.old, replacedExternal.new);
                  fileChanged = true;
                  break;
                }
              }

              items.push(item);
            }
          } else {
            fileChanged = true;
          }
        }

        jsonObj.Externals = items;
      }

      if (jsonObj.NSPlugins && jsonObj.NSPlugins.length && jsonObj.NSPlugins.length > 0) {
        let NSPluginsForCheck = [];
        let items = [];
        for (let item of jsonObj.NSPlugins) {
          if (item) {
            let replaced = false;
            for (let replacedPlugin of migrateJson.REPLACED_PLUGINS) {
              if (item.startsWith(replacedPlugin.old)) {
                item = item.replace(replacedPlugin.old, replacedPlugin.new);
                replaced = true;
                fileChanged = true;
                break;
              } else if (item.startsWith(replacedPlugin.new)) {
                replaced = true;
                break;
              }
            }

            if (!replaced) {
              NSPluginsForCheck.push(item);
            }

            items.push(item);
          } else {
            fileChanged = true;
          }
        }

        jsonObj.NSPlugins = items;
        this.NSPlugins = NSPluginsForCheck;
      }

      return fileChanged;
    });
  }

  removeFile(filePath) {
    fs.unlinkSync(filePath);
    this.countFileRemoved(filePath);
  }

  updateJsonFileData(filePath, content, updateFunc) {
    try {
      let jsonObj = JSON.parse(content);
      if (updateFunc(jsonObj)) {
        content = JSON.stringify(jsonObj, null, '\t');
        fs.writeFileSync(filePath, content, 'utf-8');
        this.countFileChanged(filePath);
      }
    } catch (e) {
      this.log(`ERROR: failed in ${filePath}`);
      this.log(e);
    }
  }

  migrateTS(filePath, content) {
    content = this.updateFileDataUsingRegExp(filePath, content, [{
      regexp: "(import.*?from\\s*?')(.*?)(')",
      replaceFunc: this.migrateTSModules.bind(this)
    }, {
      regexp: '(import.*?from\\s*?")(.*?)(")',
      replaceFunc: this.migrateTSModules.bind(this)
    }]);

    this.migrateNativeClassTS(filePath, content);
  }

  migrateNativeClassTS(filePath, content) {
    this.updateFileDataUsingRegExp(filePath, content, [{
      regexp: "(@[^};'\"]*?)?(^\\s*?)(export\\s*?)?(class[\\s\\S]+?extends\\s+)(.\\S+)([\\s\\S]*?{)",
      replaceFunc: this.addTSNativeClass.bind(this)
    }]);
  }

  addTSNativeClass(re, filePath, fileData) {
    const nativeClass = '@NativeClass()';

    let fileChanged = false;
    let exportClasses = [];
    fileData = fileData.replace(re, (match, decorators, preSpace, preExport, s4, baseClass, s6) => {
      preSpace = preSpace || '';
      preExport = preExport || '';
      if (decorators) {
        if (decorators.indexOf(nativeClass) === -1) {
          if (this.isNativeClass(baseClass)) {
            fileChanged = true;
            let lines = preSpace.split('\n');
            if (preExport) {
              const className = this.getClassName(s4);
              if (className) {
                exportClasses.push(className);
              }
            }
            return decorators + preSpace + nativeClass + '\n' + lines[lines.length - 1] + s4 + baseClass + s6;
          } else {
            return match;
          }
        } else {
          if (preExport) {
            fileChanged = true;

            const className = this.getClassName(s4);
            if (className) {
              exportClasses.push(className);
            }

            return decorators + preSpace + s4 + baseClass + s6;
          } else {
            return match;
          }
        }
      } else {
        if (this.isNativeClass(baseClass)) {
          fileChanged = true;
          let lines = preSpace.split('\n');
          if (preExport) {
            const className = this.getClassName(s4);
            if (className) {
              exportClasses.push(className);
            }
          }
          return preSpace + nativeClass + '\n' + lines[lines.length - 1] + s4 + baseClass + s6;
        } else {
          return match;
        }
      }
    });

    if (fileChanged && exportClasses.length > 0) {
      fileData += '\nexport { ' + exportClasses.join(', ') + ' };\n';
    }

    return { fileChanged: fileChanged, fileData: fileData };
  }

  getClassName(classInfo) {
    if (!classInfo) {
      return '';
    }

    const words = classInfo.split(/\s/);
    let count = 0;
    for (const word of words) {
      if (word.trim()) {
        count++;
      }

      if (count === 2) {
        return word.trim();
      }
    }

    return '';
  }

  isNativeClass(className) {
    if (!className) {
      return false;
    }

    for (let item of migrateJson.NATIVE_CLASSES) {
      if (item.startsWith) {
        if (className.startsWith(item.name)) {
          return true;
        }
      } else {
        if (className === item.name) {
          return true;
        }
      }
    }

    return false;
  }

  migrateDemoJS(filePath, content) {
    let replaceItems = [{
      old: '_tns_core_modules_',
      new: '_nativescript_core_'
    }];

    for (let item of this.replaceItems) {
      if (item.startsWith) {
        replaceItems.push(item);
      } else {
        let newItem1 = {
          old: `"${item.old}"`,
          new: `"${item.new}"`,
        }

        let newItem2 = {
          old: `'${item.old}'`,
          new: `'${item.new}'`,
        }

        replaceItems.push(newItem1);
        replaceItems.push(newItem2);
      }
    }

    this.updateFileDataByReplaceArray(filePath, content, replaceItems);
  }

  migrateJS(filePath, content) {
    this.updateFileDataUsingRegExp(filePath, content, [{
      regexp: "(require\\s*?\\(\\s*?')(.*?)('\\s*?\\))",
      replaceFunc: this.migrateJSModules.bind(this)
    }, {
      regexp: '(require\\s*?\\(\\s*?")(.*?)("\\s*?\\))',
      replaceFunc: this.migrateJSModules.bind(this)
    }, {
      regexp: '(define\\(\\[)(.*?)(\\],\\s*?factory\\))',
      replaceFunc: this.migrateJSModulesForDefine.bind(this)
    }, {
      regexp: '(factory\\(root\\[)(.*?)(\\]\\))',
      replaceFunc: this.migrateJSModulesForDefine.bind(this)
    }, {
      regexp: "(import.*?from\\s*?')(.*?)(')",
      replaceFunc: this.migrateJSModules.bind(this)
    }, {
      regexp: '(import.*?from\\s*?")(.*?)(")',
      replaceFunc: this.migrateJSModules.bind(this)
    }]);
  }

  migrateJSModulesForDefine(re, filePath, fileData) {
    let fileChanged = false;
    fileData = fileData.replace(re, (match, s1, importPath, s3) => {
      let newImportPath = importPath;

      let itemChanged = false;
      for (const item of this.replaceItems) {
        let find = false;
        if (item.startsWith) {
          find = importPath.startsWith(item.old);
        } else {
          find = importPath === item.old;
        }
        if (find) {
          newImportPath = newImportPath.replace(item.old, item.new);
          itemChanged = true;
          fileChanged = true;
          break;
        }
      }

      if (itemChanged) {
        return s1 + newImportPath + s3;
      } else {
        return match;
      }
    });

    return { fileChanged: fileChanged, fileData: fileData };
  }

  migrateTSJSModules(re, filePath, fileData, allowTS) {
    let fileFolder = path.dirname(filePath);
    let fileChanged = false;
    fileData = fileData.replace(re, (match, s1, importPath, s3) => {
      let result = this.replaceRequireInTsAndJs(match, s1, importPath, s3, fileFolder, allowTS);
      fileChanged = fileChanged || result.fileChanged;

      return result.match;
    });

    return { fileChanged: fileChanged, fileData: fileData };
  }

  replaceRequireInTsAndJs(match, s1, importPath, s3, fileFolder, allowTS) {
    let fileChanged = false;
    let newImportPath = importPath;

    let itemChanged = false;
    for (const item of this.replaceItems) {
      let find = false;
      if (item.startsWith) {
        find = importPath.startsWith(item.old);
      } else {
        find = importPath === item.old;
      }
      if (find) {
        newImportPath = newImportPath.replace(item.old, item.new);
        itemChanged = true;
        fileChanged = true;
        break;
      }
    }

    if (newImportPath.startsWith('@nativescript/core')) {
      for (let item of migrateJson.DOUBLE_NAMES) {
        const doubleName = item + '/' + item;
        if (newImportPath.endsWith(doubleName)) {
          newImportPath = newImportPath.replace(doubleName, item);
          itemChanged = true;
          fileChanged = true;
        }
      }
    }

    if (itemChanged) {
      return { fileChanged: fileChanged, match: s1 + newImportPath + s3 };
    } else {
      return { fileChanged: fileChanged, match: match };
    }
  }

  migrateJSModules(re, filePath, fileData) {
    return this.migrateTSJSModules(re, filePath, fileData, false);
  }

  migrateTSModules(re, filePath, fileData) {
    return this.migrateTSJSModules(re, filePath, fileData, true);
  }

  updateFileDataUsingRegExp(filePath, fileData, regexps) {
    let fileChanged = false;

    for (const item of regexps) {
      const re = new RegExp(item.regexp, 'gm');
      if (re.test(fileData)) {
        let r = item.replaceFunc(re, filePath, fileData);

        fileChanged = fileChanged || r.fileChanged;
        if (r.fileChanged) {
          fileData = r.fileData;
        }
      }
    }

    if (fileChanged) {
      fs.writeFileSync(filePath, fileData, 'utf-8');
      this.countFileChanged(filePath);
    }

    return fileData;
  }

  updateFileDataByReplaceArray(filePath, fileData, replaceItems) {
    let fileChanged = false;

    for (const item of replaceItems) {
      if (fileData.indexOf(item.old) !== -1) {
        fileData = this.replaceAll(fileData, item.old, item.new);
        fileChanged = true;
      }
    }

    if (fileChanged) {
      fs.writeFileSync(filePath, fileData, 'utf-8');
      this.countFileChanged(filePath);
    }
  }

  countFileChanged(filePath) {
    if (this.udaptedFiles.indexOf(filePath) === -1) {
      this.udaptedFiles.push(filePath);
      this.log(`Updated ${filePath}`);
    }
  }

  countFileRemoved(filePath) {
    if (this.removedFiles.indexOf(filePath) === -1) {
      this.removedFiles.push(filePath);
      this.log(`Removed ${filePath}`);
    }
  }

  escapeRegExp(str) {
    return str.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
  }

  replaceAll(str, find, replace) {
    return str.replace(new RegExp(this.escapeRegExp(find), 'gm'), replace);
  }

  log(str) {
    console.log(str);

    if (this.sLogFilePath) {
      fs.appendFileSync(this.sLogFilePath, str + '\n');
    }
  }
}

exports.MetadataMigrate = MetadataMigrate;

if (require.main === module) {
  const c = new MetadataMigrate();
  c.run();
}
