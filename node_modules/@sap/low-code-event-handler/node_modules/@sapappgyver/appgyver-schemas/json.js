const { normalizeSchema } = require('./normalization');
const { makeError, stringify, stringifyType } = require('./utils/shortcuts');
const { upperFirst } = require('./utils/string');

const jsonSerializableSimpleTypes = {
  string: true,
  number: true,
  boolean: true,
  null: true,
  undefined: true,
  json: true,
  value: true,
  schema: true,
};

/**
 * Checks  the given schema type only consists of JSON-serializable types.
 * The following types are accepted:
 *
 * - string
 * - number
 * - boolean
 * - null
 * - undefined (even though not technically JSON-serializable)
 * - object containing only JSON-serializable properties
 * - array containing only JSON-serializable properties
 * - "json" type
 * - "schema" type
 * - wildcard type "value"
 *
 * Unknown or partially unknown types are not considered
 * JSON-serializable.
 *
 * Returns an array of errors. Returns an empty array if
 * the schema is JSON-serializable.
 *
 * @ignore
 */
function getSchemaJsonSerializationErrors(schema) {
  // eslint-disable-next-line no-param-reassign
  schema = normalizeSchema(schema);
  const combination = schema.anyOf || schema.allOf;
  if (combination) {
    return combination.length > 0
      ? [].concat(...combination.map(getSchemaJsonSerializationErrors))
      : [makeError('Impossible type is not JSON-serializable')];
  }
  const { type } = schema;
  if (type && jsonSerializableSimpleTypes[type]) {
    // Is a JSON-serializable primitive or special type
    return [];
  }
  if (type === 'array') {
    const errors = getSchemaJsonSerializationErrors(schema.items);
    return errors.length ? [makeError('List items are not JSON-serializable', errors)] : [];
  }
  if (type === 'object') {
    const { properties, additionalProperties } = schema;
    if (!properties && !additionalProperties) {
      return [makeError('Object with unknown properties is not JSON-serializable')];
    }
    const errors = [];
    Object.keys(properties || {}).forEach((propertyName) => {
      const propertySchema = properties[propertyName];
      const propertyErrors = getSchemaJsonSerializationErrors(propertySchema);
      if (propertyErrors.length) {
        errors.push(makeError(`Object property ${stringify(propertyName)} is not JSON-serializable`, propertyErrors));
      }
    });
    const additionalErrors = additionalProperties
      ? getSchemaJsonSerializationErrors(additionalProperties) : [];
    if (additionalErrors.length) {
      errors.push(makeError('Object properties are not JSON-serializable', additionalErrors));
    }
    return errors;
  }
  if (type === 'schematicValue') {
    // Schematic value is JSON-serializable only if its meta-schema is JSON-serializable
    const { schema: metaSchema } = schema;
    const errors = getSchemaJsonSerializationErrors(metaSchema);
    if (errors.length) {
      return [makeError(`${upperFirst(stringifyType(type))} does not represent a JSON-serializable value`, errors)];
    }
    return [];
  }
  // A custom type
  return [makeError(`${upperFirst(stringifyType(type))} is not JSON-serializable`)];
}

/**
 * @ignore
 */
function isJsonCompatibleSchema(schema) {
  return !getSchemaJsonSerializationErrors(schema).length;
}

module.exports.getSchemaJsonSerializationErrors = getSchemaJsonSerializationErrors;
module.exports.isJsonCompatibleSchema = isJsonCompatibleSchema;
