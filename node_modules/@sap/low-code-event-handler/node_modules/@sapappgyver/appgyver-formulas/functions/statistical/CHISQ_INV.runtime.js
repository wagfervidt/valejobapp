/* eslint-disable no-bitwise */
const gammaLN = require('./GAMMALN.runtime');

const lowRegGamma = (a, x) => {
  const aln = gammaLN([a]);
  let ap = a;
  let sum = 1 / a;
  let del = sum;
  let b = x + 1 - a;
  let c = 1 / 1.0e-30;
  let d = 1 / b;
  let h = d;
  let i = 1;
  // calculate maximum number of itterations required for a
  const ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  let an;

  if (x < 0 || a <= 0) {
    return null;
  }
  if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      ap += 1;
      del *= (x / ap);
      sum += del;
    }
    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= (d * c);
  }
  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));
};

const gammapInv = (p, a) => {
  const a1 = a - 1;
  const EPS = 1e-8;
  const gln = gammaLN([a]);
  let x;
  let err;
  let t;
  let u;
  let pp;
  let lna1;
  let afac;
  let j = 0;

  if (p >= 1) {
    return Math.max(100, a + 100 * Math.sqrt(a));
  }
  if (p <= 0) {
    return 0;
  }
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) x = -x;
    x = Math.max(1e-3,
      a * ((1 - 1 / (9 * a) - x / (3 * Math.sqrt(a))) ** 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t) x = ((p / t) ** (1 / a));
    else x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for (; j < 12; j++) {
    if (x <= 0) return 0;
    err = lowRegGamma(a, x) - p;
    if (a > 1) t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1)));
    x -= t;
    if (x <= 0) x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x) break;
  }
  return x;
};

module.exports = ([prob, degrees]) => {
  if (!(typeof prob === 'number' && Number.isFinite(prob))) {
    return null;
  }
  if (!(typeof degrees === 'number' && Number.isFinite(degrees))) {
    return null;
  }
  if (prob < 0 || prob > 1) {
    return null;
  }
  const result = 2 * gammapInv(prob, 0.5 * degrees);
  return Number.isFinite(result) ? result : null;
};
