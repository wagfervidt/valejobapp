import { Schema } from '@sapappgyver/appgyver-schemas';
import { FunctionDefinition, FunctionParameterDefinition } from './functions/types';
import { ExecutableExpression, ExportedExpression } from './runtime';

export interface ExpressionError {
  /**
   * Error message
   */
  message: string;
  /**
   * Nested errors related to this error.
   */
  errors?: ExportedExpression[];
  /**
   * Start index of this error at the original formula string.
   */
  offset: number;
  /**
   * Length of the error as a number of characters in the original formula string.
   */
  length: number;
}

export interface ExpressionToken {
  /**
   * Parsed type of this token in the formula.
   */
  type: string;
  /**
   * The start index of this token in the original formula.
   */
  offset: number;
  /**
   * The length of this token as a number of characters in the original formula.
   */
  length: number;
  /**
   * The text of this token as it is in the original formula.
   */
  text: string;
}

export interface ExpressionStructure {
  /**
   * The type of this expression structure node.
   */
  type: string;
  /**
   * The original expression formula that was parsed.
   */
  formula: string;
   /**
   * JavaScript implementation of the formula.
   * Never use this directly!!!
   * Instead, always follow the correct runtime usage!
   */
  script: string;
  /**
   * List of "accessor paths" describing what information the expression needs
   * from the provided context object. You can use this information to optimize
   * your runtime.
   */
  dependencies: [string, ...string[]][];
  /**
   * List of function names used by the expression on runtime.
   * It may contain helper functions in addition to the ones written in formula.
   */
  functions: string[];
  /**
   * JavaScript for the **inverse evaluation**. Present if the formula supports inversion,
   * otherwise omitted. Never use this directly, but instead follow the inverse execution usage!
   */
  inverse?: string;
  /**
   * List similar to `dependencies`, describing what "paths" in the context would be updated by
   * an inverse evaluation. Present if the formula supports inversion **and if not equal
   * to `dependencies`**, otherwise omitted.
   */
  inverts?: [string, ...string[]][];
  /**
   * The start index of this structural node in the original formula.
   */
  offset: number;
  /**
   * The length of this structural node as number of characters in the original formula.
   */
  length: number;
  /**
   * List of syntactical errors in this expression structure.
   */
  syntaxErrors?: ExpressionError[];
  /**
   * The nested structural nodes of the expression.
   */
  children: ExpressionStructure[];
  /**
   * The parsed tokens this structural node consists of.
   */
  tokens: ExpressionToken[];
  /**
   * If this structural node is for a function parameter, this contains the
   * definition of that parameter.
   */
  parameter?: FunctionParameterDefinition;
  /**
   * If this structural node is for a function parameter, this contains the
   * index of that parameter.
   * @deprecated Use with care: this might not be available in the future!
   */
  index?: number;
  /**
   * If there is a text part in this structure, this property defines the tokens for it.
   * @deprecated Use with care: this might not be available in the future!
   */
  term?: { text: string, offset: number }[] | null;
  /**
   * In case the expression node structures represents a simple pointer (accessor sequence)
   * then this equals to that pointer path.
   * @deprecated Use with care: this might not be available in the future!
   */
  reference?: (string | number)[];
  /**
   * If this node represents a constant value, this would be it.
   */
  value?: unknown;
  /**
   * If this structural node is for a function call, this contains the
   * identifying name of the function.
   * @deprecated Use with care: this might not be available in the future!
   */
  name?: string;
  /**
   * If this structural node is for a function call, this contains the
   * function definition.
   * @deprecated Use with care: this might not be available in the future!
   */
  function?: FunctionDefinition;
}

export interface ExpressionAnalysis {
  /**
   * The return schema of the formula.
   */
  schema: Schema;
  /**
   * List of both semantic and syntactical errors in the formula.
   */
  errors: ExpressionError[];
}

export interface ExpressionInspection extends ExpressionAnalysis, ExpressionStructure {
  /**
   * The mapping of root variables and their schemas available for the formula
   * at the context of this expression structure.
   */
  contextSchema: Record<string, Schema>;
  /**
   * The nested structural analyzed nodes of the expression.
   * NOTE: Access this with care! Backward-incompatible changes are likely in the future!
   */
  children: ExpressionInspection[];
}

export type ExpressionRenames = { [name: string]: string | ExpressionRenames };

/**
 * Options for an analysis
 */
 export interface AnalysisOptions {
  /**
   * The number of milliseconds after which any formula execution, e.g. when
   * calculating example values, is interrupted, if it takes longer than the provided value.
   */
  executionTimeout?: number | null;
}

export interface ParsedExpression {
  /**
   * The original formula string.
   */
  readonly formula: string;
  /**
   * All the syntax errors in the formula.
   */
  readonly syntaxErrors: ExpressionError[];
  /**
   * The first syntax error occurred in the formula.
   * @deprecated
   */
  readonly syntaxError: ExpressionError | undefined;
  /**
   * The parsed structure of the expression.
   * NOTE: Access this with care! Backward-incompatible changes are likely in the future!
   */
  readonly structure: ExpressionStructure;
  /**
   * Analyzes the given formula for semantic/typing errors and resolves the
   * schema of the return value of the formula.
   *
   * @param contextSchema the mapping of root variables with their respective schemas
   * @param requiredSchema the expected return value schema of the formula
   */
  analyze(contextSchema: Record<string, Schema>, requiredSchema?: Schema | null, options?: AnalysisOptions): ExpressionAnalysis;
  /**
   * Analyzes the given formula for semantic/typing errors, resolves the
   * schema of the return value of the formula, and also includes the structural information
   *
   * @param contextSchema the mapping of root variables with their respective schemas
   * @param requiredSchema the expected return value schema of the formula
   */
  inspect(contextSchema: Record<string, Schema>, requiredSchema?: Schema | null, options?: AnalysisOptions): ExpressionInspection;
  /**
   * Exports the formula expression to JSON-serializable format, which can then be "imported"
   * either to the runtime using `prepareExecutable` or as this kind of `Expression` instance
   * by using `importExpression`.
   */
  export(options?: { inverse?: boolean }): ExportedExpression;
  /**
   * Convert the expression to an executable which can be evaluated.
   * @param context the default context provided to the expression
   */
  toExecutable(context?: Record<string, unknown>): ExecutableExpression;
  /**
   * Returns the original formula string.
   */
  toString(): string;
  /**
   * Refactor the given formula by renaming the given root variables or nested properties to another name.
   */
  rename(renames: ExpressionRenames): ParsedExpression;
}

/**
 * Parses the given formula expression string and returns an object possibly containing errors.
 * @param expression Formula expression string to parse
 */
export const parseExpression: (expression: string) => ParsedExpression;

/**
 * Parses a previously exported expression object.
 * This accepts a structure returned by `.export()`
 * @param expression exported expression object to parse
 */
 export const importExpression: (expression: ExportedExpression) => ParsedExpression;
