const gammaln = require('./GAMMALN.runtime');

const betacf = (x, a, b) => {
  const fpmin = 1e-30;
  const qab = a + b;
  const qap = a + 1;
  const qam = a - 1;
  let c = 1;
  let d = 1 - qab * x / qap;
  let m2;
  let aa;
  let del;
  let h;

  if (Math.abs(d) < fpmin) {
    d = fpmin;
  }

  d = 1 / d;
  h = d;

  for (let m = 1; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));

    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));

    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7) {
      break;
    }
  }
  return h;
};

const ibeta = (x, a, b) => {
  const bt = (x === 0 || x === 1)
    ? 0
    : Math.exp(gammaln([a + b]) - gammaln([a])
      - gammaln([b]) + a * Math.log(x) + b
      * Math.log(1 - x));
  if (x < (a + 1) / (a + b + 2)) {
    return bt * betacf(x, a, b) / a;
  }
  return 1 - bt * betacf(1 - x, b, a) / b;
};

const ibetainv = (p, a, b) => {
  const EPS = 1e-8;
  const a1 = a - 1;
  const b1 = b - 1;
  let x;
  if (p <= 0) return 0;
  if (p >= 1) return 1;
  if (a >= 1 && b >= 1) {
    const pp = (p < 0.5) ? p : 1 - p;
    const t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) x = -x;
    const al = (x * x - 3) / 6;
    const h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
    const w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1))
      * (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    const lna = Math.log(a / (a + b));
    const lnb = Math.log(b / (a + b));
    const t = Math.exp(a * lna) / a;
    const u = Math.exp(b * lnb) / b;
    const w = t + u;
    if (p < t / w) x = (a * w * p) ** (1 / a);
    else x = 1 - ((b * w * (1 - p)) ** (1 / b));
  }
  const afac = -gammaln([a]) - gammaln([b]) + gammaln([a + b]);
  // eslint-disable-next-line no-plusplus
  for (let j = 0; j < 10; j++) {
    if (x === 0 || x === 1) return x;
    const err = ibeta(x, a, b) - p;
    let t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    const u = err / t;
    t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x))));
    x -= t;
    if (x <= 0) x = 0.5 * (x + t);
    if (x >= 1) x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0) break;
  }
  return x;
};

module.exports = ([prob, degrees1, degrees2]) => {
  if (!(typeof prob === 'number' && Number.isFinite(prob))) {
    return null;
  }
  if (!(typeof degrees1 === 'number' && Number.isFinite(degrees1))) {
    return null;
  }
  if (!(typeof degrees2 === 'number' && Number.isFinite(degrees2))) {
    return null;
  }
  if (degrees1 < 1 || degrees2 < 1) {
    return null;
  }
  if (prob <= 0 || prob >= 1) {
    return null;
  }

  const result = degrees2 / (degrees1 * (1 / ibetainv(prob, degrees1 / 2, degrees2 / 2) - 1));
  return Number.isFinite(result) ? result : null;
};
