# Creating new expression functions

Please follow the following guidelines when creating new functions:

## Process

1. Start a new branch from `master` branch
2. Create **[function definition](#function-definition)** to a new file `src/functions/XXXXXXXX.js`.
   Here `XXXXXXXX` is the uppercase, unique name of the new function.
3. Create **[function runtime implementation](#function-runtime-implementation)** to a new file `src/functions/XXXXXXXX.runtime.js`
4. Create **function unit tests** to a new file `src/functions/XXXXXXXX.test.js`
5. Add your function implementation import/export to `src/functions/runtime.js`.
6. Add your function definition import/export to `src/functions/index.js`.
7. Once ready, create a [pull request](#pull-requests) in GitHub to the `master` branch

## General requirements

- **Write comprehensive tests for your function**! Take a look at the [existing functions](./src/functions/) for examples.
  You can run the tests once with the following command:

    npm test

  Or alternatively, to automatically re-run the tests when there are changes:

    npm start

- **Use ESLint**! Your code must follow the style rules defined in `.eslintrc`.
  If you have a particularly good reason to omit certain style rules, then use eslint-disable comments.
  (To make your life easier, use the auto-fix feature of your IDE)
  You can run the linter with the following command:

    npm run lint

- **Do not add new dependencies to package.json**. This is to keep the library lightweight.
  The only exception is MomentJS (`moment`), for date parsing/formatting purposes.
  If you feel that installing some new dependency is justfied, then discuss this with an AppGyver developer for approval.

## Function runtime implementation

The actual execution of the function must be written in its own module file that exports a function:

```javascript
module.exports = ([param1, param2]) => {
  // TODO: Implement here and return the result!
  return param1 + param2;
};
```

This function is called whenever the function is actually run.
It takes **one** parameter, which is an **array of function parameters**.

For example, when evaluating an expression `IF(appVars.myVariable > 5, "Yes", "No")`,
and the `appVars.myVariable > 5` evaluates to `true`, then the function `execute` will be called with:

```javascript
[true, "Yes", "No"]
```

The function must **return** the result value of the function.

Please always follow these principles when writing the implementation:

- **The function must be fully synchronous**! No asynchronous opererations (e.g. HTTP requests) are allowed!
- **The function must never mutate any parameters they receive**!
  If they take e.g. an object or an array as a parameter, those must remain unaltered by the function.
  The function may still return parameter values as-is, or wrapped in object/arrays.
  However, if they would like to "make changes" to a parameter, they must return an altered _copy_ of the original value.
- **The function must never have side-effects**! The function may only have an execution-time internal state, and never alter anything else.
- **The function must be deterministic**! This means that whenever called with the same parameters, it must return equal return values.
  The only exceptions are the few randomizing functions (`RANDOM`, `SHUFFLE`) which are not deterministic.
- The function can assume that the parameters are of the types that it expects (as defined in its definition).
  For example, if the function expects an array parameter, it can just assume the value has the `map` method like any Array. However...
- The function must **NOT** throw an error if the parameter is `null` or `undefined`.
  The function should somehow handle these values. The simples solution is to pass through the nully value without doing anything else.
  For example, if the function expects an array parameter, it still needs to check if the value is nully (`param == null`) and if so,
  then just return the nully value as-is.

Note that if the function is used without some optional parameters, those parameter values are automatically set to their default values, and the implementation function is called with default values applied.


## Function definition

A function is defined as an object exported from its own file:

```javascript
const execute = require('./XXXXXXXXXX.runtime.js');

module.exports = {
  // The unique name of the function, only containing uppercase letters, underscores and digits
  name: 'XXXXXXXXXX',
  // A short, human-readable name of the function
  title: 'Lorem ipsum',
  // A longer description what the function does and how it works. May contain Markdown, see below.
  description: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit',
  // An array containing a schema for each parameter the function takes.
  parameters: [{
    // A short human-readable name for this parameter
    title: 'Value',
    // A longer description for the parameter. May contain Markdown, see below.
    description: 'Value for doing things',
    // Other JSONSchema keywords, see below!!!
    // ...
  }],
  // Function that returns the type for the function's return value,
  // as well as any additional issues with the function parameters, see below.
  analyze: (parameters, offset, parameterErrors) => {
    /* analyze and return schema and errors */
    return {
      // Required: schema of the return value
      schema: { /* valid schema */ },
      // Optional: array of additional errors if the parameters are incorrect
      errors: [{
        // Required: An error message what is wrong
        message: 'Parameters are incompatible',
        // Required: The index where the error occured. You can use the `offset` parameter.
        offset: offset,
        // Required: Array of sub-errors for this particular error, or empty array.
        errors: [],
      }],
    };
  },
  // The actual runtime implementation of the function.
  // Must be imported from the corresponding .runtime.js file
  execute,
};
```

The parameters, as well as the return value of the `analyze` method must be [our supported subset of JSONSchema][schema].

### Optional parameters

You can make some function parameters optional by providing a `default` property in the function parameter definition.
You still must apply the default value in the function implementation: the default values are **not** automatically applied to the parameters passed to the implementation function.

Note that only the last parameters of the function can be optional; after an optional parameter, there must not be required parameters.

### Function analysis method

The correct usage of the function is validated by two properties in the definition:

- `parameters`: this must be an array of [schema objects][schema] that define the required type for each parameter, in the correct order.
- `analyze`: a function that is called to determine the return value of the function, as well as to perform any _additional_ validation for the parameters.

The `analyze` called **after the parameter types have been validated**.
The parameters will automatically be validated against the schema defined by `parameters`.

The function is called with the following parameters:

- `parameters`: an array containing information object for each parameter being passed to the function in an expression.
  You may use only these parameters of these objects (and must not alter them):
  - `schema`: the [schema][schema] (type) of the parameter
  - `offset`: the position of the starting character of this parameter in the expression string
- `offset`: the position of the starting character of the function call in the expression string
- `parameterErrors`: array of errors with the parameters if they are incorrectly typed.
  If empty, then you can assume that the parameters match the type defined by `parameters`.

The function must return an **object** with the following properties:

- `schema` (**required**): the [schema][schema] (type) of the **return value of the function**.
  The return value may depend on the parameters (like e.g. in [PLUCK](./functions/PLUCK.js) function)
- `errors` (optional): any errors **in addition to the parameter type errors**.
  This can be used e.g. in cases where correct parameter types depend on each other.
  If included, this must be an array of objects with the following properties:
  - `message`: human readable message what is wrong with the function usage
  - `offset`: the index where this error occurs. Please use the parameters provided to `analyze`
  - `messages`: any sub-errors to this specific error. In most cases, an empty array is enough.


## GIT usage

- Use **[Angular commit message conventions](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)** for your GIT commit messages!
- Use this kind of commit message when adding a new function:

    feat (functions) add XXXXXXXX

- Always use `(functions)` scope when working with functions.
- Each commit should be related to **only one function, if possible**.
- Always mention the name of the function (`XXXXXXXX`) in your commit message.
- Use subject `fix`, `refactor`, etc. when fixing, adding more tests, or otherwise improving an function.


## Pull requests

- Create your pull request when the implementation is ready and it is tested well.
- One pull request should introduce only **one function, or just a few closely related functions**!
  This makes them easier to review, and certain functions can be merged while others are being improved, etc.
  If the functions are very closely related (e.g. `UPPERCASE` and `LOWERCASE`) then they can be bundled to one pull request.
- Pull request title should be in format: `Add function XXXXXXXX`, or `Add functions XXXXXXXX and YYYYYYYYY`
- Pull request description should shortly describe what the function does.
  It should also have links to the original specs, task tickets, etc. to make the reviewing easier.
- Notify the person whoever gave you the task once your pull request is ready to be reviewed.
- If the automated tests fail for your pull request, fix them first before requesting a review.
- If you are having questions or issues, contact an AppGyver developer.


[schema]: https://github.tools.sap/AppGyver/appgyver-schemas/blob/main/docs/SCHEMA.md
