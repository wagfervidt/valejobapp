const logger = require('../../../logger');
const path = require('path');
const fs = require('fs-extra');
const loaderUtils = require('loader-utils');
const schemaUtils = require('schema-utils');
const _ = require('lodash');

const schema = {
  type: 'object',
  properties: {
  fragmentsPath: {
    type: 'string',
  },
  },
};

function hasFragment(content) {
  const regexp = /\"([\/_a-zA-Z0-9\.]*\.fragment)\"/g;
  return regexp.test(content);
}
function hasComplexFragment(content) {
  // has overriding or parameter
  const regexp = /\"_Type\":\s*\"Fragment\"/g;
  return regexp.test(content);
}
function resolveFragment(dir, content) {
  if (hasComplexFragment(content)) {
    const obj = JSON.parse(content);
    resolveComplexFragment(dir, obj);
    content = JSON.stringify(obj);
  }
  const regexp = /\"([\/_a-zA-Z0-9\.]*\.fragment)\"/g;
  const output = content.replace(regexp, function(i, match) {
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('resolving fragment ') + logger.getInfoMore(match));
    const sPath = path.join(dir, match);
    let fragmentContent = fs.readFileSync(sPath, 'utf8');
    if (hasFragment(fragmentContent)) {
      return resolveFragment(dir, fragmentContent);
    }
    return fragmentContent;
  });
  return output;
}
function overrideNamedProperties(obj, properties) {
  if (Object.keys(properties).length > 0) {
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (value && typeof value === "object") {
          if (value.hasOwnProperty("_Name")) {
            const name = value["_Name"];
            for (const n in properties) {
              if (properties.hasOwnProperty(n) && n === name) {
                obj[key] = _.merge(value, properties[n]);
                delete properties[n];
              }
            }
          }
          overrideNamedProperties(value, properties);
        }
      }
    }
  }
}
function removeNullProperties(obj) {
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const value = obj[key];
      if (value === null) {
        delete obj[key];
      } else if (value && typeof value === "object") {
        removeNullProperties(value);
      }
    }
  }
  return obj;
};
function resolveComplexFragment(dir, obj) {
  for (let property in obj) {
    if (obj.hasOwnProperty(property)) {
      const value = obj[property];
      if (value && typeof value === "object") {
        if (value.hasOwnProperty("_Type") && value["_Type"] === "Fragment") {
          const fragmentPath = value.Fragment;
          console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('resolving complex fragment ') + logger.getInfoMore(fragmentPath));
          const sPath = path.join(dir, fragmentPath);
          let fragmentContent = fs.readFileSync(sPath, 'utf8');
          if (hasFragment(fragmentContent)) {
            fragmentContent = resolveFragment(dir, fragmentContent);
          }
          const properties = value.Properties;
          const namedProperties = {};
          const indexedProperties = {};
          for (const key in properties) {
    		    if (properties.hasOwnProperty(key)) {
              if (key.startsWith("#Index:")) {
              	indexedProperties[key] = properties[key];
                delete properties[key];
              } else if (key.startsWith("#Name:")) {
                const name = key.substring(6);
              	namedProperties[name] = properties[key];
                delete properties[key];
              }
            }
          }
          // 1. merge new properties
          const fragmentObj = _.merge(JSON.parse(fragmentContent), properties);
          // 2. override properties by name
          overrideNamedProperties(fragmentObj, namedProperties);
          const names = Object.keys(namedProperties);
          if (names.length > 0) {
            // still have unfound properties
            throw new Error('Cannot find properties: ' + JSON.stringify(names));
          }
          // 3. override propertier by index
          // 4. remove all null properties
          obj[property] = removeNullProperties(fragmentObj);
        } else if (hasComplexFragment(JSON.stringify(value))) {
          resolveComplexFragment(dir, value);
        }
      }
    }
  }
}
module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  schemaUtils.validate(schema, options, {
    name: 'Fragments Loader',
    baseDataPath: 'options',
  });
  const fragmentsPath = options.fragmentsPath;
  if (hasFragment(source)) {
    return resolveFragment(fragmentsPath, source);
  }
  return source;
}
