const { formats } = require('./formatting');

/**
 * Returns a "blank" or "empty" value that matches the given schema:
 *
 * - for strings this is an empty string
 * - for booleans this is false
 * - for numbers this is 0
 * - for arrays this is an empty array
 * - for objects this is an object with blank values for all properties
 *
 * @param {object} schema schema to which the value must match
 */
function getBlankValueForSchema(schema) {
  const {
    anyOf, allOf, type, enum: options,
  } = schema || {};
  // If schema has enum (only allows certain values), then pick the first one from them
  if (options && options.length) {
    return options[0];
  }
  // If schema is an union type then get a blank value for the first allowed value
  if (anyOf) {
    return getBlankValueForSchema(anyOf[0]);
  }
  // If schema is an intersection type, then try to find a value that matches all of them
  if (allOf) {
    return allOf.length ? allOf.reduce(getCommonBlankValueForSchemas) : null;
  }
  // For null type return null
  if (type === 'null') {
    return null;
  }
  // For undefined type return undefined
  if (type === 'undefined') {
    return undefined;
  }
  // If schema is an intersection type then get a blank value for the
  if (type === 'string') {
    // Is formatted?
    const { format } = schema;
    if (!format || format === '*') {
      // Empty string for an unformatted string
      return '';
    }
    // Return empty string if that is assignable to a known format, otherwise null
    return formats[format] && formats[format].matches('') ? '' : null;
  }
  if (type === 'number') {
    return 0;
  }
  if (type === 'boolean') {
    return false;
  }
  if (type === 'object') {
    const { properties } = schema;
    if (!properties) {
      // Schema does not specify specific property names
      return {};
    }
    const result = {};
    Object.keys(properties).forEach((key) => {
      result[key] = getBlankValueForSchema(properties[key]);
    });
    return result;
  }
  if (type === 'array') {
    return [];
  }
  if (type === 'schema') {
    return schema.schema || {};
  }
  return null;
}

function getCommonBlankValueForSchemas(schema1, schema2) {
  const value1 = getBlankValueForSchema(schema1);
  const value2 = getBlankValueForSchema(schema2);
  return getCommonValue(value1, value2);
}

function getCommonValue(value1, value2) {
  if (value1 == null) {
    return value2;
  }
  if (value2 == null) {
    return value1;
  }
  if (typeof value1 !== typeof value2) {
    return null;
  }
  if (Array.isArray(value1)) {
    return value1;
  }
  if (typeof value1 === 'object') {
    const result = {};
    Object.keys({ ...value1, ...value2 }).forEach((propertyName) => {
      result[propertyName] = getCommonValue(value1[propertyName], value2[propertyName]);
    });
    return result;
  }
  return value1;
}

module.exports.getBlankValueForSchema = getBlankValueForSchema;
