function requireFromApp(module) {
  return require('../../../src/SnowblindClientApplication/node_modules/' + module);
}
const expect = requireFromApp('chai').expect;
const proxyquire = requireFromApp('proxyquire').noCallThru();
const sinon = requireFromApp('sinon');
const assert = requireFromApp('chai').assert;
const sandbox = sinon.createSandbox();
const copySyncStub = sandbox.stub();
const execSyncStub = sandbox.stub();
const extractAllToStub = sandbox.stub();
const zipPath = sandbox.stub();
let createdFileContent;
let webpackParams;
const createFileStub = (path, content, callback) => {
  createdFileContent = content;
  createdFilePath = path;
  callback();
}
function AdmZip(path) {
  zipPath(path);
  return {
    extractAllTo: extractAllToStub,
  };
}
let files = [];
let filesThatExist = [];
// app with bad json
let mdkBundlerBadJSONApp = 'MdkBundlerBadJSONApp';
// default component application name
let mdkBundlerComponentApp = 'MdkBundlerComponentApp';
//
let mdkBundlerRecursiveAppLevel1 = 'MdkBundlerRecursiveAppLevel1';
//
let mdkBundlerRecursiveAppLevel2 = 'MdkBundlerRecursiveAppLevel2';
//
let mdkBundlerRecursiveAppLevel3 = 'MdkBundlerRecursiveAppLevel3';
// bundler base app - everything starts here
let mdkBundlerBaseApp = 'MdkBundlerBaseApp';
// app with no components
let mdkBundlerNoComponentApp = 'MdkBundlerNoComponentApp';
// default component application name
let mdkBundlerComponentProject = 'MdkBundlerComponentProject';
// default component application name
let mdkBundlerRecursiveProjectLevel2 = 'MdkBundlerRecursiveLevel2Project';
// default component application name
let mdkBundlerRecursiveProjectLevel3 = 'MdkBundlerRecursiveLevel3Project';
// bundler base app for error testing
let mdkBundlerErrorApp = 'MdkBundlerErrorApp';
// bundler base app for failure testing
let mdkBundlerFailureApp = 'MdkBundlerFailureApp';
// default export path
let defaultEditorExportPath = 'MdkEditorExportPath';
// cim content
let baseAppComponent = {
  DisplayName: "MDK Bundler Test Component",
  ApplicationName: mdkBundlerComponentApp,
  ComponentVersion: "1.0",
  ProjectName: mdkBundlerComponentProject,
  IntegrationPoints: [{
    Source: `/${mdkBundlerComponentApp}/Actions/Common/GenericMessage.action`,
    Target: `/${mdkBundlerBaseApp}/Actions/Navigation/NavToWorkOrderList.action`
  }]
};

let recursiveComponentLevel1 = {
  DisplayName: "MDK Bundler Test Component",
  ApplicationName: mdkBundlerRecursiveAppLevel2,
  ComponentVersion: "1.0",
  ProjectName: mdkBundlerRecursiveProjectLevel2,
  IntegrationPoints: [{
    Source: `/${mdkBundlerRecursiveAppLevel2}/Actions/Common/GenericMessage.action`,
    Target: `/${mdkBundlerRecursiveAppLevel1}/Actions/Navigation/NavToWorkOrderList.action`
  }]
};

let recursiveComponentLevel2 = {
  DisplayName: "MDK Bundler Test Component",
  ApplicationName: mdkBundlerRecursiveAppLevel3,
  ComponentVersion: "1.0",
  ProjectName: mdkBundlerRecursiveProjectLevel3,
  IntegrationPoints: [{
    Source: `/${mdkBundlerRecursiveAppLevel3}/Actions/Common/GenericMessage.action`,
    Target: `/${mdkBundlerRecursiveAppLevel2}/Actions/Navigation/NavToWorkOrderList.action`
  }]
};

// spies
let execSpy = sinon.spy();
let failSpy = sinon.spy();

// impls

// for testing _appNameFromAppFile
let readSyncJsonImpl2 = sinon.stub();
readSyncJsonImpl2.withArgs(`${mdkBundlerBaseApp}/Application.app`).returns({
  _Name: mdkBundlerBaseApp
});
readSyncJsonImpl2.withArgs(`${mdkBundlerComponentProject}/${mdkBundlerComponentApp}/Application.app`).returns({
  _Name: mdkBundlerComponentApp
});
readSyncJsonImpl2.withArgs(`${mdkBundlerNoComponentApp}/Application.app`).returns({
  _Name: mdkBundlerNoComponentApp
});
readSyncJsonImpl2.withArgs(`${mdkBundlerRecursiveAppLevel1}/Application.app`).returns({
  _Name: mdkBundlerRecursiveAppLevel1
});
readSyncJsonImpl2.withArgs(`${mdkBundlerRecursiveProjectLevel2}/${mdkBundlerRecursiveAppLevel2}/Application.app`).returns({
  _Name: mdkBundlerRecursiveAppLevel2
});
readSyncJsonImpl2.withArgs(`${mdkBundlerRecursiveProjectLevel3}/${mdkBundlerRecursiveAppLevel3}/Application.app`).returns({
  _Name: mdkBundlerRecursiveAppLevel3
});
readSyncJsonImpl2.withArgs(`${mdkBundlerBadJSONApp}/Application.app`).returns({
});

let fsextraImpl = {
  existsSync: sPath => {
    return filesThatExist.includes(sPath);
  },
  mkdirSync: sPath => {
  },
  copySync: copySyncStub,
  readJsonSync: readSyncJsonImpl2,
};

// for testing _appNameFromAppFile
let isFileImpl = (sPath) => {
  // every app but the failure app is valid
  return !sPath.includes(mdkBundlerFailureApp);
};

let nodedirImpl = {
  // used by _generateBundleFiles
  files: (sPath, callback) => {
    callback(null, files);
  },
  // this method is used for reading cim files
  readFiles: (sSourcePath, filter, contentCallback, filesCallback) => {
    if (sSourcePath === `${mdkBundlerBaseApp}`) {
      contentCallback(null, JSON.stringify(baseAppComponent), () => {
        filesCallback(null, [`${mdkBundlerComponentApp}.cim`]);
      });
    } else if (sSourcePath === `${mdkBundlerRecursiveAppLevel1}`) {
      contentCallback(null, JSON.stringify(recursiveComponentLevel1), () => {
        filesCallback(null, [`${mdkBundlerRecursiveAppLevel1}.cim`]);
      });
    } else if (sSourcePath === `${mdkBundlerRecursiveProjectLevel2}/${mdkBundlerRecursiveAppLevel2}`) {
      contentCallback(null, JSON.stringify(recursiveComponentLevel2), () => {
        filesCallback(null, [`${mdkBundlerRecursiveAppLevel2}.cim`]);
      });
    } else {
      let error = `${sSourcePath} contains no components`;
      contentCallback(error, '', () => {
        filesCallback(error, []);
      });
    }
  }
};

let pathImpl = {
  extname: (sPath) => {
    let segments = sPath.split('.');
    return `.${segments[segments.length - 1]}`;
  },
  join: function () {
    return Array.from(arguments).join('/');
  },
  sep: '/',
};

let processImpl = {
  cwd: () => 'bundlerSpec',
};

let toolutilsImpl = {
  fail: failSpy,
  exec: execSpy,
  isDirectory: (sPath) => {
    if (sPath.includes(`${mdkBundlerComponentProject}`)) {
      return true;
    } else if (sPath.includes(`${mdkBundlerRecursiveProjectLevel2}`)) {
      return true;
    } else if (sPath.includes(`${mdkBundlerRecursiveProjectLevel3}`)) {
      return true;
    }

    return false;
  },
  isFile: isFileImpl,
  showError: () => { },
};

let webpackImpl = (params) => {
  return {
    run: callback => {
      const status = {
        compilation: {
          errors: [],
        },
      };
      webpackParams = params;
      callback(null, status);
    },
  };
};

const Bundler = proxyquire('../bundler', {
  'child_process': {
    execSync: execSyncStub,
  },
  'copy': {},
  'create-file': createFileStub,
  'delete': {},
  'node-dir': nodedirImpl,
  'fs-extra': fsextraImpl,
  'line-reader': {},
  'mv': {},
  'path': pathImpl,
  'process': processImpl,
  '../../tool-utils': toolutilsImpl,
  'write': {},
  'webpack': webpackImpl,
  'adm-zip': AdmZip,
  'shelljs': null
}).Bundler

// interface to args
let args;

const argsStub = {
  editorExport: () => { return args.editorExport; },
  applicationName: () => { return args.applicationName; },
  buildOutputPath: () => { return args.buildOutputPath; },
  bundleName: () => { return args.bundleName; },
  libraryTarget: () => { return 'umd' },
  nativeScriptProjectPath: () => { return args.nativeScriptProjectPath; },
  projectIndexFile: () => { return args.projectIndexFile; },
  mdkBaseApplicationPath: () => { return args.mdkBaseApplicationPath; },
  externals: () => { return args.externals || []; },
  shouldCreateBundle: () => { return args.shouldCreateBundle; },
  devtool: () => { return args.devtool || false; }
};

describe('Bundler Test Suite', () => {
  beforeEach(() => {
    sandbox.reset();
    zipPath.reset();
    createdFileContent = null;
    files = [];
    filesThatExist = [];
    args = {};
    webpackParams = undefined;
    execSpy.resetHistory();
    failSpy.resetHistory();
  });

  describe('bundler non-arg property tests', () => {
    it('should return export application path', () => {
      let bundler = new Bundler(argsStub);
      expect(bundler.exportedApplicationPath).to.eql('bundlerSpec/exported-application');
    });

    it('should return upload bundle contents path', () => {
      let bundler = new Bundler(argsStub);
      expect(bundler.uploadBundleContents).to.eql('bundlerSpec/uploadBundleContents');
    });

    it('should return full build output path', () => {
      let bundler = new Bundler(argsStub);
      expect(bundler.buildOutputPath).to.eql('bundlerSpec/build.definitions');
    });
  });

  describe('bundler argument based tests', () => {
    it('should return export path when buiding editor export', () => {
      args = {
        buildOutputPath: '',
        editorExport: defaultEditorExportPath,
      };

      let bundler = new Bundler(argsStub);
      expect(bundler.clientDefinitionsPath).to.eql('bundlerSpec/exported-application');
    });

    it('should return seam project path when NOT buiding editor export', () => {
      args = {
        buildOutputPath: '',
        mdkBaseApplicationPath: `${mdkBundlerBaseApp}`,
      };

      let bundler = new Bundler(argsStub);
      expect(bundler.clientDefinitionsPath).to.eql(args.mdkBaseApplicationPath);
    });
  });

  describe('create-bundle option', () => {
    // See requirements in SNOWBLIND-3758
    it('creates a zip with bundle.js and .che directory if .project.json is in .che', () => {
      const projectPath = './projectPath';
      args = {
        mdkBaseApplicationPath: projectPath,
      };
      let bundler = new Bundler(argsStub);
      filesThatExist.push('bundlerSpec/bundle.js');
      filesThatExist.push(projectPath + '/.che/project.json');
      bundler.createUploadBundle();
      expect(copySyncStub.withArgs('bundlerSpec/bundle.js', 'bundlerSpec/uploadBundleContents/bundle.js').calledOnce).to.be.true;
      expect(copySyncStub.withArgs(projectPath + '/.che', 'bundlerSpec/uploadBundleContents/.che').calledOnce).to.be.true;
      expect(copySyncStub.withArgs(projectPath + '/.project.json', 'bundlerSpec/uploadBundleContents/.project.json').calledOnce).to.be.false;
      expect(execSyncStub.withArgs('cd bundlerSpec/uploadBundleContents && zip -r ../uploadBundle.zip .').calledOnce).to.be.true;
    });

    it('creates a zip with bundle.js and .project.json if .project.json is in root directory but not in .che', () => {
      const projectPath = './projectPath';
      args = {
        mdkBaseApplicationPath: projectPath,
      };
      let bundler = new Bundler(argsStub);
      filesThatExist.push('bundlerSpec/bundle.js');
      filesThatExist.push(projectPath + '/.project.json');
      bundler.createUploadBundle();
      expect(copySyncStub.withArgs('bundlerSpec/bundle.js', 'bundlerSpec/uploadBundleContents/bundle.js').calledOnce).to.be.true;
      expect(copySyncStub.withArgs(projectPath + '/.che', 'bundlerSpec/uploadBundleContents/.che').calledOnce).to.be.false;
      expect(copySyncStub.withArgs(projectPath + '/.project.json', 'bundlerSpec/uploadBundleContents/.project.json').calledOnce).to.be.true;
      expect(execSyncStub.withArgs('cd bundlerSpec/uploadBundleContents && zip -r ../uploadBundle.zip .').calledOnce).to.be.true;
    });

    it('throws if .project.json not found in root or .che directory', () => {
      const projectPath = './projectPath';
      args = {
        mdkBaseApplicationPath: projectPath,
      };
      let bundler = new Bundler(argsStub);
      filesThatExist.push('bundlerSpec/bundle.js');
      expect(() => {
        bundler.createUploadBundle();
      }).to.throw();
    });

    it('throws if bundle.js not found', () => {
      const projectPath = './projectPath';
      args = {
        mdkBaseApplicationPath: projectPath,
      };
      let bundler = new Bundler(argsStub);
      filesThatExist.push(projectPath + '/.che/.project.json');
      expect(() => {
        bundler.createUploadBundle();
      }).to.throw();
    });
  });

  describe('bundler private methods', () => {

    describe('_appNameFromAppFile tests', () => {
      it('should fail if file is not found', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: mdkBundlerFailureApp,
        };

        let bundler = new Bundler(argsStub);
        bundler._appNameFromAppFile(bundler.clientDefinitionsPath);
        sinon.assert.calledOnce(failSpy);
      });

      it('should fail if invalid json is found', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerBadJSONApp}`,
        };

        let bundler = new Bundler(argsStub);
        bundler._appNameFromAppFile(bundler.clientDefinitionsPath);
        sinon.assert.calledOnce(failSpy);
      });

      it('should succeed', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerBaseApp}`,
        };
  
        let bundler = new Bundler(argsStub);
        expect(bundler._appNameFromAppFile(bundler.clientDefinitionsPath)).to.eql(mdkBundlerBaseApp);
      });
    });

    describe('assemble tests', () => {

      it('should assemble base application', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerNoComponentApp}`,
        };
  
        let bundler = new Bundler(argsStub);
        return bundler._assemble().then(() => {
          sinon.assert.calledThrice(execSpy);
          sinon.assert.calledWith(execSpy, `mkdir -p "${bundler.buildOutputPath}"`);
          sinon.assert.calledWith(execSpy, `cp -r "${mdkBundlerNoComponentApp}" "bundlerSpec/build.definitions/${mdkBundlerNoComponentApp}"`);
        });
      });
      
      it('should assemble base application and components', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerBaseApp}`,
        };
  
        let bundler = new Bundler(argsStub);
        filesThatExist.push(`${mdkBundlerComponentProject}`);
        filesThatExist.push(`${mdkBundlerComponentProject}/${mdkBundlerComponentApp}`);
        filesThatExist.push(`${mdkBundlerComponentProject}/${mdkBundlerComponentApp}/Application.app`);
        return bundler._assemble().then(() => {
          sinon.assert.callCount(execSpy, 4);
          sinon.assert.calledWith(execSpy, `mkdir -p "${bundler.buildOutputPath}"`);
          sinon.assert.calledWith(execSpy, `cp -r "${mdkBundlerBaseApp}" "bundlerSpec/build.definitions/${mdkBundlerBaseApp}"`);
          sinon.assert.calledWith(execSpy, `cp -r "${mdkBundlerComponentProject}/${mdkBundlerComponentApp}" "bundlerSpec/build.definitions/${mdkBundlerComponentApp}"`); 
        });
      });

      it('should assemble base application and components - recursive', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerRecursiveAppLevel1}`,
        };
  
        let bundler = new Bundler(argsStub);
        filesThatExist.push(`${mdkBundlerRecursiveProjectLevel2}`);
        filesThatExist.push(`${mdkBundlerRecursiveProjectLevel2}/${mdkBundlerRecursiveAppLevel2}`);
        filesThatExist.push(`${mdkBundlerRecursiveProjectLevel2}/${mdkBundlerRecursiveAppLevel2}/Application.app`);
        filesThatExist.push(`${mdkBundlerRecursiveProjectLevel3}`);
        filesThatExist.push(`${mdkBundlerRecursiveProjectLevel3}/${mdkBundlerRecursiveAppLevel3}`);
        filesThatExist.push(`${mdkBundlerRecursiveProjectLevel3}/${mdkBundlerRecursiveAppLevel3}/Application.app`);
        return bundler._assemble().then(() => {
          sinon.assert.callCount(execSpy, 5);
          sinon.assert.calledWith(execSpy, `mkdir -p "${bundler.buildOutputPath}"`);
          sinon.assert.calledWith(execSpy, `cp -r "${mdkBundlerRecursiveAppLevel1}" "bundlerSpec/build.definitions/${mdkBundlerRecursiveAppLevel1}"`);
          sinon.assert.calledWith(execSpy, `cp -r "${mdkBundlerRecursiveProjectLevel2}/${mdkBundlerRecursiveAppLevel2}" "bundlerSpec/build.definitions/${mdkBundlerRecursiveAppLevel2}"`); 
          sinon.assert.calledWith(execSpy, `cp -r "${mdkBundlerRecursiveProjectLevel3}/${mdkBundlerRecursiveAppLevel3}" "bundlerSpec/build.definitions/${mdkBundlerRecursiveAppLevel3}"`);
        });
      });
    });

    describe('_buildAppIndexContent tests', () => {

      it('should fail if duplicate names detected', () => {
        args = {
          projectIndexFile: 'application-index.js',
        };

        let bundler = new Bundler(argsStub);

        const aBundleFiles = [
          'build.definitions/Application.app',
          'build.definitions/MDKDevApp/Globals/Center.global',
          'build.definitions/MDKDevApp/Globals/Center.global'
        ];

        expect(() => {
          bundler._buildAppIndexContent(aBundleFiles);
        }).to.throw(Error, `Create bundle failure - duplicate names detected: mdkdevapp_globals_center_global`);
      });

      it('should create correct app index content', () => {
        args = {
          projectIndexFile: 'application-index.js',
        };

        let bundler = new Bundler(argsStub);

        const aBundleFiles = [
          'build.definitions/Application.app',
          'build.definitions/MDKDevApp/Globals/Center.global'
        ];

        return bundler._buildAppIndexContent(aBundleFiles).then((sIndexFileContent) => {
          expect(sIndexFileContent.indexOf(`application_app : application_app,`)).to.not.eql(-1);
          expect(sIndexFileContent.indexOf(`mdkdevapp_globals_center_global : mdkdevapp_globals_center_global`)).to.not.eql(-1);
        });
      });
    });

    describe('bundle file filter tests', () => {

      it('should filter DS_Store files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('.DS_Store')).to.be.false;
      });

      it('should filter README.md files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('README.md')).to.be.false;
      });

      it('should filter neo-app.json files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('neo-app.json')).to.be.false;
      });

      it('should filter unit test files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('test.spec.js')).to.be.false;
      });

      it('should filter cim files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('test.cim')).to.be.false;
      });

      it('should filter blockly rule files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('test.rule')).to.be.false;
      });

      it('should filter non-root Applicatin.app files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('/ComponentApplication/Application.app')).to.be.false;
      });

      it('should filter xml files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('test.xml')).to.be.false;
      });

      it('should filter SMF files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('test.SMF')).to.be.false;
      });

      it('should filter hidden files', () => {
        let bundler = new Bundler(argsStub);
        expect(bundler._isValidBundleFile('/ComponentApplication/.git/Application.app')).to.be.false;
      });
      
      it('should create filtered bundle files', () => {

        files = [
          'build.definitions/Application.app',
          'build.definitions/version.mdkbundlerversion',
          'build.definitions/MDKDevApp/.DS_Store',
          'build.definitions/MDKDevApp/.gitignore',
          'build.definitions/MDKDevApp/MDKOnlineApplication.cim',
          'build.definitions/MDKDevApp/README.md',
          'build.definitions/MDKDevApp/.che/project.json',
          'build.definitions/MDKDevApp/Globals/Center.global',
          'build.definitions/MDKDevApp/Globals/CenterLowercase.global',
          'build.definitions/MDKDevApp/Globals/CheckRequiredFields.global',
          'build.definitions/MDKDevApp/Globals/SecondTest.global',
          'build.definitions/MDKDevApp/Globals/SeeMore.global',
          'build.definitions/MDKDevApp/Globals/Test.global',
          'build.definitions/MDKDevApp/Globals/ThirdTest.global',
          'build.definitions/MDKDevApp/Globals/durationUnit.global',
          'build.definitions/MDKDevApp/Globals/durationValue.global',
          'build.definitions/MDKDevApp/Images/action.png',
          'build.definitions/MDKDevApp/Images/add-edit.png',
        ]
        // args not neeeded
        let bundler = new Bundler(argsStub);
        return bundler._generateBundleFiles().then((aBundleFiles) => {
          const filteredBundleFiles = [ 'build.definitions/Application.app',
          'build.definitions/version.mdkbundlerversion',
          'build.definitions/MDKDevApp/Globals/Center.global',
          'build.definitions/MDKDevApp/Globals/CenterLowercase.global',
          'build.definitions/MDKDevApp/Globals/CheckRequiredFields.global',
          'build.definitions/MDKDevApp/Globals/SecondTest.global',
          'build.definitions/MDKDevApp/Globals/SeeMore.global',
          'build.definitions/MDKDevApp/Globals/Test.global',
          'build.definitions/MDKDevApp/Globals/ThirdTest.global',
          'build.definitions/MDKDevApp/Globals/durationUnit.global',
          'build.definitions/MDKDevApp/Globals/durationValue.global',
          'build.definitions/MDKDevApp/Images/action.png',
          'build.definitions/MDKDevApp/Images/add-edit.png' ];
          expect(aBundleFiles).to.eql(filteredBundleFiles);
        });
      });
    });

    describe('reading component integration files', () => {
      it('should return read application cim files', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerBaseApp}`,
        };
  
        let bundler = new Bundler(argsStub);
        return bundler._readComponentIntegrationFiles(bundler.clientDefinitionsPath).then((aComponents) => {
          expect(aComponents.length).to.eql(1);
          expect(aComponents[0]).to.deep.eql(baseAppComponent);
        });
      });

      it('should return empty component array when read error occurs', () => {
        args = {
          buildOutputPath: '',
          mdkBaseApplicationPath: `${mdkBundlerErrorApp}`,
        };
  
        let bundler = new Bundler(argsStub);
        return bundler._readComponentIntegrationFiles(bundler.clientDefinitionsPath).then((aComponents) => {
          expect(aComponents.length).to.eql(0);
        });
      });
    });

    describe('unzip editor export tests', () => {
      it('unzips editor export file if specified', () => {
        args = {
          buildOutputPath: '',
          editorExport: defaultEditorExportPath,
          mdkBaseApplicationPath: mdkBundlerBaseApp,
        };
  
        let bundler = new Bundler(argsStub);
        bundler._unzipEditorExport();
        sinon.assert.calledWith(zipPath, defaultEditorExportPath);
        sinon.assert.calledOnce(extractAllToStub);
      });
    });
  });
});