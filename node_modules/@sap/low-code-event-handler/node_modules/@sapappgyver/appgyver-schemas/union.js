const { isFormatCompatible } = require('./formatting');
const { isJsonCompatibleSchema } = require('./json');
const { pickAnnotations } = require('./keywords');
const { normalizeSchema } = require('./normalization');
const { sortInterestingValues } = require('./utils');
const { unionValues } = require('./utils/array');
const { getSchemaAssignmentErrors } = require('./validation');

/**
 * Returns an union schema of the all given schemas.
 * If the array is empty, then returns null.
 * @param schemas {array} array of schemas to combine
 * @param simplify {boolean} whether or not to find common shared schema
 */
function getUnionSchema(schemas, simplify) {
  if (!Array.isArray(schemas)) {
    throw new Error('getUnionSchema expects an array parameter');
  }
  const actualSchemas = schemas.filter((schema) => schema != null);
  if (!actualSchemas.length) {
    return null;
  }
  return actualSchemas.reduce((schema1, schema2) => combineSchemaUnion(schema1, schema2, simplify));
}

const schemaEqualityCheckOptions = {
  tolerant: false,
  subset: false,
};

function isEqualSchema(schema1, schema2) {
  return !getSchemaAssignmentErrors(schema1, schema2, schemaEqualityCheckOptions).length
    && !getSchemaAssignmentErrors(schema2, schema1, schemaEqualityCheckOptions).length;
}

function combineSchemaUnion(schema1, schema2, simplify) {
  // eslint-disable-next-line no-param-reassign
  schema1 = normalizeSchema(schema1);
  // eslint-disable-next-line no-param-reassign
  schema2 = normalizeSchema(schema2);
  const combinedSchema = combineSchemaUnionType(schema1, schema2, simplify);
  if (combinedSchema.anyOf || combinedSchema.allOf) {
    return combinedSchema;
  }
  const { enum: _, examples, ...schema } = combinedSchema;
  const examples1 = schema1.examples;
  const examples2 = schema2.examples;
  if (examples1 || examples2) {
    // Combine examples, and then apply the combined examples
    const resultExamples = unionValues(examples1 || [], examples2 || []);
    if (resultExamples.length) {
      schema.examples = resultExamples;
    }
  }
  const enum1 = schema1.enum;
  const enum2 = schema2.enum;
  if (enum1 || enum2) {
    // Combine the schema without enums, and then apply the combined enum
    const resultEnum = enum1 && enum2 && sortInterestingValues(
      unionValues(enum1, enum2),
    );
    if (resultEnum) {
      schema.enum = resultEnum;
    } else {
      // Instead of forgetting the enums, add them as examples
      const enumExamples = (enum1 || enum2).filter((val) => val != null);
      if (enumExamples.length) {
        schema.examples = sortInterestingValues(
          unionValues(schema.examples || [], enumExamples),
        );
      }
    }
  }
  return schema;
}

function combineSchemaUnionType(schema1, schema2, simplify) {
  const anyOf1 = schema1.anyOf;
  const anyOf2 = schema2.anyOf;
  if (anyOf1 && anyOf2) {
    return getUnionSchema([...anyOf1, ...anyOf2], simplify);
  }
  if (anyOf1) {
    if (!anyOf1.length) {
      return schema2;
    }
    // Try to merge the non-union schema with one of the nested schemas
    for (let index = 0; index < anyOf1.length; index += 1) {
      const subSchema = anyOf1[index];
      const mergedSchema = combineSchemaUnion(subSchema, schema2, simplify);
      if (!mergedSchema.anyOf) {
        return { anyOf: anyOf1.map((s, i) => (i === index ? mergedSchema : s)) };
      }
    }
    // Could not merge with any sub-schema
    return { anyOf: [...anyOf1, schema2] };
  }
  if (anyOf2) {
    if (!anyOf2.length) {
      return schema1;
    }
    // Try to merge the non-union schema with one of the nested schemas
    for (let index = 0; index < anyOf2.length; index += 1) {
      const subSchema = anyOf2[index];
      const mergedSchema = combineSchemaUnion(schema1, subSchema, simplify);
      if (!mergedSchema.anyOf) {
        return { anyOf: anyOf2.map((s, i) => (i === index ? mergedSchema : s)) };
      }
    }
    // Could not merge with any sub-schema
    return { anyOf: [schema1, ...anyOf2] };
  }
  if (schema1.allOf || schema2.allOf) {
    return simplify ? {} : { anyOf: [schema1, schema2] };
  }
  const $ref1 = schema1.$ref;
  const $ref2 = schema2.$ref;
  const type1 = schema1.type;
  const type2 = schema2.type;
  if ((!type1 && $ref1 == null) || type1 === 'value') {
    // 1st type allows anything
    return schema1;
  }
  if ((!type2 && $ref2 == null) || type2 === 'value') {
    // 2nd type allows anything
    return schema2;
  }
  if ($ref1 != null && $ref2 != null && $ref1 === $ref2) {
    // Schemas refer to the same type
    return schema1;
  }
  if ($ref1 != null || $ref2 != null) {
    // At least one of the schemas is a reference, and they are incompatible
    return simplify ? {} : { anyOf: [schema1, schema2] };
  }
  // Type 'null' is redundant (unless other type is 'undefined')
  if (type1 === 'null' && type2 !== 'undefined') {
    return schema2;
  }
  if (type2 === 'null' && type1 !== 'undefined') {
    return schema1;
  }
  // Type 'undefined' is redundant (unless other type is 'null')
  if (type1 === 'undefined' && type2 !== 'null') {
    return schema2;
  }
  if (type2 === 'undefined' && type1 !== 'null') {
    return schema1;
  }
  // Type 'json' makes other type redundant unless other type is non-JSON-serializable
  if (type1 === 'json' && isJsonCompatibleSchema(schema2)) {
    return schema1;
  }
  if (type2 === 'json' && isJsonCompatibleSchema(schema1)) {
    return schema2;
  }
  // If both schemas have type "schema", then combine their meta schemas
  if (type1 === 'schema' && type2 === 'schema') {
    const meta1 = schema1.schema;
    const meta2 = schema2.schema;
    if (meta1 && meta2) {
      return {
        type: 'schema',
        schema: combineSchemaUnionType(meta1, meta2),
      };
    }
    return meta2 ? schema1 : schema2;
  }
  if (type1 !== type2) {
    // Allow any of the given types
    if (!simplify) {
      return { anyOf: [schema1, schema2] };
    }
    // Check if both types are JSON compatible
    if (isJsonCompatibleSchema(schema1) && isJsonCompatibleSchema(schema2)) {
      return { type: 'json' };
    }
    return {};
  }
  if (type1 === 'object') {
    const newObjectSchema = {
      ...pickAnnotations(schema2),
      ...pickAnnotations(schema1),
      type: 'object',
    };
    const properties1 = schema1.properties;
    const properties2 = schema2.properties;
    const additionalProperties1 = schema1.additionalProperties;
    const additionalProperties2 = schema2.additionalProperties;
    // Combine the additional properties
    if (additionalProperties1 != null || additionalProperties2 != null) {
      if (additionalProperties1 === true || additionalProperties2 === true) {
        newObjectSchema.additionalProperties = {};
      } else if (additionalProperties1 && additionalProperties2) {
        newObjectSchema.additionalProperties = combineSchemaUnion(
          additionalProperties1,
          additionalProperties2,
          simplify,
        );
      } else {
        newObjectSchema.additionalProperties = additionalProperties1 || additionalProperties2;
      }
    }
    if (newObjectSchema.additionalProperties != null) {
      // Union includes dictionaries
      if (!properties1 && !properties2) {
        return newObjectSchema;
      }
      if (!simplify) {
        // At least one of the object types is not a dictionary, too complex to combine
        return { anyOf: [schema1, schema2] };
      }
    }
    // Test if one of the schemas has unknown properties
    if (!properties1 || !properties2) {
      return newObjectSchema;
    }
    // At this point both schemas have properties! Test their compatibility!
    const propertyNames1 = Object.keys(properties1);
    const propertyNames2 = Object.keys(properties2);
    const required1 = schema1.required || propertyNames1;
    const required2 = schema2.required || propertyNames2;
    const allPropertyNames = unionValues(propertyNames1, propertyNames2);
    newObjectSchema.properties = {};
    newObjectSchema.required = [];
    let incompatiblePropertyCount = 0;
    for (let i = 0; i < allPropertyNames.length; i += 1) {
      const propertyName = allPropertyNames[i];
      const property1 = properties1[propertyName];
      const property2 = properties2[propertyName];
      // Determine property result type
      let isIncompatible = false;
      if (!property1 || !property2) {
        isIncompatible = true;
        newObjectSchema.properties[propertyName] = property1 || property2;
      } else if (property1 && property2) {
        isIncompatible = !isEqualSchema(property1, property2);
        newObjectSchema.properties[propertyName] = combineSchemaUnion(
          property1,
          property2,
          simplify,
        );
      }
      // Determine property requirement
      const isRequired1 = required1.indexOf(propertyName) >= 0;
      const isRequired2 = required2.indexOf(propertyName) >= 0;
      if (isRequired1 && isRequired2) {
        newObjectSchema.required.push(propertyName);
      } else if (isRequired1 || isRequired2) {
        // One of the properties was required while other was not
        isIncompatible = true;
      }
      if (isIncompatible) {
        incompatiblePropertyCount += 1;
        if (!simplify && incompatiblePropertyCount > 1) {
          // Too many incompatibility in properties, fall back to a union schema
          return { anyOf: [schema1, schema2] };
        }
      }
    }
    // If all properties are required, then omit `required`
    if (newObjectSchema.required.length === allPropertyNames.length) {
      delete newObjectSchema.required;
    }
    return newObjectSchema;
  }
  if (type1 === 'array') {
    // Check if item schemas are equal
    const items1 = schema1.items;
    const items2 = schema2.items;
    if (simplify || isEqualSchema(items1, items2)) {
      return {
        type: 'array',
        items: combineSchemaUnion(items1, items2, simplify),
      };
    }
    return { anyOf: [schema1, schema2] };
  }
  if (type1 === 'string') {
    const format1 = schema1.format;
    const format2 = schema2.format;
    if (!format1) {
      // First string is unformatted -> result is unformatted
      return schema1;
    }
    if (!format2) {
      // Second string is unformatted -> result is unformatted
      return schema2;
    }
    if (format1 === '*') {
      return schema1;
    }
    if (format2 === '*') {
      return schema2;
    }
    if (isFormatCompatible(format2, format1)) {
      // First format includes the second format
      return schema1;
    }
    if (isFormatCompatible(format1, format2)) {
      // Second format includes the first format
      return schema2;
    }
    // Incompatible formats
    return simplify ? { type: 'string' } : { anyOf: [schema1, schema2] };
  }
  // Schemas are equal
  return schema1;
}

module.exports.getUnionSchema = getUnionSchema;
