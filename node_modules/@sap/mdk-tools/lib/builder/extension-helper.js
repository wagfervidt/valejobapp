const _=require('lodash');
const KEY_NAME_METADATA ="_Name";
const KEY_ARRAY_REMOVE = "Remove";
const KEY_ARRAY_REORDER = "Reorder";
const KEY_ARRAY_ADD = "Add";
const KEY_ARRAY_INSERT_AFTER_NAME = "NameAfter";
const KEY_ARRAY_INSERT_AFTER_INDEX = "IndexAfter";
const KEY_ARRAY_INSERT_BEFORE_NAME = "NameBefore";
const KEY_ARRAY_INSERT_BEFORE_INDEX = "IndexBefore";

const KEY_SEP = "/";
const VALUE_REMOVED ="undefined";

function mergeJson(oMap, oTarget) {
    let targetObj;
    if (Array.isArray(oMap)) {
        oMap.forEach(item => {
            //if no Name, it will be applied to root object. this is a patch for .fragment.
            if (!item[KEY_NAME_METADATA] && oTarget[KEY_NAME_METADATA]) {
                item[KEY_NAME_METADATA] = oTarget[KEY_NAME_METADATA];
            }
            targetObj = _findObjectByName(oTarget,item[KEY_NAME_METADATA]);
            if (targetObj) {
                _mergeOneJsonObject(targetObj, item);
            } else {
                throw Error(`Not found object with _Name ${item[KEY_NAME_METADATA]} in base` );
            }
           
        });
    } else {
        if (!oMap[KEY_NAME_METADATA] && oTarget[KEY_NAME_METADATA]) {
            oMap[KEY_NAME_METADATA] = oTarget[KEY_NAME_METADATA];
        }
        targetObj = _findObjectByName(oTarget,oMap[KEY_NAME_METADATA]);
        if (targetObj) {
            _mergeOneJsonObject(targetObj, item);
        } else {
            throw Error(`Not found object with _Name ${oMap[KEY_NAME_METADATA]} in base` );
        }
    }
    return oTarget;
}

function mergeJs(oMap, sTarget){
    if (Array.isArray(oMap)) {
        oMap.forEach(item => {
            sTarget = _mergeOneJsExt(sTarget, item.Name, item.Value);
        });
    } else {
        sTarget = _mergeOneJsExt(sTarget, oMap.Name, oMap.Value);
    }
    return sTarget;
}

function mergeI18n(sSource, sTarget) {
    let sourcePairs = _getKeyValuePairs(sSource);
    let targetPairs = _getKeyValuePairs(sTarget);
    let mergedPairs = _.cloneDeep(sourcePairs);
    targetPairs.forEach(item =>{
        let isDuplicate= sourcePairs.some(srcItem => srcItem.key===item.key);
        if (!isDuplicate) {
            mergedPairs.push(item);
        }
    });
    let sContent = "";
    mergedPairs.forEach(item =>{
        sContent += `${item.key}=${item.value}\n`;
    })
    return sContent;
}

function mergeStyle(sSource, sTarget){
    //it's merged in runtime, the later has higher priority
    sSource =  sSource.replace(/\/\*[\s\S]*?\*\//g, '');
    return `${sTarget}\n${sSource}`;
}

function _mergeOneJsonObject(oTarget, oItem) {
    for (let key in oItem) {
        if (oItem.hasOwnProperty(key) && key!==KEY_NAME_METADATA) {
            let oRet = _getParentWithKey(oTarget,key);
            let oTargetParent = oRet.parent;
            let sSourceKey = oRet.key;

            if (_isArrayChange(oItem[key])) {
                if (oTargetParent[sSourceKey]===undefined) {
                    oTargetParent[sSourceKey] = [];
                }
                //manage array						
                if (oTargetParent[sSourceKey] && Array.isArray(oTargetParent[sSourceKey])){ 
                    //remove
                    if (oItem[key][KEY_ARRAY_REMOVE]) {
                        oItem[key][KEY_ARRAY_REMOVE].forEach((item) =>{
                            const sourceIndex = oTargetParent[sSourceKey].findIndex(souceItem => {return item.Name ? item.Name === souceItem._Name : _.isEqual(souceItem,item)});
                            oTargetParent[sSourceKey].splice(sourceIndex,1);
                        });
                    }
                    //reorder
                    if (oItem[key][KEY_ARRAY_REORDER]) {
                        let newArr = [];

                        for (let i = 0; i < oItem[key][KEY_ARRAY_REORDER].length; i++) {
                            if (i<oTargetParent[sSourceKey].length) {
                                newArr.push(oTargetParent[sSourceKey][oItem[key][KEY_ARRAY_REORDER][i]]);
                            }
                        }
                        if (oItem[key][KEY_ARRAY_REORDER].length < oTargetParent[sSourceKey].length) {
                            for (let j = oItem[key][KEY_ARRAY_REORDER].length; j < oTargetParent[sSourceKey].length; j++) {
                                newArr.push(oTargetParent[sSourceKey][j]);
                            }
                        }

                        oTargetParent[sSourceKey] = newArr;
                    }
                    //add
                    if (oItem[key][KEY_ARRAY_ADD]) {
                        oItem[key][KEY_ARRAY_ADD].forEach((item) => {
                            const targetName = item[KEY_ARRAY_INSERT_AFTER_NAME]!==undefined ? item[KEY_ARRAY_INSERT_AFTER_NAME] : item[KEY_ARRAY_INSERT_BEFORE_NAME];
							const targetIndex = item[KEY_ARRAY_INSERT_AFTER_INDEX]!==undefined ? item[KEY_ARRAY_INSERT_AFTER_INDEX] : item[KEY_ARRAY_INSERT_BEFORE_INDEX];

                            if (targetName !== undefined && item.Value !== undefined) {
                                const iIndex = oTargetParent[sSourceKey].findIndex(souceItem => {return souceItem._Name === targetName});
                                if (item[KEY_ARRAY_INSERT_AFTER_NAME]) {
                                    oTargetParent[sSourceKey].splice(iIndex+1,0,item.Value);
                                } else {
                                    oSourceParent[sSourceKey].splice(iIndex - 1, 0, item.Value);
                                }
                            } else if (targetIndex !== undefined && item.Value !== undefined) { 
                                if (item[KEY_ARRAY_INSERT_AFTER_INDEX]!==undefined) {
                                    oTargetParent[sSourceKey].splice(item.Index+1,0,item.Value);
                                } else {
                                    //the index is from end
                                    const realIndex = oTargetParent[sSourceKey].length - item[KEY_ARRAY_INSERT_BEFORE_INDEX] -1;
                                    oTargetParent[sSourceKey].splice(realIndex,0,item.Value);
                                }
                            } else { 
                                throw Error(`Failed to merge ${oTargetParent[KEY_NAME_METADATA]} ${sSourceKey}` );
                            }
                        });
                    }
                    
                } else {   
                    //unsupport array operation, it may caused by base changed arrary into
					throw Error(`Failed to merge array into another type: ${oItem[KEY_NAME_METADATA]}.${sSourceKey}`);
                }
            } else {
                if (oItem[key] ===VALUE_REMOVED) {
                    delete oTargetParent[sSourceKey];
                } else {
                    oTargetParent[sSourceKey] = oItem[key];//simple
                }
            }
        }
    }
}

function _isArrayChange(oChange) {
    return oChange && (oChange[KEY_ARRAY_ADD] || oChange[KEY_ARRAY_REORDER] || oChange[KEY_ARRAY_REMOVE]);
}

function _getParentWithKey(oSource, key) {
    if (key.indexOf(KEY_SEP)===0) {
        return {parent: oSource, key: key};
    } else {
        let aKey = key.split(KEY_SEP);
        let oParent = oSource; //Object.assign({},oSource);
        for (let i=0; i<aKey.length-1; i++) {
            if (!oParent[aKey[i]]) {
                oParent[aKey[i]] = {};
            }
            oParent =  oParent[aKey[i]];
            
        }
        return  {parent: oParent, key: aKey[aKey.length-1]}
    }
}

function _mergeOneJsExt(sContent, sName, aValue) {
    if (!sName) {
        throw Error(`No extension point name.` );
    }
    let theRegexStringStart =`\\/\\/ExtPt-${sName}:\\s*==START==`;
    let theRegexJSExtContentStart = new RegExp(theRegexStringStart, "g");
    let theRegexStringEnd =`\\/\\/ExtPt-${sName}:\\s*==END==`;
    let theRegexJSExtContentEnd = new RegExp(theRegexStringEnd, "g");
    const linesWithStart = sContent.match(theRegexJSExtContentStart);
    const linesWithEnd = sContent.match(theRegexJSExtContentEnd);
    const aContent = sContent.split("\n");

    if (linesWithStart && linesWithEnd) {
        if (linesWithStart.length===1 && linesWithEnd.length===1) {
            const iStartLine = aContent.findIndex((item)=> item.trim()=== linesWithStart[0].trim());
            const iEndLine = aContent.findIndex((item)=> item.trim()=== linesWithEnd[0].trim());
            if (iEndLine> iStartLine) {
                let sTemp = "";
                for (let i=0; i<=iStartLine; i++) {
                    sTemp = sTemp + aContent[i] + "\n";
                }
                sTemp = sTemp + aValue.join("\n") ;
                for (let j=iEndLine; j<aContent.length; j++) {
                    sTemp =  sTemp +"\n" +aContent[j] ;
                }
                return sTemp;
            }
        } else {
            throw Error(`Invalid matched numbers for extension point ${sName}` );
        }
    } else {
        throw Error(`failed to find extension point ${sName}` );
    }
    return sContent;
}

function _getKeyValuePairs(sContent) {
    let lines = sContent.split('\n');
    let pairs = [];
    lines.forEach(line => {
        if (!line.trim().startsWith('#')) {
            let separatorIdx = line.indexOf('=');
            if (separatorIdx>0) {
                let firstString = line.substr(0, separatorIdx).trim();
                let secondString = line.substr(separatorIdx + 1, line.length - separatorIdx + 1).trim();
                pairs.push({
                    key: firstString,
                    value: secondString
                });
            }
        }
    });
    return pairs;
}

function _findObjectByName(obj, name) {
    if (name===undefined) {
        return obj;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        
        if (key === '_Name' && value === name) {
          return obj;
        }
        
        if (typeof value === 'object' && value !== null) {
          const foundObject = _findObjectByName(value, name);
          if (foundObject !== null) {
            return foundObject;
          }
        }
        
        if (Array.isArray(value)) {
          for (const item of value) {
            if (typeof item === 'object' && item !== null) {
              const foundObject = _findObjectByName(item, name);
              if (foundObject !== null) {
                return foundObject;
              }
            }
          }
        }
      }
    }
    
    return null;
  }
module.exports = {
    mergeJson,
    mergeJs,
    mergeI18n,
    mergeStyle
}
