/**
 * Represents an exported, JSON-serializable formula expression
 * that can be used on runtime without
 * need of heavy re-parsing the original formula.
 *
 * You can use this structure with
 * - `prepareExecutable` for runtime use
 * - `importExpression` for editor use
 */
export interface ExportedExpression {
  /**
   * The original expression formula that was parsed.
   */
  formula: string;
  /**
   * JavaScript implementation of the formula.
   * Never use this directly!!!
   * Instead, always follow the correct runtime usage!
   */
  script: string;
  /**
   * List of "accessor paths" describing what information the expression needs
   * from the provided context object. You can use this information to optimize
   * your runtime.
   */
  dependencies: [string, ...string[]][];
  /**
   * List of function names used by the expression on runtime.
   * It may contain helper functions in addition to the ones written in formula.
   */
  functions: string[];
  /**
   * JavaScript for the **inverse evaluation**. Present if the formula supports inversion,
   * otherwise omitted. Never use this directly, but instead follow the inverse execution usage!
   */
  inverse?: string;
  /**
   * List similar to `dependencies`, describing what "paths" in the context would be updated by
   * an inverse evaluation. Present if the formula supports inversion **and if not equal
   * to `dependencies`**, otherwise omitted.
   */
  inverts?: [string, ...string[]][];
  /**
   * Whether or not executing the expression _will always results to an equal value_.
   * Value `true` implies that `dependencies` is empty, and `functions` is either empty
   * or only contains deterministic functions. Instead of `false`, this property is omitted.
   */
  isConstant?: true;
  /**
   * Whether or not the formula only consists of one context usage, followed by any number
   * of property accessors, and _nothing else_. If `true` then `dependencies`
   * has _exactly one_ array, and `functions` is empty or only contains `LOOKUP`.
   * Instead of `false`, this property is omitted.
   */
  isPointer?: true;
}

/**
 * Options for an execution
 */
export interface ExecutionOptions {
  /**
   * The number of milliseconds after which the execution
   * is interrupted, if it takes longer. The execution will throw
   * a `TimeoutError`.
   */
  timeout?: number | null;
}

/**
 * Represents a formula expression ready to be executed, for runtime.
 */
export interface ExecutableExpression {

  /**
   * Any syntax error if the provided exported formula expression was invalid.
   */
  readonly syntaxError: SyntaxError | null;

  /**
   * List of "accessor paths" describing what information the expression needs
   * from the provided context object. You can use this information to optimize
   * your runtime.
   */
  readonly dependencies: [string, ...string[]][];

  /**
   * List similar to `dependencies`, describing what "paths" in the context would be updated by
   * an inverse evaluation. Present if the formula supports inversion **and if not equal
   * to `dependencies`**, otherwise omitted.
   */
  readonly inverts?: [string, ...string[]][];

  /**
   * Call this to evaluate the formula expression on runtime.
   * As a parameter you should pass the context object, where keys are
   * "root variables" available for the formula.
   *
   * Returns the result of the formula evaluation.
   * May throw an error if the formula is invalid.
   * Also wrap this around try-except for user-provided formulas!
   *
   * @param context the mapping of root variables available for the formula
   */
  execute(context?: Record<string, unknown>, options?: ExecutionOptions): unknown;

  /**
   * Performs an "inverse execution" for the formula.
   * See the documentation for details how to use this!
   *
   * @param result the end result of the formula
   * @param context the current mapping of root variables available for the formula
   * @returns mapping of root variables that were changed by the inversion
   */
  invertDiff(result: unknown, context?: Record<string, unknown>): Record<string, unknown>;

  /**
   * Performs an "inverse execution" for the formula.
   * See the documentation for details how to use this!
   *
   * @param result the end result of the formula
   * @param context the current mapping of root variables available for the formula
   * @returns the updated root variables after the inversion
   */
  invert(result: unknown, context?: Record<string, unknown>): Record<string, unknown>;
}

/**
 * Prepares previously exported expression for evaluation, for runtime usage.
 * @param expression An exported expression object
 * @param context Default runtime context available for the expression
 */
export const prepareExecutable: (expression: ExportedExpression, context?: Record<string, unknown>) => ExecutableExpression;
