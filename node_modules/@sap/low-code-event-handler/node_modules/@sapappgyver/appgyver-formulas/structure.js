/* eslint-disable no-bitwise,no-nested-ternary */
/**
 * This module contains helpers used by the grammar parser
 * to build the syntax structure and analysis results.
 */
const {
  getUnionSchema, getSchemaAssignmentErrors, resolveObjectMemberAccessor,
  getConstantSchema, getExampleValues, stringifyType,
  idenfitySchemas, resolveSchemaReferences, traverseSchema,
} = require('@sapappgyver/appgyver-schemas');
const {
  combinations, pickEvenly, includesValue,
  unionValues, addUnionValues, indexOfValue,
} = require('@sapappgyver/appgyver-schemas/utils/array');
const { isEqual, isSame } = require('@sapappgyver/appgyver-schemas/utils/equality');
const { sortInterestingValues } = require('@sapappgyver/appgyver-schemas/utils');
const functions = require('./functions');
const { valueKeywords, describeToken } = require('./tokenizer');
const { assertNotTimedOut } = require('./timeout');

// For memory-optimization, a re-usable empty array
const empty = [];

function isExpecting(node, char) {
  return node.expects.indexOf(char) >= 0;
}

function stringifyTokens(tokens) {
  return tokens.map(token => (token ? token.text : '')).join('');
}

function getCombinedNodeAnalyzer(baseNode, nodes, analyze) {
  return (contextSchema, options) => {
    const nestedAnalyses = nodes.map(node => node.analyze(contextSchema, options));
    const { schema = {}, errors = empty, ...analysis } = analyze(
      contextSchema, nestedAnalyses, options,
    );
    const nestedErrors = nestedAnalyses.map(nestedAnalysis => nestedAnalysis.errors || []);
    return {
      ...baseNode,
      contextSchema,
      children: nestedAnalyses,
      ...analysis,
      schema,
      errors: empty.concat(...nestedErrors, errors),
    };
  };
}

function buildBaseNode(
  type, script, tokens, children = [], syntaxErrors = null, addedFunctions,
) {
  // eslint-disable-next-line no-param-reassign
  tokens = tokens.filter(token => token.offset != null);
  const formula = stringifyTokens(tokens);
  const allSyntaxErrors = empty.concat(...children.map(node => node.syntaxErrors));
  if (syntaxErrors) {
    syntaxErrors.forEach((syntaxError) => {
      if (syntaxError.offset == null) {
        const lastToken = tokens[tokens.length - 1];
        // eslint-disable-next-line no-param-reassign
        syntaxError = {
          ...syntaxError,
          offset: lastToken.offset + lastToken.text.length,
          length: 0,
        };
      }
      allSyntaxErrors.push(syntaxError);
    });
  }
  const visibleTokens = tokens
    .filter(token => token.text)
    .map(token => ({
      text: token.text,
      offset: token.offset,
      length: token.text.length,
      type: token.type,
    }));
  return {
    type,
    script,
    offset: tokens.length ? tokens[0].offset : 0,
    length: formula.length,
    tokens: visibleTokens,
    formula,
    children,
    term: null,
    inverse: null,
    inverts: null,
    syntaxErrors: allSyntaxErrors,
    dependencies: unionValues(...children.map(node => node.dependencies)),
    functions: addedFunctions
      ? unionValues(addedFunctions, ...children.map(node => node.functions))
      : unionValues(...children.map(node => node.functions)),
    expects: (children.length && children[children.length - 1].expects) || '',
  };
}

function makeBaseAnalysis(node, contextSchema, schema, errors = [], options) {
  const childAnalyses = node.children.map(child => child.analyze(contextSchema, options));
  const nestedErrors = childAnalyses.map(analysis => analysis.errors);
  if (typeof schema === 'undefined') {
    // eslint-disable-next-line no-param-reassign
    schema = childAnalyses.length
      ? getUnionSchema(childAnalyses.map(child => child.schema))
      : undefined;
  }
  return {
    ...node,
    contextSchema,
    errors: errors.concat(...nestedErrors),
    schema,
    children: childAnalyses,
  };
}

/**
 * An internal helper to make result objects with the schema and errors,
 * to make the code more tidy.
 * @param {object} schema Schema object
 * @param {array} errors Sub-errors
 */
function makeAnalysis(schema, errors = []) {
  return { schema, errors };
}

function executeConstantCombinations(paramArrays, executor, ignoreErrors) {
  if (!paramArrays) {
    return undefined;
  }
  if (!paramArrays.length) {
    // No parameters
    return [executor([])];
  }
  if (paramArrays.every(options => options != null)) {
    const results = [];
    const combs = combinations(paramArrays);
    for (let i = 0; i < combs.length; i += 1) {
      const params = combs[i];
      try {
        const result = executor(params);
        if (typeof result !== 'undefined' && !Object.is(result, NaN)) {
          if (!includesValue(results, result)) {
            results.push(result);
          }
        } else if (!ignoreErrors) {
          return undefined;
        }
      } catch (error) {
        // Abort if not ignoring errors
        if (!ignoreErrors) {
          return undefined;
        }
      }
    }
    // Sort any null value to the last value, because that is not usually interesting
    const indexOfNull = results.indexOf(null);
    if (indexOfNull >= 0) {
      // Move the value to the last
      results.push(results.splice(indexOfNull, 1)[0]);
    }
    return results;
  }
  return undefined;
}

const maxEnumCount = 10;
const maxExampleCount = 5;

function evaluateSchemaEnumAndExamples(paramSchemas, evaluator, baseSchema) {
  let schema = baseSchema;
  // Auto-generate enum values
  const resultEnum = executeConstantCombinations(
    paramSchemas.map((paramSchema) => {
      const enums = paramSchema && paramSchema.enum;
      if (enums && enums.length <= maxEnumCount) {
        return enums;
      }
      if (paramSchema && paramSchema.type === 'schema') {
        const metaSchema = paramSchema.schema;
        if (metaSchema) {
          return metaSchema.anyOf ? metaSchema.anyOf : [metaSchema];
        }
      }
      return undefined;
    }),
    evaluator,
    false,
  );
  if (resultEnum && resultEnum.length && resultEnum.length <= maxEnumCount) {
    // The combinations might become extremely large quickly,
    // so only keep at most 10 enum values
    if (schema && schema.type === 'schema') {
      const metaSchema = resultEnum.length === 1 ? resultEnum[0] : { anyOf: resultEnum };
      schema = { ...schema, schema: metaSchema };
    } else {
      schema = { ...schema, enum: resultEnum };
    }
  }
  // Auto-generate example values
  const resultExamples = executeConstantCombinations(
    paramSchemas.map(paramSchema => pickEvenly(getExampleValues(paramSchema), maxExampleCount)),
    evaluator,
    true,
  );
  if (resultExamples && resultExamples.length && !(schema && schema.type === 'schema')) {
    // The combinations might become extremely large quickly,
    // so only keep at most 5 examples values
    schema = {
      ...schema,
      examples: sortInterestingValues(pickEvenly(resultExamples, maxExampleCount)),
    };
  }
  return schema || {};
}

const operatorFunctions = {
  '==': { name: 'IS_EQUAL', script: 'IS_EQUAL' },
  '!=': { name: 'IS_EQUAL', script: '!IS_EQUAL' },
  '===': { name: 'IS_SAME', script: 'IS_SAME' },
  '!==': { name: 'IS_SAME', script: '!IS_SAME' },
};

function executeOperator(operand1, operand2, operator) {
  switch (operator) {
    case '+': return operand1 + operand2;
    case '-': return operand1 - operand2;
    case '*': return operand1 * operand2;
    case '/': return operand1 / operand2;
    case '%': return operand1 % operand2;
    case '&&': return operand1 && operand2;
    case '||': return operand1 || operand2;
    case '==': return isEqual(operand1, operand2);
    case '!=': return !isEqual(operand1, operand2);
    case '===': return isSame(operand1, operand2);
    case '!==': return !isSame(operand1, operand2);
    case '<': return operand1 < operand2;
    case '>': return operand1 > operand2;
    case '<=': return operand1 <= operand2;
    case '>=': return operand1 >= operand2;
    default: return undefined;
  }
}
function executeUnary(operand, operator) {
  switch (operator) {
    case '+': return +operand;
    case '-': return -operand;
    case '!': return !operand;
    default: return undefined;
  }
}

function isConstantStructure(node) {
  if (!node.script || !node.dependencies || !node.functions) {
    // Not enough information available -> assume not constant
    return false;
  }
  if (node.dependencies.length) {
    // Has dependencies -> is not constant
    return false;
  }
  // Is constant if every used function is deterministic
  return node.functions.every((funcName) => {
    const func = functions[funcName];
    return func != null && func.deterministic !== false;
  });
}

function getInvertParameterIndexes(paramNodes, maxInversions) {
  if (!maxInversions) {
    return empty;
  }
  const invertIndexes = [];
  paramNodes.forEach((node, idx) => {
    const paramDef = node.parameter;
    if (typeof paramDef === 'undefined' || (paramDef && paramDef.inversible)) {
      if (node.inverse && invertIndexes.length < maxInversions) {
        invertIndexes.push(idx);
      }
    }
  });
  return invertIndexes;
}

function compareParameterItemDependency(item1, item2) {
  let item1IsDependency = false;
  let item2IsDependency = false;
  item2.$refs.forEach(($ref) => {
    if (item1.$ids[$ref]) {
      item1IsDependency = true; // schema2 depends on schema1
    }
  });
  item1.$refs.forEach(($ref) => {
    if (item2.$ids[$ref]) {
      item2IsDependency = true; // schema1 depends on schema2
    }
  });
  if (item1IsDependency) {
    return -1;
  }
  if (item2IsDependency) {
    return 1;
  }
  return 0;
}

function getParameterAnalysisPlan(parameterDefs, paramNodes) {
  const parameterItems = parameterDefs.map((paramDef, index) => {
    const paramNode = paramNodes[index];
    const $ids = {};
    const $refs = [];
    traverseSchema(paramDef, (schema) => {
      const { $id, $ref } = schema;
      if ($id != null) {
        $ids[$id] = true;
      }
      if ($ref != null) {
        $refs.push($ref);
      }
      return schema;
    });
    return {
      paramDef, paramNode, index, $ids, $refs,
    };
  });
  // Sort to the dependency order
  parameterItems.sort(compareParameterItemDependency);
  // Duplicate items that depend on itself
  for (let i = parameterItems.length - 1; i >= 0; i -= 1) {
    const item = parameterItems[i];
    const dependency = compareParameterItemDependency(item, item);
    if (dependency !== 0) {
      parameterItems.splice(i, 0, item);
    }
  }
  // Append extra descriptions so that they become analyzed as well
  for (let index = parameterDefs.length; index < paramNodes.length; index += 1) {
    const paramNode = paramNodes[index];
    parameterItems.push({ paramNode, index });
  }
  return parameterItems;
}

const buildFormula = (leadingWs, childNode, trailingWs, errorToken) => {
  if (leadingWs.text === '' && trailingWs.text === '' && !errorToken && childNode) {
    // No wrapper structure
    return childNode;
  }
  const syntaxErrors = [];
  const tokens = [leadingWs];
  const children = [];
  if (childNode) {
    tokens.push(...childNode.tokens);
    children.push(childNode);
  }
  tokens.push(trailingWs);
  if (errorToken) {
    tokens.push(errorToken);
    const firstChar = /^.?/u.exec(errorToken.text);
    syntaxErrors.push({
      message: `Invalid syntax: Unexpected ${JSON.stringify(firstChar[0])}`,
      offset: errorToken.offset,
      length: errorToken.text.length,
    });
  } else if (!childNode) {
    syntaxErrors.push({
      message: 'Incomplete syntax',
      offset: 0,
      length: leadingWs.text.length + trailingWs.text.length,
    });
  }
  const script = childNode ? childNode.script : '';
  const baseNode = buildBaseNode('trimmed', script, tokens, children, syntaxErrors);
  baseNode.inverse = childNode ? childNode.inverse : null;
  baseNode.inverts = childNode ? childNode.inverts : null;
  if (childNode && childNode.reference) {
    baseNode.reference = childNode.reference;
  }
  const refactor = (...args) => {
    const childStr = childNode ? childNode.refactor(...args) : '';
    return `${leadingWs.text}${childStr}${trailingWs.text}${errorToken ? errorToken.text : ''}`;
  };
  const analyze = (contextSchema, options) => makeBaseAnalysis(
    baseNode, contextSchema, undefined, undefined, options,
  );
  return { ...baseNode, refactor, analyze };
};

const buildError = (expression1, sepWs, expression2, errorToken) => {
  const syntaxErrors = [];
  const tokens = [];
  const children = [];
  if (expression1) {
    tokens.push(...expression1.tokens);
    children.push(expression1);
  }
  if (sepWs) {
    tokens.push(sepWs);
  }
  if (errorToken) {
    tokens.push(errorToken);
    syntaxErrors.push({
      message: `Invalid syntax: Unexpected ${describeToken(errorToken)}`,
      offset: errorToken.offset,
      length: errorToken.text.length,
    });
  }
  if (expression2) {
    tokens.push(...expression2.tokens);
    children.push(expression2);
    const [unexpectedToken] = expression2.tokens;
    syntaxErrors.push({
      message: `Invalid syntax: Unexpected ${describeToken(unexpectedToken)}`,
      offset: unexpectedToken.offset,
      length: unexpectedToken.length,
    });
  }
  const script = expression1 ? expression1.script : '';
  const baseNode = buildBaseNode('error', script, tokens, children, syntaxErrors);
  baseNode.inverse = expression1 ? expression1.inverse : null;
  baseNode.inverts = expression1 ? expression1.inverts : null;
  if (expression1 && expression1.reference) {
    baseNode.reference = expression1.reference;
  }
  const refactor = (...args) => {
    const expr1Str = expression1 ? expression1.refactor(...args) : '';
    const expr2Str = expression2 ? expression2.refactor(...args) : '';
    return `${expr1Str}${sepWs ? sepWs.text : ''}${expr2Str}${errorToken ? errorToken.text : ''}`;
  };
  const analyze = (contextSchema, options) => makeBaseAnalysis(
    baseNode, contextSchema, undefined, undefined, options,
  );
  return { ...baseNode, refactor, analyze };
};

const buildSyntaxError = (tokens, unexpectedToken) => {
  let syntaxErrors;
  if (unexpectedToken) {
    const { text, offset } = unexpectedToken;
    const message = `Invalid syntax: Unexpected ${describeToken(unexpectedToken)}`;
    syntaxErrors = [{ message, offset, length: text.length }];
  } else {
    const offset = tokens.reduce((length, token) => length + token.text.length, 0);
    syntaxErrors = [{ message: 'Incomplete syntax', offset, length: 0 }];
  }
  const baseNode = buildBaseNode('error', '', tokens, [], syntaxErrors);
  const refactor = () => baseNode.formula;
  const analyze = (contextSchema, options) => makeBaseAnalysis(
    baseNode, contextSchema, undefined, undefined, options,
  );
  return { ...baseNode, refactor, analyze };
};

const buildAlias = (anchor, leadingWs, identifier, trailingWs) => {
  let { offset } = leadingWs;
  if (offset == null) {
    offset = anchor.offset + anchor.text.length;
    // eslint-disable-next-line no-param-reassign
    leadingWs = { ...leadingWs, offset };
  }
  const tokens = [leadingWs];
  let name;
  let syntaxErrors;
  if (identifier) {
    tokens.push(identifier);
    name = identifier.text;
    if (identifier.type === 'keyword') {
      // Cannot use reserved keyword as an alias
      syntaxErrors = [{
        message: `Cannot use the reserved keyword ${JSON.stringify(identifier.text)} as a parameter alias`,
        offset: identifier.offset,
        length: identifier.text.length,
      }];
    } else if (identifier.type === 'functionName') {
      // Cannot use function name as an alias
      syntaxErrors = [{
        message: `Cannot use the function name ${JSON.stringify(identifier.text)} as a parameter alias`,
        offset: identifier.offset,
        length: identifier.text.length,
      }];
    }
  }
  if (trailingWs) {
    tokens.push(trailingWs);
  }
  if (!identifier) {
    syntaxErrors = [{
      message: 'Missing function parameter alias',
      offset,
      length: stringifyTokens(tokens).length,
    }];
  }
  const baseNode = buildBaseNode('alias', '', tokens, undefined, syntaxErrors);
  return {
    ...baseNode,
    name,
    identifier,
    term: identifier ? [identifier] : null,
  };
};

const buildAliasList = (aliasItems, closingChar) => {
  let syntaxErrors;
  const tokens = [];
  const children = aliasItems.map(({ prefix, alias }) => {
    tokens.push(...prefix, ...alias.tokens);
    return alias;
  });
  if (closingChar) {
    tokens.push(closingChar);
  } else {
    syntaxErrors = [{ message: 'Missing closing character for the function parameter alias list' }];
  }
  const node = buildBaseNode('aliasList', '', tokens, children, syntaxErrors);
  if (!closingChar) {
    node.expects = ',>';
  }
  return node;
};

// NOTE: Does not return a node but a temporary structrue
const buildParameterList = (items, prefix = empty) => ({ items, prefix });

const buildParameter = (anchor, leadingWs, node, trailingWs) => {
  let { offset } = leadingWs;
  if (offset == null) {
    offset = anchor.offset + anchor.text.length;
    // eslint-disable-next-line no-param-reassign
    leadingWs = { ...leadingWs, offset };
  }
  const tokens = [leadingWs];
  const children = [];
  let syntaxErrors;
  if (node) {
    tokens.push(...node.tokens);
    children.push(node);
  } else {
    syntaxErrors = [{
      message: 'Missing formula for the parameter',
      offset,
      length: stringifyTokens(tokens).length,
    }];
  }
  if (trailingWs) {
    tokens.push(trailingWs);
  }
  const script = node ? node.script : 'undefined';
  const baseNode = buildBaseNode('parameter', script, tokens, children, syntaxErrors);
  baseNode.inverse = node ? node.inverse : null;
  baseNode.inverts = node ? node.inverts : null;
  const refactor = (...args) => {
    if (!node) {
      return leadingWs.text;
    }
    return `${leadingWs.text}${node.refactor(...args)}${trailingWs ? trailingWs.text : ''}`;
  };
  const analyze = (contextSchema, options) => makeBaseAnalysis(
    baseNode, contextSchema, undefined, undefined, options,
  );
  return { ...baseNode, analyze, refactor };
};

const buildFunctionCall = (fnNameToken, aliasList, paramList, parenthesisEnd) => {
  const term = [fnNameToken];
  const tokens = [fnNameToken];
  const syntaxErrors = [];
  if (aliasList) {
    tokens.push(...aliasList.tokens);
  }
  if (paramList) {
    if (!parenthesisEnd) {
      syntaxErrors.push({
        message: `Missing closing parenthesis for the ${fnNameToken} function call`,
      });
    } else if (paramList.items.length && isExpecting(paramList.items[paramList.items.length - 1].item, ')')) {
      // If an inner token expects a right parenthesis, and this has one, then reject
      return null;
    }
    tokens.push(...paramList.prefix);
    paramList.items.forEach(({ item, prefix }) => {
      tokens.push(...prefix);
      tokens.push(...item.tokens);
    });
  } else {
    syntaxErrors.push({
      message: 'Missing parentheses for the function call',
    });
  }
  if (parenthesisEnd) {
    tokens.push(parenthesisEnd);
  }
  const functionName = fnNameToken.text;
  const fn = functions[functionName];
  const { offset } = fnNameToken;
  const dependencies = [];
  // Determine (default) aliases supported by the function and their correct order
  const funcAliasDefs = [];
  (fn ? fn.parameters : []).forEach((paramDef) => {
    if (paramDef.type === 'function') {
      paramDef.parameters.forEach((funcParamDef) => {
        if (funcAliasDefs.every(({ name }) => funcParamDef.name !== name)) {
          funcAliasDefs.push(funcParamDef);
        }
      });
    }
  });
  const paramNodes = !paramList ? [] : paramList.items.map(({ item }, index) => ({
    ...item,
    parameter: (fn && fn.parameters[index]) || null,
    index,
  }));
  const aliasNodes = !aliasList ? [] : aliasList.children.map((aliasNode, index) => ({
    ...aliasNode,
    parameter: funcAliasDefs[index] || null,
    index,
  }));
  const children = aliasList ? [aliasList].concat(paramNodes) : paramNodes;
  // Create mapping for parameter aliases
  const aliasReverseMapping = {};
  const aliasMapping = {};
  // First register non-overridden default names
  funcAliasDefs.forEach(({ name: origName }, index) => {
    const aliasNode = aliasNodes[index];
    if (!aliasNode || aliasNode.name == null) {
      aliasMapping[origName] = origName;
      aliasReverseMapping[origName] = origName;
    }
  });
  // Then validate and register custom aliases
  aliasNodes.forEach((aliasNode, index) => {
    const alias = aliasNode && aliasNode.name;
    if (alias == null) {
      return;
    }
    if (aliasReverseMapping[alias] != null) {
      // This name is already in use!
      syntaxErrors.push({
        message: `Duplicate identifier ${JSON.stringify(alias)}`,
        offset: aliasNode.identifier.offset,
        length: alias.length,
      });
    }
    const aliasDef = funcAliasDefs[index];
    const origName = aliasDef && aliasDef.name;
    if (origName != null) {
      aliasMapping[origName] = alias;
      aliasReverseMapping[alias] = origName;
    }
  });
  function transformAlias(origName) {
    const customName = aliasMapping[origName];
    return customName == null ? origName : customName;
  }
  // Build script and dependencies
  const outerParamNodes = paramNodes.map((node) => {
    const paramDef = node.parameter;
    if (!paramDef || paramDef.type !== 'function') {
      // Regular parameter
      return node;
    }
    // A function parameter
    const paramNames = paramDef.parameters.map(funcParam => transformAlias(funcParam.name));
    // Drop last unused parameter names from the function header
    const usedParamNames = paramNames.slice();
    while (usedParamNames.length) {
      const lastParamName = usedParamNames[usedParamNames.length - 1];
      if (node.dependencies.some(([rootName]) => rootName === lastParamName)) {
        // Parameter is used
        break;
      }
      // Drop the last unused parameter
      usedParamNames.pop();
    }
    const funcHeader = usedParamNames.length === 1 ? usedParamNames[0] : `(${usedParamNames.join(',')})`;
    return {
      ...node,
      script: `${funcHeader}=>(${node.script})`,
      paramNames,
      paramInverse: node.inverse && `${funcHeader}=>(${node.inverse})`,
      // Ignore parameter usage from dependencies
      dependencies: node.dependencies.filter(
        ([rootName]) => paramNames.indexOf(rootName) < 0,
      ),
      // Ignore parameter usage from inverts
      inverts: node.inverts && node.inverts.filter(
        ([rootName]) => paramNames.indexOf(rootName) < 0,
      ),
    };
  });
  const paramScripts = outerParamNodes.map((node) => {
    // Collect all actual dependencies from parameters
    addUnionValues(dependencies, node.dependencies);
    return node.script;
  });
  const script = `${functionName}(${paramScripts.join(',')})`;
  const baseNode = buildBaseNode('functionCall', script, tokens, children, syntaxErrors, [functionName]);
  const invertParamIndexes = getInvertParameterIndexes(outerParamNodes, fn && fn.maxInversions);
  if (invertParamIndexes.length) {
    const inverts = [];
    const inverseParamTargetScripts = outerParamNodes.map((node, index) => {
      const isInverted = invertParamIndexes.includes(index);
      if (isInverted) {
        addUnionValues(inverts, node.inverts);
      }
      if (node.paramInverse != null) {
        // Inversible higher order formula parameter
        return `["p",${node.script},${JSON.stringify(node.paramNames)},${node.paramInverse}]`;
      }
      if (isInverted && node.inverse) {
        // Regular inversible parameter
        return node.inverse;
      }
      // A constant parameter
      return `["c",${node.script}]`;
    });
    baseNode.inverse = `${functionName}.inv(${inverseParamTargetScripts.join(',')})`;
    baseNode.inverts = inverts;
  }
  baseNode.term = term;
  baseNode.aliases = aliasNodes;
  baseNode.parameters = paramNodes;
  baseNode.name = functionName;
  baseNode.function = fn;
  baseNode.dependencies = dependencies;
  if (paramList) {
    if (!parenthesisEnd) {
      baseNode.expects = ',)';
    } else if (!isExpecting(baseNode, ')')) {
      baseNode.expects = '';
    }
  }
  // NOTE: 'reference' is purposefully not included!
  return {
    ...baseNode,
    analyze: (contextSchema, options) => {
      let references = null;
      function resolveGenericTypes(schema) {
        return references ? resolveSchemaReferences(schema, references) : schema;
      }
      const parameters = [];
      const outerParams = [];
      const innerParams = [];
      // Analyze the parameters according to an analysis plan, so that generic
      // types would be identified and resolved in correct order.
      const analysisPlan = getParameterAnalysisPlan(fn ? fn.parameters : [], paramNodes);
      analysisPlan.forEach(({ index, paramDef, paramNode }) => {
        // Build context for this specific parameter
        let paramContextSchema = contextSchema;
        if (paramDef && paramDef.type === 'function') {
          paramDef.parameters.forEach(({ name, ...funcParam }) => {
            // Resolve any generic types in function parameters
            const resolvedSchema = resolveGenericTypes(funcParam);
            const contextKey = transformAlias(name);
            paramContextSchema = {
              ...paramContextSchema,
              [contextKey]: resolvedSchema,
            };
          });
        }
        // Perform the analysis
        if (paramNode) {
          const outerAnalysis = paramNode.analyze(paramContextSchema, options);
          const innerAnalysis = outerAnalysis.children[0] || outerAnalysis;
          outerParams[index] = { ...outerAnalysis, parameter: paramDef, index };
          innerParams[index] = innerAnalysis;
          // Identify any generic types for next analyses
          if (paramDef) {
            const identifications = idenfitySchemas(paramDef, outerAnalysis.schema);
            if (Object.keys(identifications).length > 0) {
              references = { ...references, ...identifications };
            }
          }
        }
        if (paramDef) {
          const paramSchema = paramDef.type === 'function' ? paramDef.returnValue || {} : paramDef;
          parameters[index] = resolveGenericTypes(paramSchema);
        }
      });

      // If no function, then warn and return any nested errors
      if (!fn) {
        const functionError = {
          message: `Unknown function ${functionName}`,
          offset,
          length: functionName.length,
        };
        const nestedErrors = [functionError].concat(
          ...outerParams.map(param => param.errors || []),
        );
        return {
          ...baseNode,
          contextSchema,
          errors: nestedErrors,
          schema: {},
          children: outerParams,
        };
      }
      const { deterministic = true } = fn;
      const parameterErrors = [];
      // Check that there are not too many aliases defined
      if (aliasNodes && aliasNodes.length > funcAliasDefs.length) {
        const firstExtraAlias = aliasNodes[funcAliasDefs.length];
        const { offset: aliasOffset } = firstExtraAlias.identifier || firstExtraAlias;
        const { length: aliasLength } = firstExtraAlias.identifier
          ? firstExtraAlias.identifier.text : firstExtraAlias;
        parameterErrors.push({
          offset: aliasOffset,
          length: aliasLength,
          message: funcAliasDefs.length === 1
            ? `Function ${fn.name} takes at most 1 alias`
            : `Function ${fn.name} takes at most ${funcAliasDefs.length} aliases`,
        });
      }
      // Check that the function is not deprecated
      if (fn.deprecated) {
        parameterErrors.push({
          offset,
          length: functionName.length,
          message: `Function ${functionName} is deprecated and should not be used, because it is not guaranteed to work in the future. Please choose another function for this purpose.`,
        });
      }
      // Check that there is a correct number of parameters
      let minParameterCount = parameters.length;
      // Decrease minimum required parameter count for each optional parameter at the end
      // (i.e. ones with 'default')
      while (minParameterCount > 0 && typeof parameters[minParameterCount - 1].default !== 'undefined') {
        minParameterCount -= 1;
      }
      // TODO: Set offset and length according to the first invalid parameter!
      // const errorParameter = innerParams.find((param, index) => index >= minParameterCount);
      if (parameters.length === minParameterCount && innerParams.length !== parameters.length) {
        parameterErrors.push({
          offset,
          length: baseNode.length,
          message: parameters.length === 0
            ? `Function ${fn.name} takes no parameters.`
            : parameters.length === 1
              ? `Function ${fn.name} requires exactly 1 parameter`
              : `Function ${fn.name} requires exactly ${parameters.length} parameters`,
        });
      } else if (innerParams.length < minParameterCount) {
        parameterErrors.push({
          offset,
          length: baseNode.length,
          message: minParameterCount === 1
            ? `Function ${fn.name} requires at least 1 parameter`
            : `Function ${fn.name} requires at least ${minParameterCount} parameters`,
        });
      } else if (innerParams.length > parameters.length) {
        parameterErrors.push({
          offset,
          length: baseNode.length,
          message: parameters.length === 1
            ? `Function ${fn.name} takes at most 1 parameter`
            : `Function ${fn.name} takes at most ${parameters.length} parameters`,
        });
      }
      // Check that the parameter are correct type
      parameters.slice(0, innerParams.length).forEach((requiredParam, index) => {
        const { schema, offset: paramOffset, length: paramLength } = innerParams[index];
        const errors = getSchemaAssignmentErrors(schema, requiredParam);
        errors.forEach((error) => {
          parameterErrors.push({ offset: paramOffset, length: paramLength, ...error });
        });
      });
      const funcAnalysis = fn.analyze(innerParams, offset, parameterErrors);
      const errors = !funcAnalysis.errors ? [] : funcAnalysis.errors.map((error) => {
        const errorParam = innerParams.find(param => param.offset === error.offset);
        const errorLength = errorParam ? errorParam.length : 0;
        return { ...error, length: errorLength };
      });
      if (paramList) {
        errors.unshift(...parameterErrors);
      }
      let resultSchema = funcAnalysis.schema || {};
      if (!errors.length && deterministic && !fn.parameters.some(paramDef => paramDef.type === 'function')) {
        const timestamp = +new Date();
        const timeout = options ? options.executionTimeout : null;
        const runtime = {
          timestamp,
          timeout,
          checkTimeout: () => {
            assertNotTimedOut(timestamp, timeout);
          },
        };
        // TODO: Support enums and examples for higher-order functions!
        resultSchema = evaluateSchemaEnumAndExamples(
          innerParams.map(param => param.schema),
          execParams => fn.execute(execParams, runtime),
          resultSchema,
        );
      }
      const nestedErrors = outerParams.map(nestedAnalysis => nestedAnalysis.errors || []);
      return {
        ...baseNode,
        parameters: outerParams,
        contextSchema,
        children: aliasNodes.concat(outerParams),
        schema: resultSchema,
        errors: errors.concat(...nestedErrors),
      };
    },
    refactor: (renames, replacements, ...args) => {
      const aliasStr = aliasList ? stringifyTokens(aliasList.tokens) : '';
      const parameters = fn ? fn.parameters : [];
      const refactoredParams = !paramList ? [] : paramList.items.map(({ item, prefix }, index) => {
        const paramDef = parameters[index];
        const prefixStr = stringifyTokens(prefix);
        // For higher-order "function" parameters, do not rename local context
        const paramRenames = { ...renames };
        if (paramDef && paramDef.type === 'function') {
          paramDef.parameters.forEach(({ name }) => {
            const alias = transformAlias(name);
            delete paramRenames[alias];
          });
        }
        const refactoredParam = item.refactor(paramRenames, {}, ...args);
        return prefixStr + refactoredParam;
      });
      const paramPrefix = paramList ? stringifyTokens(paramList.prefix) : '';
      const parenthesisEndStr = parenthesisEnd ? parenthesisEnd.text : '';
      return `${functionName}${aliasStr}${paramPrefix}${refactoredParams.join('')}${parenthesisEndStr}`;
    },
  };
};

const buildArrayItem = (anchor, leadingWs, node, trailingWs) => {
  let { offset } = leadingWs;
  if (offset == null) {
    offset = anchor.offset + anchor.text.length;
    // eslint-disable-next-line no-param-reassign
    leadingWs = { ...leadingWs, offset };
  }
  const tokens = [leadingWs];
  const children = [];
  let syntaxErrors;
  if (node) {
    tokens.push(...node.tokens);
    children.push(node);
  } else {
    syntaxErrors = [{
      message: 'Missing formula for the list item',
      offset,
      length: stringifyTokens(tokens).length,
    }];
  }
  if (trailingWs) {
    tokens.push(trailingWs);
  }
  const script = node ? node.script : 'undefined';
  const baseNode = buildBaseNode('item', script, tokens, children, syntaxErrors);
  baseNode.inverse = node ? node.inverse : null;
  baseNode.inverts = node ? node.inverts : null;
  const refactor = (...args) => {
    if (!node) {
      return leadingWs.text;
    }
    return `${leadingWs.text}${node.refactor(...args)}${trailingWs ? trailingWs.text : ''}`;
  };
  const analyze = (contextSchema, options) => makeBaseAnalysis(
    baseNode, contextSchema, undefined, undefined, options,
  );
  return { ...baseNode, analyze, refactor };
};

const buildArray = (prefixTokens, itemList, bracketEnd) => {
  if (bracketEnd && itemList.length && isExpecting(itemList[itemList.length - 1].item, ']')) {
    // If an inner token expects a right bracket, and this has one, then reject
    return null;
  }
  const tokens = prefixTokens.slice();
  itemList.forEach(({ item, prefix }) => {
    tokens.push(...prefix);
    tokens.push(...item.tokens);
  });
  if (bracketEnd) {
    tokens.push(bracketEnd);
  }
  const children = itemList.map(({ item }) => item);
  const syntaxErrors = bracketEnd ? null : [{ message: 'Missing closing bracket for the list' }];
  const script = `[${itemList.map(({ item }) => item.script).join(',')}]`;
  const baseNode = buildBaseNode('array', script, tokens, children, syntaxErrors);
  if (!bracketEnd) {
    baseNode.expects = ',]';
  } else if (!isExpecting(baseNode, ']')) {
    baseNode.expects = '';
  }
  const inverts = [];
  const childInverseScripts = children.map((childNode) => {
    if (childNode.inverse) {
      addUnionValues(inverts, childNode.inverts);
      return childNode.inverse;
    }
    return `["c",${childNode.script}]`;
  });
  if (inverts.length) {
    baseNode.inverse = `["a",${childInverseScripts.join(',')}]`;
    baseNode.inverts = inverts;
  }
  const analyze = getCombinedNodeAnalyzer(baseNode, children, (contextSchema, itemAnalyses) => {
    if (!itemAnalyses.length) {
      return { schema: getConstantSchema([]) };
    }
    const itemSchema = getUnionSchema(itemAnalyses.map(item => item.schema));
    const schema = evaluateSchemaEnumAndExamples(
      itemAnalyses.map(param => param.schema),
      itemValues => itemValues,
      { type: 'array', items: itemSchema },
    );
    return { schema };
  });
  const refactor = (renames, replacements, ...args) => {
    const refactoredItems = itemList.map(
      ({ item, prefix }) => stringifyTokens(prefix) + item.refactor(renames, {}, ...args),
    );
    const prefixStr = stringifyTokens(prefixTokens);
    const bracketEndStr = bracketEnd ? bracketEnd.text : '';
    return `${prefixStr}${refactoredItems.join('')}${bracketEndStr}`;
  };
  return { ...baseNode, analyze, refactor };
};

const buildEntry = (anchor, leadingWs, keyNode, separatorTokens, valueNode, trailingWs) => {
  let entryOffset = leadingWs.offset;
  let keyOffset = entryOffset;
  if (entryOffset == null) {
    entryOffset = anchor.offset + anchor.text.length;
    keyOffset = entryOffset;
    // eslint-disable-next-line no-param-reassign
    leadingWs = { ...leadingWs, offset: entryOffset };
  } else {
    keyOffset += leadingWs.text.length;
  }
  const tokens = [leadingWs];
  const children = [];
  const syntaxErrors = [];
  if (!valueNode && !keyNode) {
    // No key nor value
    syntaxErrors.push({
      message: 'Missing key-value pair from the object',
      offset: entryOffset,
      length: 0,
    });
  } else if (!keyNode) {
    // Value only, key is missing
    syntaxErrors.push({
      message: 'Missing object property name',
      offset: keyOffset,
      length: 0,
    });
    children.push(valueNode);
  } else if (!valueNode) {
    // Key only, value is missing
    let valueOffset = entryOffset;
    separatorTokens.forEach((token) => {
      if (token.offset != null) {
        valueOffset = token.offset + token.text.length;
      }
    });
    syntaxErrors.push({
      message: 'Missing object property value',
      offset: valueOffset,
      length: 0,
    });
    children.push(keyNode);
  } else {
    // Both key and value present
    children.push(keyNode, valueNode);
  }
  if (keyNode) { tokens.push(...keyNode.tokens); }
  tokens.push(...separatorTokens);
  if (valueNode) { tokens.push(...valueNode.tokens); }
  if (trailingWs) { tokens.push(trailingWs); }

  const keyScript = keyNode ? keyNode.script : '[""]';
  const valueScript = valueNode ? valueNode.script : 'undefined';
  const script = `${keyScript}:${valueScript}`;
  const baseNode = {
    ...buildBaseNode('entry', script, tokens, children, syntaxErrors),
    key: keyNode,
    value: valueNode,
  };
  const analyze = (contextSchema, options) => {
    const childAnalyses = [];
    const errors = [];
    let key;
    let value;
    if (keyNode) {
      key = keyNode.analyze(contextSchema, options);
      childAnalyses.push(key);
      errors.push(...key.errors);
    }
    if (valueNode) {
      value = valueNode.analyze(contextSchema, options);
      childAnalyses.push(value);
      errors.push(...value.errors);
    }
    return {
      ...baseNode,
      key,
      value,
      contextSchema,
      errors,
      children: childAnalyses,
    };
  };
  const refactor = (renames, replacements, ...args) => {
    const leadStr = leadingWs.text;
    const keyStr = keyNode ? keyNode.refactor(renames, {}, ...args) : '';
    const separatorStr = stringifyTokens(separatorTokens);
    const valueStr = valueNode ? valueNode.refactor(renames, {}, ...args) : '';
    const trailingStr = trailingWs ? trailingWs.text : '';
    return `${leadStr}${keyStr}${separatorStr}${valueStr}${trailingStr}`;
  };
  return { ...baseNode, refactor, analyze };
};

const buildObject = (prefixTokens, entryItemList, braceEnd) => {
  if (braceEnd && entryItemList.length && isExpecting(entryItemList[entryItemList.length - 1].entry, '}')) {
    // If an inner token expects a right brace, and this has one, then reject
    return null;
  }
  const tokens = prefixTokens.slice();
  entryItemList.forEach(({ prefix, entry }) => {
    tokens.push(...prefix);
    tokens.push(...entry.tokens);
  });
  if (braceEnd) {
    tokens.push(braceEnd);
  }
  const entryNodes = entryItemList.map(({ entry }) => entry);
  const syntaxErrors = braceEnd ? null : [{ message: 'Missing closing brace for the object' }];
  const script = `{${entryNodes.map(node => node.script).join(',')}}`;
  const baseNode = buildBaseNode('object', script, tokens, entryNodes, syntaxErrors);
  if (!braceEnd) {
    baseNode.expects = ',}';
  } else if (!isExpecting(baseNode, '}')) {
    baseNode.expects = '';
  }
  const inverts = [];
  const childInverseScripts = [];
  entryNodes.forEach((entryNode) => {
    const { key: keyNode, value: valueNode } = entryNode;
    if (keyNode && valueNode) {
      if (valueNode.inverse) {
        addUnionValues(inverts, valueNode.inverts);
        childInverseScripts.push(`${keyNode.script}:${valueNode.inverse}`);
      } else {
        childInverseScripts.push(`${keyNode.script}:["c",${valueNode.script}]`);
      }
    }
  });
  if (inverts.length) {
    baseNode.inverse = `["o",{${childInverseScripts.join(',')}}]`;
    baseNode.inverts = inverts;
  }
  return {
    ...baseNode,
    analyze: getCombinedNodeAnalyzer(baseNode, entryNodes, (contextSchema, entryAnalyses) => {
      const explicitKeys = [];
      const errors = [];
      const properties = {};
      const schema = { type: 'object', properties };
      let enumObj = {};
      entryAnalyses.forEach(({ key: keyAnalysis, value: valueAnalysis }) => {
        const keySchema = (keyAnalysis && keyAnalysis.schema) || { type: 'string' };
        const enumKeys = keySchema.enum;
        if (!enumKeys) {
          // TODO: Apply to the object schema
          enumObj = null;
          return;
        }
        // Ensure that no exact duplicate keys are defined
        if (enumKeys.length === 1) {
          const key = String(enumKeys[0]);
          if (includesValue(explicitKeys, key)) {
            errors.push({
              offset: keyAnalysis.offset,
              length: keyAnalysis.length,
              message: `The object already defines the key ${JSON.stringify(key)}`,
            });
          } else {
            explicitKeys.push(key);
          }
        } else {
          enumObj = null;
        }
        // Build the schemas of properties
        const valueSchema = (valueAnalysis && valueAnalysis.schema) || { type: 'value' };
        enumKeys.forEach((key) => {
          const property = properties[key];
          if (property == null || enumKeys.length === 1) {
            properties[key] = valueSchema;
          } else {
            properties[key] = getUnionSchema([property, valueSchema]);
          }
          const enumValues = valueSchema.enum;
          if (enumValues && enumValues.length === 1 && enumObj) {
            [enumObj[key]] = enumValues;
          } else {
            enumObj = null;
          }
        });
        // TODO: Define `additionalProperties`?
      });
      if (enumObj) {
        schema.enum = [enumObj];
        schema.examples = [enumObj];
      }
      return { schema, errors };
    }),
    refactor: (...args) => {
      const prefixStr = stringifyTokens(prefixTokens);
      const entryStr = entryItemList
        .map(({ prefix, entry }) => `${stringifyTokens(prefix)}${entry.refactor(...args)}`)
        .join('');
      const suffixStr = braceEnd ? braceEnd.text : '';
      return `${prefixStr}${entryStr}${suffixStr}`;
    },
  };
};

const equalityComparisonOperators = ['==', '===', '!=', '!=='];
const operatorInverses = {
  '+': 'ADD',
  '-': 'SUBTRACT',
  '*': 'MULTIPLY',
  '/': 'DIVIDE',
};
const comparisonOperators = equalityComparisonOperators.concat(['>', '>=', '<', '<=']);

const buildOperator = (leftSide, ws1, operatorToken, ws2, rightSide) => {
  const separatorTokens = [ws1, operatorToken, ws2];
  const operator = operatorToken.text;
  let script = `${leftSide.script}${operator}${rightSide.script}`;
  const addedFunctions = [];
  const opFn = operatorFunctions[operator];
  const opInvFn = operatorInverses[operator];
  if (opFn) {
    script = `${opFn.script}(${leftSide.script},${rightSide.script})`;
    addedFunctions.push(opFn.name);
  }
  if (opInvFn) {
    addedFunctions.push(opInvFn);
  }
  const children = [leftSide, rightSide];
  const tokens = [...leftSide.tokens, ...separatorTokens, ...rightSide.tokens];
  const baseNode = buildBaseNode('operator', script, tokens, children, null, addedFunctions);
  baseNode.operator = operator;
  if (opInvFn) {
    // Is inversible if exactly one of the operands is inversible and other one is a constant
    const invertIndexes = getInvertParameterIndexes(children, 1);
    if (invertIndexes.length === 1) {
      baseNode.inverse = `${opInvFn}.inv(${
        children.map((child, index) => (invertIndexes.includes(index) ? child.inverse : `["c",${child.script}]`)).join(',')
      })`;
      baseNode.inverts = children[invertIndexes[0]].inverts;
    }
  }
  if (leftSide.constants && rightSide.constants) {
    baseNode.constants = [];
    combinations([leftSide.constants, rightSide.constants]).forEach(([x, y]) => {
      const opResult = executeOperator(x, y, operator);
      if (!includesValue(baseNode.constants, opResult)) {
        baseNode.constants.push(opResult);
      }
    });
  }
  const { offset } = leftSide;
  const { length } = baseNode;
  const analyze = getCombinedNodeAnalyzer(baseNode, children, (_, operandAnalyses) => {
    const { schema: leftSchema } = operandAnalyses[0] || {};
    const { schema: rightSchema } = operandAnalyses[1] || {};
    const type1 = leftSchema && leftSchema.type;
    const type2 = rightSchema && rightSchema.type;
    const schema = evaluateSchemaEnumAndExamples(
      [leftSchema, rightSchema],
      ([operand1, operand2]) => executeOperator(operand1, operand2, operator),
    );
    if (operator === '+' && (type1 === 'string' || type2 === 'string')) {
      // A string concatenation -> result is a string
      return makeAnalysis({ type: 'string', ...schema });
    }
    if (operator === '||' || operator === '&&') {
      // Logical OR or AND operator -> union type of both sides
      return makeAnalysis({
        ...getUnionSchema([leftSchema, rightSchema]),
        ...schema,
      });
    }
    if (comparisonOperators.indexOf(operator) >= 0) {
      // Equality/inequality comparison results in boolean,
      // but warn if comparing unequal values.
      schema.type = 'boolean';
      if (!schema.enum) {
        schema.enum = [true, false];
      }
      if (!schema.examples) {
        schema.examples = [true, false];
      }
      const isEqualityComparison = equalityComparisonOperators.indexOf(operator) >= 0;
      if (!isEqualityComparison) {
        if (type1 && type2 && type1 !== type2) {
          return makeAnalysis(schema, [{
            offset,
            length,
            message: `Comparing ${stringifyType(type1)} and ${stringifyType(type2)} might be a mistake`,
          }]);
        }
      } else {
        const options = { tolerant: isEqualityComparison };
        const leftToRightErrors = getSchemaAssignmentErrors(leftSchema, rightSchema, options);
        const rightToLeftErrors = getSchemaAssignmentErrors(rightSchema, leftSchema, options);
        if (leftToRightErrors.length && rightToLeftErrors.length) {
          if (type1 && type2 && type1 !== type2) {
            return makeAnalysis(schema, [{
              offset,
              length,
              message: `Comparing ${stringifyType(type1)} and ${stringifyType(type2)} might be a mistake`,
            }]);
          }
          // Neither type is assignable to another, so comparison is likely a mistake
          const errors = leftToRightErrors.length < rightToLeftErrors.length
            ? leftToRightErrors : rightToLeftErrors;
          return makeAnalysis(schema, errors.map(error => ({ offset, length, ...error })));
        }
      }
      return makeAnalysis(schema);
    }
    if (type1 === 'number' && type2 === 'number') {
      // Calculating two numbers
      return makeAnalysis({ type: 'number', ...schema });
    }
    if (!type1 && !type2) {
      // Calculating two unkown values
      return makeAnalysis(schema);
    }
    // Otherwise calculating two incompatible values
    const knownTypes = [type1, type2].filter(type => !!type).map(type => stringifyType(type));
    return makeAnalysis(schema, [{
      offset,
      length,
      message: `Invalid "${operator}" operation with ${knownTypes.join(' and ')}`,
    }]);
  });
  const refactor = (renames, replacements, ...args) => {
    const separator = stringifyTokens(separatorTokens);
    const subReplacements = operator === '&&' || operator === '||' ? replacements : {};
    const newLeftSide = leftSide.refactor(renames, subReplacements, ...args);
    const newRightSide = rightSide.refactor(renames, subReplacements, ...args);
    return `${newLeftSide}${separator}${newRightSide}`;
  };
  return {
    ...baseNode,
    analyze,
    refactor,
  };
};

const unaryInverses = {
  '!': 'NOT',
  '-': 'OPPOSITE',
};

function buildUnary(operatorToken, operand) {
  const operator = operatorToken.text;
  const children = [operand];
  const script = `${operator}${operand.script}`;
  const unaryInvFn = unaryInverses[operator];
  const addedFunctions = unaryInvFn ? [unaryInvFn] : undefined;
  const baseNode = buildBaseNode('unary', script, [operatorToken, ...operand.tokens], children, null, addedFunctions);
  baseNode.operator = operator;
  if (operand.constants) {
    baseNode.constants = operand.constants.map(val => executeUnary(val, operator));
  }
  if (unaryInvFn) {
    const invertIndexes = getInvertParameterIndexes(children, 1);
    if (invertIndexes[0] === 0) {
      baseNode.inverse = `${unaryInvFn}.inv(${operand.inverse})`;
      baseNode.inverts = operand.inverts;
    }
  }
  const { offset } = operatorToken;
  const analyze = getCombinedNodeAnalyzer(baseNode, children, (_, [{ schema: operandSchema }]) => {
    const { type } = operandSchema;
    const schema = evaluateSchemaEnumAndExamples(
      [operandSchema], ([value]) => executeUnary(value, operator),
    );
    if (operator === '!') {
      // Logical NOT
      return makeAnalysis({ type: 'boolean', ...schema });
    }
    if (type !== 'number' && type) {
      // Attempting to use plus/minus in front of non-number type
      return makeAnalysis({ type: 'number', ...schema }, [{
        offset,
        length: operator.length,
        message: `Using "${operator}" in front of ${stringifyType(type)} might be a mistake`,
      }]);
    }
    return makeAnalysis({ type: 'number', ...schema });
  });
  const refactor = (renames, replacements, ...args) => (
    `${operator}${operand.refactor(renames, {}, ...args)}`
  );
  return {
    ...baseNode,
    analyze,
    refactor,
  };
}

const executeTernary = ([x, y, z]) => (x ? y : z);
const buildConditional = (cond, ternaryIf, result1, ternaryElse, result2) => {
  const tokens = cond.tokens.concat(
    ternaryIf, result1.tokens, ternaryElse, result2.tokens,
  );
  const children = [cond, result1, result2];
  const script = `${cond.script}?${result1.script}:${result2.script}`;
  const baseNode = buildBaseNode('conditional', script, tokens, children);
  const analyze = getCombinedNodeAnalyzer(baseNode, children, (contextSchema, params) => {
    const [condAnalysis, truthyAnalysis, falsyAnalysis] = params;
    const conditionErrors = getSchemaAssignmentErrors(
      condAnalysis.schema, { type: 'boolean' },
    );
    const errors = conditionErrors.map(error => ({
      offset: cond.offset,
      length: cond.length,
      ...error,
    }));
    const schema = evaluateSchemaEnumAndExamples(
      params.map(param => param.schema),
      executeTernary,
      getUnionSchema([truthyAnalysis.schema, falsyAnalysis.schema]),
    );
    return makeAnalysis(schema, errors);
  });
  const refactor = (renames, replacements, ...args) => {
    const newCond = cond.refactor(renames, {}, ...args);
    const newResult1 = result1.refactor(renames, replacements, ...args);
    const newResult2 = result2.refactor(renames, replacements, ...args);
    return `${newCond}${stringifyTokens(ternaryIf)}${newResult1}${stringifyTokens(ternaryElse)}${newResult2}`;
  };
  return {
    ...baseNode,
    analyze,
    refactor,
  };
};

const buildContextAccess = (tokens) => {
  const rootName = stringifyTokens(tokens);
  const rootNameJson = JSON.stringify(rootName);
  const baseNode = {
    ...buildBaseNode('contextAccess', rootName, tokens),
    inverse: `["r",${rootName},${rootNameJson}]`,
    inverts: [[rootName]],
    term: tokens,
    name: rootName,
    reference: [rootName],
    dependencies: [[rootName]],
  };
  return {
    ...baseNode,
    analyze: (contextSchema, options) => {
      const schema = contextSchema[rootName];
      const errors = schema ? [] : [{
        offset: baseNode.offset,
        length: baseNode.length,
        message: `Unknown reference ${rootNameJson}`,
      }];
      return makeBaseAnalysis(baseNode, contextSchema, schema || {}, errors, options);
    },
    refactor: (renames) => {
      const renamed = renames[rootName];
      if (typeof renamed !== 'string') {
        return rootName;
      }
      if (!/^[a-z_$][a-z0-9_$]*$/i.test(renamed)) {
        throw new Error(`Cannot rename context accessor to an invalid name ${JSON.stringify(renamed)}`);
      }
      return renamed;
    },
  };
};

const buildIdentifier = (identifierToken) => {
  const name = identifierToken.text;
  const tokens = [identifierToken];
  const baseNode = {
    ...buildBaseNode('identifier', name, tokens),
    name,
    term: tokens,
    constants: [name],
  };
  return {
    ...baseNode,
    analyze: (contextSchema, options) => makeBaseAnalysis(
      baseNode, contextSchema, getConstantSchema(name), undefined, options,
    ),
    refactor: (renames, replacements) => {
      const replacement = replacements[name];
      if (typeof replacement !== 'string') {
        return name;
      }
      if (!/^[a-z_$][a-z0-9_$]*$/i.test(replacement)) {
        throw new Error(`Cannot rename identifier to an invalid name ${JSON.stringify(replacement)}`);
      }
      return replacement;
    },
  };
};

const buildMemberAccess = (operand, dotToken, accessor) => {
  const name = accessor ? accessor.name : '';
  const accessOffset = accessor ? accessor.offset : dotToken.offset + dotToken.text.length;
  const accessLength = accessor ? accessor.length : 0;
  const operandReference = operand.reference;
  const reference = operandReference && operandReference.concat(name);
  const tokens = [...operand.tokens, dotToken];
  const children = [operand];
  if (accessor) {
    tokens.push(...accessor.tokens);
    children.push(accessor);
  }
  const syntaxErrors = accessor ? null : [{ message: 'Missing property name' }];
  const nameScript = JSON.stringify(name);
  const script = `LOOKUP(${operand.script},${nameScript})`;
  let baseNode = buildBaseNode('memberAccess', script, tokens, children, syntaxErrors, ['LOOKUP']);
  if (reference) {
    let { dependencies } = operand;
    // Make reference and related dependency more explicit
    // Remove the existing dependency
    const depIndex = indexOfValue(dependencies, operandReference);
    dependencies = dependencies.slice();
    dependencies.splice(depIndex, 1);
    // Re-add the more explicit dependency
    if (!includesValue(dependencies, reference)) {
      dependencies.push(reference);
    }
    baseNode = { ...baseNode, reference, dependencies };
  }
  if (operand.term) {
    baseNode = { ...baseNode, term: baseNode.tokens };
  }
  if (operand.inverse) {
    baseNode.inverse = `LOOKUP.inv(${operand.inverse},["c",${nameScript}])`;
    baseNode.inverts = reference ? [reference] : operand.inverts;
  }
  const analyze = getCombinedNodeAnalyzer(baseNode, children, (contextSchema, analyses) => {
    const operandSchema = analyses[0].schema;
    const accessorSchema = analyses[1] ? analyses[1].schema : { type: 'string' };
    const accessorResult = resolveObjectMemberAccessor(operandSchema, accessorSchema);
    return makeAnalysis(
      accessorResult.schema || { type: 'undefined' },
      accessorResult.errors.map(error => ({
        ...error,
        offset: accessOffset,
        length: accessLength,
      })),
    );
  });
  const refactor = (renames, replacements, ...args) => {
    const newOperand = operand.refactor(renames, {}, ...args);
    const renamed = !reference ? null : reference.reduce(
      (mapping, key) => (mapping != null && typeof mapping === 'object' ? mapping[key] : null),
      renames,
    );
    if (typeof renamed !== 'string') {
      return `${newOperand}.${name}`;
    }
    const newAccessor = /^[a-z_$][a-z0-9_$]*$/i.test(renamed)
      ? `.${renamed}` : `[${JSON.stringify(renamed)}]`;
    return newOperand + newAccessor;
  };
  return { ...baseNode, analyze, refactor };
};

const buildComputedMemberAccess = (operand, startBracket, startWs, accessor, endWs, endBracket) => {
  const { constants } = accessor;
  const operandReference = operand.reference;
  const accessorValue = constants && constants.length === 1 ? constants[0] : null;
  const accessOffset = accessor ? accessor.offset : startBracket.offset + startBracket.text.length;
  const accessLength = accessor ? accessor.length : stringifyTokens([startWs, endWs]).length;
  const tokens = [
    ...operand.tokens, startBracket, startWs, ...accessor.tokens, endWs, endBracket,
  ];
  const children = [operand, accessor];
  const script = `LOOKUP(${operand.script},${accessor.script})`;
  let baseNode = buildBaseNode('memberAccess', script, tokens, children, null, ['LOOKUP']);
  const reference = operandReference && (typeof accessorValue === 'string' || typeof accessorValue === 'number')
    ? operandReference.concat(accessorValue) : null;
  if (reference) {
    // Make reference and related dependency more explicit
    let { dependencies } = baseNode;
    // Remove the existing dependency
    const depIndex = indexOfValue(dependencies, operandReference);
    dependencies = dependencies.slice();
    dependencies.splice(depIndex, 1);
    // Re-add the more explicit dependency
    if (!includesValue(dependencies, reference)) {
      dependencies.push(reference);
    }
    baseNode = { ...baseNode, reference, dependencies };
  }
  if (operand && operand.term && accessor && accessor.term) {
    baseNode = { ...baseNode, term: baseNode.tokens };
  }
  if (operand.inverse) {
    baseNode.inverse = `LOOKUP.inv(${operand.inverse},["c",${accessor.script}])`;
    baseNode.inverts = reference ? [reference] : operand.inverts;
  }
  const analyze = getCombinedNodeAnalyzer(baseNode, children, (contextSchema, analyses) => {
    const [{ schema: operandSchema }, { schema: accessorSchema }] = analyses;
    const accessorResult = resolveObjectMemberAccessor(operandSchema, accessorSchema);
    return makeAnalysis(
      accessorResult.schema || { type: 'undefined' },
      accessorResult.errors.map(error => ({
        ...error,
        offset: accessOffset,
        length: accessLength,
      })),
    );
  });
  const refactor = (renames, replacements, ...args) => {
    const newOperand = operand.refactor(renames, replacements, ...args);
    const accessorReplacements = operandReference && operandReference.reduce(
      (mapping, key) => (mapping != null && typeof mapping === 'object' ? mapping[key] : null),
      renames,
    );
    const newAccessor = accessor.refactor(renames, accessorReplacements || {}, ...args);
    const startBracketStr = startBracket ? startBracket.text : '';
    const endBracketStr = endBracket ? endBracket.text : '';
    return `${newOperand}${startBracketStr}${startWs.text}${newAccessor}${endWs.text}${endBracketStr}`;
  };
  return { ...baseNode, analyze, refactor };
};

function buildGroup(parenthesisStart, leadingWs, node, trailingWs, parenthesisEnd) {
  const tokens = [parenthesisStart];
  let syntaxErrors = null;
  if (leadingWs) {
    tokens.push(leadingWs);
  }
  if (node) {
    tokens.push(...node.tokens);
  } else {
    syntaxErrors = [{ message: 'Incomplete group expression' }];
  }
  if (trailingWs) {
    tokens.push(trailingWs);
  }
  if (parenthesisEnd) {
    tokens.push(parenthesisEnd);
  } else if (node) {
    syntaxErrors = [{ message: 'Missing closing parenthesis for the group' }];
  }
  const children = node ? [node] : [];
  const script = node ? `(${node.script})` : '(undefined)';
  const baseNode = buildBaseNode('group', script, tokens, children, syntaxErrors);
  baseNode.inverse = node ? node.inverse : null;
  baseNode.inverts = node ? node.inverts : null;
  if (!parenthesisEnd) {
    baseNode.expects = ')';
  } else if (!isExpecting(baseNode, ')')) {
    baseNode.expects = '';
  }
  const analyze = (contextSchema, options) => makeBaseAnalysis(
    baseNode, contextSchema, undefined, undefined, options,
  );
  const refactor = (...args) => {
    const parenthesisStartStr = parenthesisStart ? parenthesisStart.text : '';
    const parenthesisEndStr = parenthesisEnd ? parenthesisEnd.text : '';
    const leadingWsStr = leadingWs ? leadingWs.text : '';
    const trailingWsStr = trailingWs ? trailingWs.text : '';
    const nodeStr = node ? node.refactor(...args) : '';
    return `${parenthesisStartStr}${leadingWsStr}${nodeStr}${trailingWsStr}${parenthesisEndStr}`;
  };
  return {
    ...baseNode,
    analyze,
    refactor,
  };
}

function buildConstant(value, tokens) {
  const script = stringifyTokens(tokens);
  const baseNode = {
    ...buildBaseNode('constant', script, tokens),
    value,
    term: tokens,
    constants: [value],
  };
  return {
    ...baseNode,
    analyze: (contextSchema, options) => makeBaseAnalysis(
      baseNode, contextSchema, getConstantSchema(value), undefined, options,
    ),
    refactor: (renames, replacements) => {
      if (replacements && typeof value === 'string') {
        const replacement = replacements[value];
        if (replacement != null && typeof replacement !== 'object') {
          return JSON.stringify(replacement);
        }
      }
      return script;
    },
  };
}

function buildReservedKeyword(tokens) {
  const keyword = stringifyTokens(tokens);
  if (valueKeywords.indexOf(keyword) >= 0) {
    return null;
  }
  const syntaxErrors = tokens.map(token => ({
    message: `Invalid syntax: Unexpected reserved keyword ${JSON.stringify(token.text)}`,
    offset: token.offset,
    length: token.text.length,
  }));
  const baseNode = {
    ...buildBaseNode('error', keyword, tokens, [], syntaxErrors),
    term: tokens,
  };
  const schema = { type: 'value' };
  return {
    ...baseNode,
    analyze: (contextSchema, options) => makeBaseAnalysis(
      baseNode, contextSchema, schema, undefined, options,
    ),
    refactor: () => keyword,
  };
}

function validateNotExpecting(node, ...chars) {
  if (chars.some(char => isExpecting(node, char))) {
    return null;
  }
  return node;
}
function validateNoFunctionName(node) {
  const { tokens } = node;
  if (tokens[tokens.length - 1].type === 'functionName') {
    return null;
  }
  return node;
}

module.exports.buildAlias = buildAlias;
module.exports.buildAliasList = buildAliasList;
module.exports.buildArray = buildArray;
module.exports.buildArrayItem = buildArrayItem;
module.exports.buildComputedMemberAccess = buildComputedMemberAccess;
module.exports.buildConditional = buildConditional;
module.exports.buildConstant = buildConstant;
module.exports.buildContextAccess = buildContextAccess;
module.exports.buildEntry = buildEntry;
module.exports.buildError = buildError;
module.exports.buildFormula = buildFormula;
module.exports.buildFunctionCall = buildFunctionCall;
module.exports.buildGroup = buildGroup;
module.exports.buildIdentifier = buildIdentifier;
module.exports.buildMemberAccess = buildMemberAccess;
module.exports.buildObject = buildObject;
module.exports.buildOperator = buildOperator;
module.exports.buildParameter = buildParameter;
module.exports.buildParameterList = buildParameterList;
module.exports.buildReservedKeyword = buildReservedKeyword;
module.exports.buildSyntaxError = buildSyntaxError;
module.exports.buildUnary = buildUnary;
module.exports.executeOperator = executeOperator;
module.exports.isConstantStructure = isConstantStructure;
module.exports.validateNoFunctionName = validateNoFunctionName;
module.exports.validateNotExpecting = validateNotExpecting;
