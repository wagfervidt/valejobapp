const fs = require('fs-extra');
const path = require('path');
const xml2js = require("xml2js");
const { MDK_CONFIG_JSON, logInfo} = require('../utils');

const ENALBE_LOG = false;
let instance;
class Checker {

    constructor(args) {
        this.checkArgs = args;
        instance = this;
        instance._prjConfig = {};
    }
    /**
     * This is the main entry point into the check metadata files
     * mdk check --target backend
     * 
     */
    check() {
        return instance._getProjectInfo()
            .then(instance._validate)
            .then(instance._checkApp)
            .then(instance._clearLinks)
            .then(instance._parseFiles)
            .then(instance._setProjectInfo)
            .then(() => {
                return true;
            })
            .catch(error => {
                logInfo(error);
                return Promise.reject(error);
            });
    }


    _getProjectInfo() {
        return new Promise(function (resolve, reject) {
            //resolve(true);
            let sPojectInfoFile = path.join(instance.checkArgs.project(), MDK_CONFIG_JSON);
            if (fs.existsSync(sPojectInfoFile)) {
                try {
                    instance._prjConfig = fs.readJSONSync(sPojectInfoFile);
                } catch (e) {
                    reject("Failed to parse .project.json with error "+e.message);
                }
            } 
            resolve(true);
        });
    }
    

    _validate() {
        return new Promise(function (resolve, reject) {
            if (instance._prjConfig["LCAP"] && instance._prjConfig["LCAP"]["Service"] && instance._prjConfig["LCAP"]["Service"].length>0) {
                let steps = [];
                instance._originalSetting = JSON.stringify(instance._prjConfig["LCAP"]["Service"], null,"\t");
                instance._prjConfig["LCAP"]["Service"].forEach((oService)=>{
                    if (oService["mdk"]) {
                        const xmlFileName = oService["mdk"].replace(/(\\|\/)/g, path.sep).split(path.sep).pop().replace(".service",".xml");
                        const xmlFullPath = path.join(instance.checkArgs.project(),"Services", `.${xmlFileName}`);
                        steps.push(instance._getXmlDomByPath(xmlFullPath, oService));
                    }
                });
                return Promise.all(steps).then(()=> resolve(true));
            }
            reject(`No Lcap service info from ${MDK_CONFIG_JSON}`);
        });
    }

    _clearLinks() {
        return new Promise(function (resolve, reject) {
            let aService = instance._prjConfig["LCAP"]["Service"] ? instance._prjConfig["LCAP"]["Service"] : [];
            aService.forEach((service)=> {
                service["links"]=[];
            })
            resolve(true);
        });
    }

    _setProjectInfo() {
        return new Promise(function (resolve, reject) {
            instance._prjConfig["LCAP"]["Service"].forEach((oService) => delete oService.xml)
            const sNewSettings = JSON.stringify(instance._prjConfig["LCAP"]["Service"], null,"\t");
            if (sNewSettings !== instance._originalSetting) {
                try {
                    let sPojectInfoFile = path.join(instance.checkArgs.project(), MDK_CONFIG_JSON);
                    fs.writeFileSync(sPojectInfoFile, JSON.stringify(instance._prjConfig, null,"\t"));
                } catch (e) {
                    reject("Failed to set .project.json with error "+e.message);
                } 
            }
            console.log(sNewSettings)
            resolve(true);     
        });
    }

    _parseFiles() {
        let steps = [];
        steps.push(instance._parseFilesHelper("Pages",".page"));
        steps.push(instance._parseFilesHelper("Actions",".action"));
        return Promise.all(steps);
    }

    _parseFilesHelper(root, ext) {
        let targetRoot = path.join(instance.checkArgs.project(),root);
        let steps = [];
        if (fs.existsSync(targetRoot)) {
            const aFiles = instance._getAllFiles(targetRoot, ext);
            for (let i=0; i<aFiles.length; i++) {
                if (ENALBE_LOG) console.log('checking file '+aFiles[i]);
                steps.push(instance._parseOneFile(aFiles[i]));
            }  
        } 
        return Promise.all(steps);
    }

    _parseOneFile(sFile) {
        if (fs.existsSync(sFile)) {
            try {
                const oJson = fs.readJSONSync(sFile);
                instance._pickTarget(oJson, sFile);
            } catch (e) {
                throw new Error(`Failed to parse ${sFile} with error ${e.message}`);
            }
        } 
    }

    _pickTarget(oJson, sFile) {
        if (oJson){ 
            if (oJson["Target"]||oJson["DesignTimeTarget"]) {
                instance._updateTarget(oJson["Target"] ? oJson["Target"] : oJson["DesignTimeTarget"], sFile)
            } else {
                for (var key in oJson) {
                    if (oJson.hasOwnProperty(key) && typeof oJson[key] === "object") {
                        this._pickTarget(oJson[key], sFile);
                    }
                }
            }
        }
    }

    _updateTarget(oTarget, sFile){
        if (oTarget["Service"] && oTarget["EntitySet"]) {
            const sService = oTarget["Service"];
            const sRelativeFilePath = instance._getRelativePath(sFile);
            let aService = instance._prjConfig["LCAP"]["Service"] ? instance._prjConfig["LCAP"]["Service"] : [];
            let oService = aService.find((service) => (service["mdk"] && sService.indexOf(service["mdk"])>-1));
            const sEntity = instance._getEntityByTarget(oTarget, oService["xml"]);
            if (oService && sEntity) {
                let aLinks = oService["links"] ? oService["links"] : [];
                let oLink = aLinks.find((link) => link.entity === sEntity);
                if (oLink) {
                    oLink.files = oLink.files ? oLink.files : [];
                    oLink.files.push(sRelativeFilePath);
                } else {
                    aLinks.push({"entity": sEntity, "files":[sRelativeFilePath]});
                }
                oService["links"] = aLinks;
            }
        }
        
    }

    _getRelativePath(sFile) {
        const root = instance.checkArgs.project();
        let sProject;
        let aPath = root.split(path.sep);
        if (root.endsWith(path.sep)) {
            sProject = aPath[aPath.length-2];
        } else {
            sProject = aPath[aPath.length-1];
        }
        if (sFile.indexOf(root)===0) {
            return path.join(sProject, sFile.substring(root.length));
        } else {
            return sFile;
        }
    }

    _getAllFiles(dirPath, ext, arrayOfFiles) {
        const files = fs.readdirSync(dirPath)
      
        arrayOfFiles = arrayOfFiles || []
      
        files.forEach(function(file) {
          if (fs.statSync(dirPath + path.sep + file).isDirectory()) {
            arrayOfFiles = instance._getAllFiles(dirPath + path.sep + file, ext, arrayOfFiles)
          } else {
            if (file.endsWith(ext)){
                arrayOfFiles.push(path.join(dirPath, path.sep, file))
            }
          }
        })
        return arrayOfFiles
      }

    _getEntityByTarget(oTarget, oXml) {
        const sSet = oTarget["EntitySet"];
        if (oXml) {
            let aSchema;
            if (oXml["edmx:Edmx"]) {
                aSchema = oXml["edmx:Edmx"]["edmx:DataServices"][0].Schema;
            } else {
                aSchema = oXml.Edmx.DataServices[0].Schema;
            }

            if (aSchema) {
                for (var i = 0; i < aSchema.length; i++) {
                    var aEntityContainer = aSchema[i].EntityContainer;
                    if (aEntityContainer) {
                        let oEntitySet = aEntityContainer[0].EntitySet.find((oEntitySet) => oEntitySet.$.Name === sSet);
                        if (oEntitySet) {
                            return oEntitySet.$.EntityType;
                        }
                    }
                }
            }
        }
        return "";
    }

     _getXmlDomByPath(sPath, oService) {
        return new Promise(function (resolve, reject) {
            if (fs.existsSync(sPath)) {
                const sContent = fs.readFileSync(sPath).toString();
                const parser = new xml2js.Parser();
                parser.parseString(sContent, function(err, result) {
                    if (err) {
                        reject(err);
                    } else {
                        oService["xml"] = result;
                        resolve(result);
                    }
                });   
            } else {
                reject(`Failed to find xml ${sPath}`);
            }
        });
    }

}
exports.Checker = Checker;