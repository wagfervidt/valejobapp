

const { parseDateTime } = require('./datetime');

function FV(rate, periods, amount, current, isOnBeginning) {
  let result;
  if (rate === 0) {
    result = current + amount * periods;
  } else {
    const term = (1 + rate) ** periods;
    result = (isOnBeginning)
      ? current * term + amount * (1 + rate) * (term - 1) / rate
      : current * term + amount * (term - 1) / rate;
  }
  return -result;
}

function DDB(cost, salvage, life, period, factor) {
  let result;
  let percent;
  let oldValue;

  percent = factor / life;
  if (percent >= 1) {
    percent = 1;
    if (period === 1) {
      oldValue = cost;
    } else {
      oldValue = 0;
    }
  } else {
    oldValue = cost * ((1 - percent) ** (period - 1));
  }
  const newValue = cost * ((1 - percent) ** period);

  if (newValue < salvage) {
    result = oldValue - salvage;
  } else {
    result = oldValue - newValue;
  }
  if (result < 0) {
    result = 0;
  }
  return result;
}

function PMT(rate, periods, present, future, isOnBeginning) {
  let result = null;
  if (rate === 0) {
    result = (present + future) / periods;
  } else {
    const term = (1 + rate) ** periods;
    if (isOnBeginning) {
      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
    } else {
      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
    }
  }
  return -result;
}

function IPMT(rate, period, periods, present, future, isOnBeginning) {
  if (periods < 0) {
    return null;
  }

  if (period < 1 || period > periods) {
    return null;
  }

  const payment = PMT(rate, periods, present, future, isOnBeginning);

  let interest;
  if (period === 1) {
    interest = isOnBeginning ? 0 : -present;
  } else {
    interest = isOnBeginning
      ? FV(rate, period - 2, payment, present, true) - payment
      : FV(rate, period - 1, payment, present, false);
  }
  return interest * rate;
}

function ISPMT(rate, period, periods, value) {
  return value * rate * (period / periods - 1);
}

function MIRR(values, finrate, rinrate) {
  const { length: n } = values;
  let fvpcfs = 0;
  let pvncfs = 0;
  let incomeDetected = false;
  let outcomeDetected = false;

  values.forEach((item, i) => {
    if (item < 0) {
      pvncfs += item / ((1 + finrate) ** i);
      incomeDetected = true;
    } else {
      fvpcfs += item * ((1 + rinrate) ** (n - i - 1));
      outcomeDetected = true;
    }
  });

  if (!incomeDetected || !outcomeDetected) {
    return null;
  }

  const mirr = ((fvpcfs / -pvncfs) ** (1 / (n - 1))) - 1;
  return mirr;
}

function NPER(rate, payment, present, future, type) {
  const typeValue = (type) ? 1 : 0;

  const num = payment * (1 + rate * typeValue) - future * rate;
  const den = (present * rate + payment * (1 + rate * typeValue));

  return Math.log(num / den) / Math.log(1 + rate);
}

function NOMINAL(rate, periods) {
  const periodsRounded = Math.trunc(periods);
  if (rate <= 0 || periodsRounded < 1) {
    return null;
  }
  return (((rate + 1) ** (1 / periodsRounded)) - 1) * periodsRounded;
}

function NPV(rate, cashFlows) {
  return cashFlows.reduce((total, item, i) => total + (item / (((1 + rate) ** (i + 1)))), 0);
}

function INVESTMENT_PDURATION(rate, present, future) {
  if (rate <= 0) {
    return null;
  }
  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
}

function PPMT(rate, period, periods, present, future, type) {
  if (periods < 0) {
    return null;
  }
  if (period < 1 || period > periods) {
    return null;
  }

  return PMT(rate, periods, present, future, type)
    - IPMT(rate, period, periods, present, future, type);
}

function PV(rate, periods, payment, future, type) {
  if (rate) {
    return (((1 - ((1 + rate) ** periods)) / rate)
      * payment * (1 + rate * type) - future)
      / ((1 + rate) ** periods);
  }
  return -payment * periods - future;
}

function RRI(periods, present, future) {
  if (periods === 0 || present <= 0 || future < 0) {
    return null;
  }
  return ((future / present) ** (1 / periods)) - 1;
}

function SLN(cost, salvage, life) {
  if (life === 0) {
    return null;
  }
  return (cost - salvage) / life;
}

function SYD(cost, salvage, life, period) {
  if (life === 0) {
    return null;
  }
  if (period < 1 || period > life) {
    return null;
  }

  const periodRounded = Math.trunc(period);
  return ((cost - salvage) * (life - periodRounded + 1) * 2) / (life * (life + 1));
}

function VDB(cost, salvage, life, life1, period, factor) {
  let result = 0;
  const fIntEnd = Math.ceil(period);
  const nLoopEnd = fIntEnd;

  let fTerm;
  let fLia = 0;
  let fRestwert = cost - salvage;
  let bNowLia = false;

  for (let i = 1; i <= nLoopEnd; i++) {
    if (!bNowLia) {
      const fDDB = DDB(cost, salvage, life, i, factor);
      fLia = fRestwert / (life1 - (i - 1));

      if (fLia > fDDB) {
        fTerm = fLia;
        bNowLia = true;
      } else {
        fTerm = fDDB;
        fRestwert -= fDDB;
      }
    } else {
      fTerm = fLia;
    }
    if (i === nLoopEnd) {
      fTerm *= (period + 1.0 - fIntEnd);
    }
    result += fTerm;
  }
  return result;
}


function XNPV(rate, amounts, dates) {
  if (amounts.length !== dates.length) {
    return null;
  }
  if (!amounts.length) {
    return null;
  }
  let result = 0;
  const baseDate = (typeof dates[0] === 'string') ? parseDateTime(dates[0]) : null;
  if (baseDate == null || !baseDate.isValid()) {
    return null;
  }

  for (let i = 0; i < amounts.length; i++) {
    const amount = amounts[i];
    if (!Number.isFinite(amount)) {
      return null;
    }
    const currentDate = (typeof dates[i] === 'string') ? parseDateTime(dates[i]) : null;
    if (currentDate == null || !currentDate.isValid()) {
      return null;
    }

    const diff = currentDate.startOf('day').diff(baseDate.startOf('day'), 'days', true);

    if (diff < 0) {
      return null;
    }
    result += amounts[i] / ((1 + rate) ** (diff / 365));
  }

  return result;
}

module.exports.DDB = DDB;
module.exports.FV = FV;
module.exports.IPMT = IPMT;
module.exports.ISPMT = ISPMT;
module.exports.MIRR = MIRR;
module.exports.NOMINAL = NOMINAL;
module.exports.NPER = NPER;
module.exports.NPV = NPV;
module.exports.INVESTMENT_PDURATION = INVESTMENT_PDURATION;
module.exports.PMT = PMT;
module.exports.PPMT = PPMT;
module.exports.PV = PV;
module.exports.RRI = RRI;
module.exports.SLN = SLN;
module.exports.SYD = SYD;
module.exports.VDB = VDB;
module.exports.XNPV = XNPV;
