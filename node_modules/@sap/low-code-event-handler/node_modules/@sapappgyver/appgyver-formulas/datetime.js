const moment = require('moment-timezone');

const supportedDateTimeFormats = [moment.ISO_8601, moment.RFC_2822];
/**
 * This regexp is used for faster parsing. It assumes that the date/time is in
 * valid standard format. If the string does not match, only then we fall
 * back to MomentJS's slower but better parsing.
 * NOTE: For seconds, we must also support leap second 60.
 * Also, milliseconds are optional, but if present, there must be exactly 3 digits
 * (otherwise the calculation would yield incorrect value).
 */
const standardFormatRegex = /^(\d\d\d\d)-([0-1]\d)-([0-3]\d)[t\s]([0-2]\d):([0-5]\d):([0-6]\d)(?:\.(\d\d\d))?z$/i;

/**
 * Attempts to parse the given date/time string as quickly as possible to an
 * array of date components: [year, month, day, hour, minute, second, millisecond].
 * This kind of date is always assumed to be in UTC. If the given string is not EXACTLY
 * an standard ISO string format, ending with `Z`, then this returns null.
 * @param {string} str ISO-formateed date/time string in UTC
 */
function parseDateTimeArray(str) {
  // Faster parsing for date-time strings in the recommended standard ISO format:
  const match = typeof str === 'string' && standardFormatRegex.exec(str);
  if (!match) {
    return null;
  }
  const years = +match[1];
  const months = +match[2] - 1; // 0 based
  const days = +match[3];
  const hours = +match[4];
  const minutes = +match[5];
  const seconds = +match[6];
  const milliseconds = match[7] ? +match[7] : 0;
  return [years, months, days, hours, minutes, seconds, milliseconds];
}

/**
 * Parses a date/time string and returns a moment object.
 * The returned moment will be in the original timezone if the string contains an offset.
 * If the string does not contain a timezone, then it is assumed to be UTC, for consistency.
 * @param {string} str date/time string
 * @param {string} dateFormat optional specific format to use
 */
function parseDateTime(str, dateFormat) {
  if (typeof str === 'number') {
    return moment.tz(str, 'UTC');
  }
  if (typeof str !== 'string') {
    return moment(NaN);
  }
  if (!dateFormat) {
    const array = parseDateTimeArray(str);
    if (array) {
      return moment.utc(array);
    }
  }
  if (dateFormat && typeof dateFormat === 'string' && !dateFormat.includes('Z')) {
    return moment.utc(str, dateFormat, true);
  }
  return moment.parseZone(str, dateFormat || supportedDateTimeFormats, true);
}

/**
 * Formats an date/time array (as returned by parseDateTimeArray) in the correct
 * string date/time format, same than formatMoment.
 * @param {array} array date/time components (UTC)
 */
function formatDateTimeArray(array) {
  const years = String(array[0]);
  const months = String(array[1] + 1).padStart(2, '0');
  const days = String(array[2]).padStart(2, '0');
  const hours = String(array[3]).padStart(2, '0');
  const minutes = String(array[4]).padStart(2, '0');
  const seconds = String(array[5]).padStart(2, '0');
  const fractions = array[6] ? `.${String(array[6] % 1000).slice(-3).padStart(3, '0')}` : '';
  return `${years}-${months}-${days}T${hours}:${minutes}:${seconds}${fractions}Z`;
}

/**
 * Formats a MomentJS object. This should always be used when a function returns a date/time
 * formatted string (expect when formatting in a user-defined format).
 * Returns null if the moment object is not valid.
 * @param {object} moment A moment object to format
 * @param {string} format optional format
 */
function formatMoment(momentObj, format) {
  if (!momentObj.isValid()) {
    return null;
  }
  if (format) {
    return momentObj.format(format);
  }
  if (momentObj.utcOffset() === 0) {
    // Format: YYYY-MM-DDTHH:mm:ssZ or YYYY-MM-DDTHH:mm:ss.SSSZ
    return formatDateTimeArray(momentObj.toArray());
  }
  if (momentObj.milliseconds()) {
    // Has non-zero milliseconds
    // Format: YYYY-MM-DDTHH:mm:ss.SSS+XX:XX
    return momentObj.format('YYYY-MM-DDTHH:mm:ss.SSSZ');
  }
  // Format in MomentJS default format (but be explicit about it)
  // Format: YYYY-MM-DDTHH:mm:ss+XX:XX
  return momentObj.format('YYYY-MM-DDTHH:mm:ssZ');
}

const maxDateTimeArrayLengthByComponent = {
  year: 1,
  month: 2,
  date: 3,
  day: 3,
  hour: 4,
  minute: 5,
  second: 6,
  millisecond: 7,
};

/**
 * Compares whether the two date/time component arrays (as returned by parseDateTimeArray)
 * are equal (0), the first one is earlier (-1) or the first one is later (1).
 * Returns null if the precision has invalid value.
 * @param {array} array1 first date/time components array (UTC)
 * @param {array} array2 second date/time components array (UTC)
 * @param {string} precision name of the component to use as precision
 */
function compareDateTimeArrays(array1, array2, precision) {
  const maxLength = precision
    ? maxDateTimeArrayLengthByComponent[precision]
    : Number.POSITIVE_INFINITY;
  if (maxLength == null) {
    return null;
  }
  const length = Math.min(array1.length, array2.length, maxLength);
  for (let i = 0; i < length; i += 1) {
    if (array1[i] < array2[i]) {
      return -1;
    }
    if (array1[i] > array2[i]) {
      return 1;
    }
  }
  return 0;
}

/**
 * Compares whether the two date/time strings are the same (0), the first one
 * is earlier (-1) or the first one is later (1). Returns null if the comparison
 * cannot be done.
 * @param {object} date1 first moment
 * @param {object} date2 second moment
 * @param {string} precision name of the component to use as precision
 */
function compareDateTimes(date1, date2, precision) {
  if (!date1 || !date2) {
    return null;
  }
  const array1 = parseDateTimeArray(date1);
  const array2 = array1 && parseDateTimeArray(date2);
  if (array1 && array2) {
    const result = compareDateTimeArrays(array1, array2, precision);
    if (result != null) {
      return result;
    }
  }
  const moment1 = parseDateTime(date1);
  const moment2 = parseDateTime(date2);
  if (moment1.isSame(moment2, precision)) {
    return 0;
  }
  if (moment1.isBefore(moment2, precision)) {
    return -1;
  }
  if (moment1.isAfter(moment2, precision)) {
    return 1;
  }
  return null;
}

module.exports.compareDateTimeArrays = compareDateTimeArrays;
module.exports.compareDateTimes = compareDateTimes;
module.exports.formatDateTimeArray = formatDateTimeArray;
module.exports.formatMoment = formatMoment;
module.exports.parseDateTime = parseDateTime;
module.exports.parseDateTimeArray = parseDateTimeArray;
