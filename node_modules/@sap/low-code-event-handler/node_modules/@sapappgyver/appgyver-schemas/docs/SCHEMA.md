# Schema and typing

This document describes how **typing** or, in more general terms, a **schema** should be defined.

The schema is defined with an object based on [JSON Schema](https://json-schema.org/).
Not all the features are supported, and there are a couple of differences, so this document describes the exact format.

- [General format](#general-format)
- [Type reference](#type-reference)
    - [`number`](#number-type)
    - [`boolean`](#boolean-type)
    - [`string`](#string-type)
    - [`object`](#object-type)
    - [`array`](#array-type)
    - [`json`](#json-type)
    - [`schema`](#schema-type)
    - [`schematicValue`](#schematicvalue-type)
- [Nully values](#nully-values)
- [Union types](#union-types)
- [Intersection types](#intersection-types)
- [Enum](#enum)
- [Annotations](#annotations)
- [Examples](#examples)
- [Default value](#default-value)
- [Deprecated primitive shortcuts](#deprecated-primitive-shortcuts)


## General format

Typically, a type/schema is represented with an object with at least one property `type`.

```javascript
{
    "type": "<INSTANCE TYPE>",
    /* type-specific constraints, annotations, etc. */
}
```

See the sections below for concrete examples of schema definitions.

## Type reference

Here we describe all the supported values for `type`.

### `number` type

A number value, either float or integer, positive or negative. For example `123`, `0.123`, or `-123`.

Note that numeric _strings_ are not included in this type, only pure numbers.

### `boolean` type

A boolean value, either `true` or `false`.

### `string` type

A text string value, for example `"foo"`, `"bar"`, or an empty string `""`.

A string schema _may_ optionally contain an identifier for a **format**:

```javascript
{
    "type": "string",
    "format": "uri",
}
```

**NOTE:** In error messages "strings" are called simply "texts".

A format acts kind of sub-type for strings. Formatted strings follow these assignment rules:

- Any string is assignable to unformatted string
- String can be assigned to a formatted string only if the assignee has the same format, **unless** the assigned string has a _wildcard format_ (see below)

For example, strings without a format or with format `uri` cannot be assigned to the format `color`.

There are some built-in formats which are recognized automatically by the typing system:

Format      | Examples         | Description
------------|-----------------|----------------------
`date-time` | `"2019-07-10T09:56:12.123Z"` | Valid ISO-formatted date/time, including timezone info. **Use this format to represent all timestamps, as there is no separate "date" type.**
`date` | `"2019-07-10"` | Valid ISO-formatted date, without the time.
`email` | `"john.smith@example.com"` | Valid email address.
`color` | `"rgb(200, 140, 120)"`, `"#ffaabb"` | Valid color code, either `rgb`, `rgba`, `hsl`, `#` hex format, or as a keyword (e.g. `red`)
`uri` | `"https://john.doe@www.example.com:123/pp/?tag=foo#top"` | Valid Uniform Resource Identifier (URI)
`url` | `"http://www.example.com/index.html"` | Valid Uniform Resource Locator (URL)
`web-url` | `"http://www.example.com/index.html"` | Valid web address, as an Uniform Resource Locator (URL), that has either `http` or `https` procotol.
`uuid` | `"ec20edcb-ab7f-41f4-99fd-6604bab3502b"` | Valid universally unique identifier (UUID)
`integer` | `"3"`, `"-5"` | Text only consisting of digits (at least one), optionally starting with a minus sign.
`number` | `"3.5"`, `"-0.2"` | Text only consists of digits, and optionally a decimal dot and a minus sign.
`percentage` | `"3%"` | Text representing a number and a percentage character. The value may be negative or contain a decimal dot.
`blank` | `""` | Blank text with length zero, i.e. has no characters.
`*` | | Special **wildcard format** (see below)

The string can also have a special **wildcard format** `*`, which means that the string type is assignable to any formatted or unformatted string type.
You can think wildcard-formatted string as a string type that "matches any possible format".
In practice no such concrete string value exists, but this format may be useful in certain cases where the formatting should be "ignored".

### `object` type

#### Object properties

A plain object with the defined `properties`. For example:

```javascript
{
    "type": "object",
    "properties": {
        "property1": { /* schema for property1 */ },
        "property2": { /* schema for property2 */ },
        "property3": { /* schema for property3 */ },
        /* etc. */
    },
    "required": [
        "property1",
        "property2",
        /* etc. */
    ]
}
```

The `properties` attribute is an object where keys define each allowed (and required) property, and the values are a schema definition for that particular property.
Values can be anything that this document describes as a "schema", so that you can nest objects, arrays, etc.

The schema may also contain an array `required`, containing the names of each property that must be present in the object.
Any property that is defined in `properties` but not listed in `required` is an optional property.

**NOTE:** Unlike in JSON Schema, if `required` is omitted, then this means that **all the properties are required**!
Therefore, omitting the `required` and having `required: []` are not the same thing. The latter means that all the properties are optional.

Example: an object with a required string property `name`, a required number property `age`, and an optional nested object property `address`:

```javascript
{
    "type": "object",
    "properties": {
        "name": {
            "type": "string"
        },
        "age": {
            "type": "number"
        },
        "address": {
            "type": "object",
            "properties": {
                "street": {
                    "type": "string"
                },
                "city": {
                    "type": "string"
                }
            }
        }
    },
    "required": [
        "name",
        "age",
    ]
}
```

#### Additional properties

The object may alternatively or in addition to have an `additionalProperties` that indicates that the object may have any keys (in addition to those defined in `properties`)
and their type must match the schema defined in this property.

Example: an dictionary-like object that allows any keys but their values must be strings.

```javascript
{
    "type": "object",
    "additionalProperties": {
        "type": "string"
    }
}
```

If `properties` nor `additionalProperties` attributes are not present, then the object can contain **any keys** with **any values**. This is not recommended!

#### Forbidden additional properties

By default, it is allowed to assign an object to another object type even though the assignee has additional properties.
However, if you want to explicitly state that no additional properties are allowed, then you can set `additionalProperties` value to `false`:

```javascript
{
    "type": "object",
    "properties": {
        "key": { "type": "string" },
        "value": { "type": "number" },
    },
    "additionalProperties": false
}
```

Assigning an object that has any other additional properties than `key` or `value` will result in an error.
This is slightly different than omitting `additionalProperties` (or setting it to `null`), which would ignore any additional properties.

#### Maximum number of properties

You may optionally limit the maximum total number of properties allowed in an object by using `maxProperties` annotation.
The following schema accepts any object that has no more than 5 different property keys:

```javascript
{
    "type": "object",
    "maxProperties": 5
}
```

#### Minimum number of properties

You may optionally require at least a certain number of properties in an object by using `minProperties` annotation.
The following schema accepts any object that has at least 3 different property keys:

```javascript
{
    "type": "object",
    "minProperties": 3
}
```


### `array` type

An array of specific values:

```javascript
{
    "type": "array",
    "items": {
        /* schema for the items */
    }
}
```

**NOTE:** In error messages "arrays" are called simply "lists".

The `items` attribute describes a schema for all the items in the array. Anything that this document describes as a "schema" can be used, so that you can nest objects, arrays, etc.

Example: an array containing objects, each of which having a string properties `id` and `message`:

```javascript
{
    "type": "array",
    "items": {
        "type": "object",
        "properties": {
            "id": {
                "type": "string"
            },
            "message": {
                "type": "string"
            }
        }
    }
}
```

If `items` attribute is not present, then the array **any values**. This is not recommended!

### `json` type

The `json` type is a special type that represents a [JSON](http://json.org/)-serializable types. These are:

- string
- number
- boolean
- null
- undefined (even though not technically part of JSON)
- object containing only JSON-serializable properties
- array containing only JSON-serializable properties
- `json` type itself
- [`schema` type](#schema-type) (because it is a shortcut for a particular JSON-serializable object schema)

The main difference to an unknown type is that this is not compatible with custom types.
It also has a recursive nature so that if you attempt to get array items or object properties of a `json` type you will get a `json` type as well.

**NOTE** the difference between "JSON-serializable" and a "JSON-serialized string"!
This type represents all the things that *could be represented as a JSON string*, not merely a JSON-encoded string.

### `schema` type

The `schema` type is a special type that represents an object value that correctly describes any **valid schema structure**, as described in this documentation.
You can think it as a shortcut for an object schema that defines all the valid properties for a schema structure.
This type is used when working with schemas on **runtime**.

Any valid schema examples in this documentation (except [deprecated primitive shortcuts](#deprecated-primitive-shortcuts)) are compatible with this type.

The schema with type `schema` may optionally contain a `schema` property with a valid schema.
This means that the schema represents an object value that correctly describes a valid schema that is **compatible with the defined `schema`**.

For example, this schema represents an object value that itself represents a schema of a string type:

```javascript
{
    "type": "schema",
    "schema": {
        "type": "string"
    }
}
```

### `schematicValue` type

This type is a shortcut for **a pair of a schema _and_ a value matching that schema**.
This pair is represented as an object with two properties: `value` and `schema`:

- `schema` must be a valid object schema structure (from this documentation)
- `value` must be a value that is valid against the `schema` property

This special type is used in the AppGyver feature called _Data modules_.

For example, this kind of special object can be defined using the following schema definition with type `schematicValue`, which also contains a `schema` property defining a super-set for the allowed schemas.
In this case, the schema must be an object schema, where properties can be either string, number, or boolean.

```javascript
{
  "type": "schematicValue",
  "schema": {
    "type": "object",
    "additionalProperties": {
      "anyOf": [
        { "type": "string" },
        { "type": "number" },
        { "type": "boolean" },
      ]
    }
  }
}
```

Here's an example of a valid value matching this schema:

```javascript
{
  // Some schema definition, must be assignable to the one defined in "schematicValue"
  "schema": {
    "type": "object",
    "properties": {
      // Only string/number/boolean properties
      "name": { "type": "string" },
      "email": { "type": "string", "format": "email" },
      "year": { "type": "number" }
    }
  },
  // This value is expected to match the `schema` above
  "value": {
    "name": "John Smith",
    "email": "john.smith@example.com",
    "year": 1987
  }
}
```

### `value` type

Special type that means a "wildcard" type that not only accepts anything but is also assignable to anything.
**Use this type with caution** as overusing it will eliminate the benefits of typing.

### Reference types

The following special types are exist to avoid mixing them with each other and for providing a better UX.
Having their own distinct types hides the fact that many (but not all) of them are internally represented as strings.

- `componentId`: an ID reference to a single component on the page
- `componentRef`: a reference to a _property_ of a single component on the page
- `pageVariableRef`: a name of a page variable, or a path to a object property inside a variable
- `appVariableRef`: a name of a global app variable, or a path to a object property inside a variable
- `dataRef`: a reference to a data reference, or a path to a object property inside a reference
- `resourceInstance`: an object that represents a single **data resource record**
- `resourceCollectionInstance`: an array representing a **collection of data resource records**
- `resourceName`: a name of a data resource
- `page`: a reference to a page in the app
- `service`: a reference to a service that could be triggered from the app

## Nully values

Unlike in JSON Schema, the value `null` (and `undefined`) are assignable to any type.
Both `null` and `undefined` also have their own types, that are assignable to any other type (but not to each other).

Example type that represents a null value:

```javascript
{
    "type": "null"
}
```

Example type that represents an undefined value:

```javascript
{
    "type": "undefined"
}
```

## Enum

A schema object _may_ contain a property `enum` listing the valid values that can be assigned to the schema type.
No other values are allowed. Each listed value must match the type described by the schema object.

Example:

```javascript
{
    "type": "string",
    "enum": ["GET", "POST", "PATCH", "DELETE"]
}
```

Note that empty array as `enum` means that **no value is assignable to this schema**!
This is rarely what you want. If you don't want to constraint the values then omit this property.

Also note that for simplification and consistency, JSONSchema's `const` keyword is **not** supported!
Instead, use an `enum` with exactly one value.

## Annotations

A schema may (and preferably should) contain `title` and `description` properties providing information about the type.
This information never affects the validation! It is used in UI tools.

```javascript
{
    "type": "string",
    "title": "Username",
    "description": "An unique name of the user account."
}
```

The `title` should be a short name for the type, without newlines.
The `description` may be longer, and it can contain newlines and markdown syntax.

## Examples

A schema object _may_ contain a property `examples` listing example values that can be assigned to the schema type.
Unlike `enum`, these are just examples, and should only be used in documentative purposes, **never for validation**!

Example:

```javascript
{
    "type": "string",
    "examples": ["Sherlock Holmes", "James Moriarty"]
}
```

## Default value

The schema can contain a property `default`, which may contain a valid value assignable to the type.
This is also just an annotation and never affects the validation.
It is used to indicate in the UI for the end-user that what value would be used in runtime if the value is omitted.
The exact meaning of this depend entirely of the context!

## Union types

For **union types** (allow any of multiple types), the schema object may contain a `anyOf` property **instead of** a `type` property:

```javascript
{
    "anyOf": [
        {
            "type": "<TYPE 1>",
            /* type-specific constraints */
        },
        {
            "type": "<TYPE 2>",
            /* type-specific constraints */
        },
        /* etc. */
    ],
}
```

The `anyOf` must be an array of valid nested schema objects.

Union types can be used in cases where the type can be of multiple type.
**However, as a general rule of thumb, avoid using union types if not necessary.**
Typing exists for a reason, and too much union typing kind of looses its point.

## Named options using unions

You can use [`enum`](#enum) to define the allowed value options for your schema.
However, sometimes you'd also like to have [annotations](#annotations), typically `title`, to be associated with each value in `enum`.
You can achieve this by using an union type:

```javascript
{
    "title": "Country",
    "anyOf": [
        {
            "type": "string",
            "title": "Finland",
            "enum": ["fi"]
        },
        {
            "type": "string",
            "title": "Turkey",
            "enum": ["tr"]
        },
        {
            "type": "string",
            "title": "United States",
            "enum": ["us"]
        }
    ]
}
```

In this case all the schemas listed in `anyOf` should have an `enum` with exactly one value!

## Dynamic typing using unions

In some cases you may want to have an object schema where **properties depend on a specific value of some property**.
There's a limited support for this kind of cases by using an union type.

For example, let's say that you are defining a schema for an authentication object, which has `type` string property. If it's value is `"bearer"`, then the object should have additional property `token`. If on the other hand the value is `"basic"` then there should be properties `username` and `password`. This can be achieved with the following schema:

```javascript
{
    "anyOf": [
        // 1st possible schema
        {
            "type": "object",
            "properties": {
                // This property exists in both schemas in the union
                "type": {
                    "type": "string",
                    "title": "Authentication type",
                    // IMPORTANT: Only allow this exact value
                    "enum": ["bearer"]
                },
                // Properties specific to "bearer" option
                "token": {
                    "type": "string",
                    "title": "Authentication token",
                }
            }
        },
        // 2nd possible schema
        {
            "type": "object",
            "properties": {
                // This property exists in both schemas in the union
                "type": {
                    "type": "string",
                    "title": "Authentication type",
                    // IMPORTANT: Only allow this exact value
                    "enum": ["basic"]
                },
                // Properties specific to "basic" option
                "username": {
                    "type": "string",
                    "title": "Username",
                },
                "password": {
                    "type": "string",
                    "title": "Password",
                }
            }
        }
    ]
}
```

**NOTE:** Even though technically, when considering schema validation, the order of schema object properties does not matter, you still **should define the common properties first** (in this case `type`) in each of the schemas in `anyOf`.
This way, the user interfaces are able to build themselves correctly, and changes to the `type` property will result in correct changes in the UI.

## Intersection types

For **intersection types** (must match all of the given types), the schema object may contain a `allOf` property **instead of** a `type` property:

```javascript
{
    "allOf": [
        {
            "type": "<TYPE 1>",
            /* type-specific constraints */
        },
        {
            "type": "<TYPE 2>",
            /* type-specific constraints */
        },
        /* etc. */
    ],
}
```

The `allOf` must be an array of valid nested schema objects.
**Use intersection types with caution!** Having two incompatible schemas in `allOf` results in schema that matches nothing.

## Deprecated primitive shortcuts

For backward-compatibility, if the schema is defined as a **string** instead of an object, it **must** be considered equivalent with an object with the matching `type` property.

For example:

- Schema `"string"` equals to `{"type": "string"}`
- Schema `"number"` equals to `{"type": "number"}`
- Schema `"boolean"` equals to `{"type": "boolean"}`
- Schema `"array"` equals to `{"type": "array"}`, so the array may contain **anything** (not recommended!)
- Schema `"object"` equals to `{"type": "object"}`, so the object may contain **any keys and values** (not recommended!)

These kind of shorcuts **are not recommended**, but are mentioned here as they are at some level supported for backward-compatibility.
