const beta = require('./BETA.runtime');
const gammaLn = require('./GAMMALN.runtime');

const betacf = (x, a, b) => {
  const fpmin = 1e-30;
  const qab = a + b;
  const qap = a + 1;
  const qam = a - 1;
  let c = 1;
  let d = 1 - qab * x / qap;
  let m2;
  let aa;
  let del;
  let h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin) {
    d = fpmin;
  }

  d = 1 / d;
  h = d;

  for (let m = 1; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));

    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));

    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7) {
      break;
    }
  }
  return h;
};

const ibeta = (x, a, b) => {
  const bt = (x === 0 || x === 1)
    ? 0
    : Math.exp(gammaLn([a + b]) - gammaLn([a])
      - gammaLn([b]) + a * Math.log(x) + b
      * Math.log(1 - x));
  if (x < (a + 1) / (a + b + 2)) {
    return bt * betacf(x, a, b) / a;
  }
  return 1 - bt * betacf(1 - x, b, a) / b;
};

const studentDist = (x, dof) => {
  const dofCorrected = dof > 1e100 ? 1e100 : dof;
  return (1 / (Math.sqrt(dofCorrected) * beta([0.5, dofCorrected / 2])))
  * ((1 + ((x * x) / dof)) ** (-((dofCorrected + 1) / 2)));
};

const cumulativeDist = (x, dof) => {
  const dof2 = dof / 2;
  return ibeta(
    (x + Math.sqrt(x * x + dof)) / (2 * Math.sqrt(x * x + dof)),
    dof2,
    dof2,
  );
};

module.exports = ([x, degrees, cumulative]) => {
  if (
    typeof x === 'number'
      && Number.isFinite(x)
      && typeof degrees === 'number'
      && Number.isFinite(degrees)
  ) {
    if (degrees < 1) {
      return null;
    }
    const result = cumulative
      ? cumulativeDist(x, degrees)
      : studentDist(x, degrees);
    return Number.isFinite(result) ? result : null;
  }
  return null;
};
