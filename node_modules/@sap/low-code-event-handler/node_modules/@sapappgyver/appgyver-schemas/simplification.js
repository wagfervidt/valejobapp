const { isJsonCompatibleSchema } = require('./json');
const { getUnionSchema } = require('./union');
const { intersectionValues } = require('./utils/array');
const { isSchemaAssignable } = require('./validation');

/**
 * Returns a simplified version of the given schema. A "simplified" schemaâ€¦
 *
 * - has no combination types (`anyOf` or `allOf`)
 * - has no enums
 * - has no `blank` string format
 *
 * @param {object} schema schema object to simplify
 * @param {object} defaultSchema schema to default on null/undefined schemas
 */
function simplifySchema(schema, defaultSchema) {
  if (!schema) {
    return defaultSchema || {};
  }
  if (schema.enum || schema.examples) {
    const { enum: enums, examples, ...enumlessSchema } = schema;
    const result = simplifySchema(enumlessSchema, defaultSchema);
    const resultType = result && result.type;
    if (resultType !== 'object' && resultType !== 'array') {
      const resultExamples = examples && examples.length ? examples : enums;
      if (resultExamples && resultExamples.length) {
        return { examples: resultExamples, ...result };
      }
    }
    return result;
  }
  const { allOf, anyOf } = schema;
  if (anyOf) {
    return simplifySchema(getUnionSchema(anyOf, true), defaultSchema);
  }
  if (allOf) {
    const combination = allOf.map((sub) => simplifySchema(sub, defaultSchema));
    if (!combination.length) {
      return defaultSchema || {};
    }
    const examples = intersectionValues(
      ...combination.map((subSchema) => subSchema.examples || []),
    );
    const superSchema = combination.find((subSchema1) => (
      combination.every((subSchema2) => isSchemaAssignable(subSchema1, subSchema2))
    ));
    if (superSchema) {
      return examples.length ? { ...superSchema, examples } : superSchema;
    }
    // Check if there is a common type for everyone
    const commonSchema = { type: combination[0].type };
    if (combination.some(({ type }) => type !== commonSchema.type)) {
      delete commonSchema.type;
    }
    if (commonSchema.type === 'array') {
      const isJson = combination.every((subSchema) => isJsonCompatibleSchema(subSchema));
      commonSchema.items = { type: isJson ? 'json' : 'value' };
    }
    if (commonSchema.type === 'object') {
      const isJson = combination.every((subSchema) => isJsonCompatibleSchema(subSchema));
      commonSchema.additionalProperties = { type: isJson ? 'json' : 'value' };
    }
    return examples.length ? { ...commonSchema, examples } : commonSchema;
  }
  const { type } = schema;
  if ((type === 'null' || type === 'undefined') && defaultSchema) {
    return defaultSchema;
  }
  if (type === 'string' && schema.format === 'blank') {
    const { format, ...unformattedSchema } = schema;
    return simplifySchema(unformattedSchema, defaultSchema);
  }
  if (type === 'array' && schema.items) {
    return { ...schema, items: simplifySchema(schema.items, defaultSchema) };
  }
  if (type === 'object') {
    const objSchema = { ...schema };
    if (objSchema.additionalProperties) {
      objSchema.additionalProperties = simplifySchema(
        objSchema.additionalProperties,
        defaultSchema,
      );
    }
    if (objSchema.properties) {
      const properties = {};
      Object.keys(objSchema.properties).forEach((propertyName) => {
        properties[propertyName] = simplifySchema(
          objSchema.properties[propertyName],
          defaultSchema,
        );
      });
      objSchema.properties = properties;
    }
    return objSchema;
  }
  return schema;
}

module.exports.simplifySchema = simplifySchema;
