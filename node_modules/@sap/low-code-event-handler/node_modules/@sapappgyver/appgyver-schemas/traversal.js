const { getIntersectionSchema } = require('./intersection');
const { pickAnnotations } = require('./keywords');
const { getUnionSchema } = require('./union');
const { immutableMap } = require('./utils/array');

/**
 * Traverses through the given schema and its subschemas recursively calling the
 * given function for each schema. The function should either return the original
 * schema object, or a schema replacement schema, in which case the current schema
 * or sub-schema is replaced with the new object. No recursion is done with the replacement.
 *
 * @param {object} schema schema object
 * @param {object} iteratee function to call for each sub-schema
 */
function traverseSchema(schema, iteratee) {
  if (!schema) {
    return schema;
  }
  const replacement = iteratee(schema);
  if (replacement !== schema) {
    // Replace with another value
    return replacement;
  }
  // Otherwise traverse recursively
  const { anyOf, allOf, type } = schema;
  if (anyOf) {
    const newAnyOf = immutableMap(anyOf, (subSchema) => traverseSchema(subSchema, iteratee));
    return newAnyOf === anyOf ? schema : {
      ...getUnionSchema(newAnyOf),
      ...pickAnnotations(schema),
    };
  }
  if (allOf) {
    const newAllOf = immutableMap(allOf, (subSchema) => traverseSchema(subSchema, iteratee));
    if (newAllOf === allOf) {
      return schema;
    }
    const newSchema = getIntersectionSchema(newAllOf);
    return !newSchema ? newSchema : { ...newSchema, ...pickAnnotations(schema) };
  }
  if (type === 'object') {
    const { properties, additionalProperties } = schema;
    let newSchema = schema;
    if (properties) {
      Object.keys(properties).forEach((propertyName) => {
        const oldPropertySchema = properties[propertyName];
        const newPropertySchema = traverseSchema(oldPropertySchema, iteratee);
        if (newPropertySchema !== oldPropertySchema) {
          newSchema = {
            ...newSchema,
            properties: {
              ...newSchema.properties,
              [propertyName]: newPropertySchema,
            },
          };
        }
      });
    }
    if (additionalProperties) {
      const newAdditionanProperties = traverseSchema(additionalProperties, iteratee);
      if (newAdditionanProperties !== additionalProperties) {
        newSchema = {
          ...newSchema,
          additionalProperties: newAdditionanProperties,
        };
      }
    }
    return newSchema;
  }
  if (type === 'array' && schema.items) {
    const { items } = schema;
    const newItems = traverseSchema(items, iteratee);
    return newItems === items ? schema : { ...schema, items: newItems };
  }
  if (type === 'schema' || type === 'schematicValue') {
    const meta = schema.schema;
    if (meta) {
      const newMeta = traverseSchema(meta, iteratee);
      return newMeta === meta ? schema : { ...schema, schema: newMeta };
    }
  }
  if (type === 'function') {
    const { parameters, returnValue } = schema;
    let newSchema = schema;
    if (parameters) {
      const newParameters = immutableMap(
        parameters,
        (paramSchema) => traverseSchema(paramSchema, iteratee),
      );
      if (newParameters !== parameters) {
        newSchema = { ...newSchema, parameters: newParameters };
      }
    }
    if (returnValue) {
      const newReturnValue = traverseSchema(returnValue, iteratee);
      if (newReturnValue !== returnValue) {
        newSchema = { ...newSchema, returnValue: newReturnValue };
      }
    }
    return newSchema;
  }
  return schema;
}

/**
 * Replaces any type of or within the given schema using the given replacements.
 * This allows using type aliases in your schema which you can then replace to
 * some concrete schemas. For example, by providing this schema:
 *
 *     {type: 'array', items: {type: 'person'}}
 *
 * And giving these replacements:
 *
 *     {person: {type: 'object', properties: {name: {type: 'string'}}}}
 *
 * The result would be:
 *
 *     {type: 'array': items: {type: 'object', properties: {name: {type: 'string'}}}}}
 *
 * NOTE: Types 'object' and 'array' cannot be replaced!
 *
 * @param {object} schema schema object
 * @param {object} replacements mapping of replacement schemas by their type names
 */
function replaceSchemaTypes(schema, replacements) {
  return traverseSchema(schema, (subSchema) => {
    const replacement = replacements[subSchema.type];
    if (typeof replacement === 'undefined') {
      // No replacement for this
      return subSchema;
    }
    // Replace preserving annotations
    return { ...pickAnnotations(subSchema), ...replacement };
  });
}

module.exports.replaceSchemaTypes = replaceSchemaTypes;
module.exports.traverseSchema = traverseSchema;
