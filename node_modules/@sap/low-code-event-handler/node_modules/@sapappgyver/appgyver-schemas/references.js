const { getArrayItemSchema } = require('./arrays');
const { getIntersectionSchema } = require('./intersection');
const { traverseSchema } = require('./traversal');

/**
 * Determines a concrete schema for each `$id` marked schema in the given
 * `modelSchema`, using the given `actualSchema`. Returns an object where
 * keys are the `$id` values found, and values are the resolved schemas,
 * or `null` values if could not be resolved.
 *
 * @param {object} modelSchema Schema with possible `$id` schemas
 * @param {object} actualSchema Schema used to resolve the identified schemas
 */
function idenfitySchemas(modelSchema, actualSchema) {
  if (!modelSchema) {
    return {};
  }
  const { $id } = modelSchema;
  if ($id != null) {
    return { [$id]: actualSchema || {} };
  }
  const { type, anyOf, allOf } = modelSchema;
  if (anyOf || allOf) {
    // Not supporting combination schemas
    return {};
  }
  if (type === 'object') {
    // TODO: Support identifying by properties
    return {};
  }
  if (type === 'array') {
    return idenfitySchemas(modelSchema.items, getArrayItemSchema(actualSchema));
  }
  if (type === 'function') {
    // TODO: Identify from parameters...?
    return idenfitySchemas(
      modelSchema.returnValue,
      actualSchema && actualSchema.type === 'function' ? actualSchema.returnValue : actualSchema,
    );
  }
  return {};
}

/**
 * Replaces the schema or its sub-schemas with `$ref` to another schema,
 * using the given mapping object (which should have identifiers as keys and schemas as values).
 * Any unknown references are replaced with unknown types.
 *
 * @param {object} schema Schema to resolve
 * @param {object} references Mapping of schemas by their $id
 * @param {object} defaultSchema Schema to use when no matching $id is found
 */
function resolveSchemaReferences(schema, references, defaultSchema) {
  return traverseSchema(schema, (subSchema) => {
    const { $ref, ...baseSchema } = subSchema;
    if ($ref == null) {
      return subSchema; // no replacement
    }
    const refSchema = references[$ref];
    if (!refSchema) {
      return defaultSchema;
    }
    return getIntersectionSchema([baseSchema, refSchema]);
  });
}

module.exports.idenfitySchemas = idenfitySchemas;
module.exports.resolveSchemaReferences = resolveSchemaReferences;
