const nearley = require('nearley');
const { getSchemaAssignmentErrors } = require('@sapappgyver/appgyver-schemas');
const { unionValues } = require('@sapappgyver/appgyver-schemas/utils/array');
const { isEqual } = require('@sapappgyver/appgyver-schemas/utils/equality');
const grammar = require('./grammar');
const { parseTokens } = require('./tokenizer');
const { buildSyntaxError, isConstantStructure } = require('./structure');
const { prepareExecutable } = require('./runtime');

class ParsedExpression {
  constructor(formula, structure) {
    this.formula = formula;
    this.structure = structure;
    // For backward compatibility
    this.syntaxErrors = structure.syntaxErrors;
    this.syntaxError = structure.syntaxErrors[0];
  }

  analyze(contextSchema, requiredSchema, options) {
    const { schema, errors } = this.inspect(contextSchema, requiredSchema, options);
    return {
      schema,
      errors: errors.map((issue) => {
        // eslint-disable-next-line no-shadow
        const { errors, ...error } = issue;
        if (!errors || errors.length === 0) {
          return error;
        }
        return issue;
      }),
    };
  }

  inspect(contextSchema, requiredSchema, options) {
    const { structure } = this;
    const { syntaxErrors } = structure;
    const analysis = structure.analyze(contextSchema, options);
    const assignedSchema = requiredSchema && requiredSchema.type === 'object' && !analysis.schema
      ? { type: 'object', properties: [] }
      : analysis.schema;
    const schemaErrors = getSchemaAssignmentErrors(assignedSchema, requiredSchema)
      .map(error => ({ ...error, offset: 0, length: this.formula.length }));
    return {
      ...analysis,
      errors: syntaxErrors.concat(analysis.errors, schemaErrors),
    };
  }

  getTokens() {
    return this.structure.tokens;
  }

  export(options) {
    const disableInverse = options != null && options.inverse != null && !options.inverse;
    const { structure } = this;
    const {
      dependencies, functions, reference, script, inverse, inverts,
    } = structure;
    // Remove duplicate dependencies and functions
    const exported = {
      formula: this.formula,
      script,
      dependencies: dependencies ? unionValues(dependencies) : [],
      functions: functions ? unionValues(functions) : [],
    };
    if (dependencies) {
      if (reference && dependencies.length === 1) {
        exported.isPointer = true;
      } if (isConstantStructure(structure)) {
        exported.isConstant = true;
      }
    }
    if (!disableInverse && inverse != null) {
      exported.inverse = inverse;
      if (!isEqual(inverts, dependencies)) {
        exported.inverts = inverts;
      }
    }
    return exported;
  }

  toExecutable(context) {
    return prepareExecutable(this.export(), context);
  }

  rename(renames) {
    const { structure } = this;
    const formula = structure.refactor(renames, {});
    return formula === this.formula ? this : parseExpression(formula);
  }

  toString() {
    return this.formula;
  }
}

/**
 * Parses the given expression string and returns an object possibly containing errors.
 * @param {string} expression Expression string to parse
 */
function parseExpression(expression) {
  const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
  let structure;
  try {
    parser.feed(expression);
    // Attempt to find a successful result
    const { results } = parser;
    structure = results.find(result => !result.syntaxErrors.length);
    // If not found, then use the last one of the possibly ambiguous results
    if (!structure) {
      structure = results[results.length - 1];
    }
  } catch (error) {
    const { token } = error;
    if (!token) {
      // Unknown error
      throw error;
    }
    structure = buildSyntaxError(parseTokens(expression), token);
  }
  if (!structure) {
    // Incomplete syntax
    structure = buildSyntaxError(parseTokens(expression));
  }
  return new ParsedExpression(expression, structure);
}

/**
 * Parses a previously exported expression object.
 * @param {object} expression exported expression object to parse
 */
function importExpression(expression) {
  return parseExpression(expression.formula || expression.script);
}

module.exports.parseExpression = parseExpression;
module.exports.importExpression = importExpression;
