const { formats, isFormatCompatible } = require('./formatting');
const { getSchemaJsonSerializationErrors } = require('./json');
const { normalizeSchema } = require('./normalization');
const metaSchema = require('./schemas/meta.json');
const { includesValue, unionValues } = require('./utils/array');
const { makeError, stringify, stringifyType } = require('./utils/shortcuts');
const { upperFirst } = require('./utils/string');

const empty = {};

/**
 * Returns an array of error messages if the first schema is not assignable to the second schema,
 * or an empty array if the first schema is assignable to the second.
 * @param fromSchema {Object} schema to be assigned
 * @param toSchema {Object} schema to which the assignment is attempted
 * @param options {Object} options for altering the way check is done
 * @param options.tolerant {boolean} whether to allow assignment of unknown types to a known value
 * @param options.subset {boolean} whether to perform a type subset check
 * @param options.references {Object} mapping of references to schemas by their ID
 */
function getSchemaAssignmentErrors(fromSchema, toSchema, options) {
  // For backward compatibility, support tolerant=true shortcut for options
  if (typeof options === 'boolean') {
    // eslint-disable-next-line no-param-reassign
    options = { tolerant: options };
  }
  const tolerant = options && options.tolerant;
  const subset = options && options.subset;
  const references = (options && options.references) || empty;
  // eslint-disable-next-line no-param-reassign
  fromSchema = normalizeSchema(fromSchema);
  // eslint-disable-next-line no-param-reassign
  toSchema = normalizeSchema(toSchema);
  // If target schema has $id then save it to references (unless already saved)
  const { $id, $ref } = toSchema;
  if ($id != null && references[$id] == null) {
    return getSchemaAssignmentErrors(fromSchema, toSchema, {
      ...options,
      references: { ...references, [$id]: toSchema },
    });
  }
  // If referring to a schema, then validate against that reference
  if ($id == null && $ref != null && references[$ref] != null) {
    // TODO: Support correct usage of "#" references
    // eslint-disable-next-line no-param-reassign
    toSchema = references[$ref];
  }
  // If both schemas have enum's, then every value from the first schema
  // must be assignable to the second.
  // NOTE: Only checking primitive values here. Could also make deep comparison for objects/arrays.
  const enumFrom = fromSchema.enum;
  const enumTo = toSchema.enum;
  if (enumFrom && enumTo) {
    const enumErrors = [];
    enumFrom.forEach((value) => {
      if (!includesValue(enumTo, value)) {
        if (enumTo.length === 1) {
          enumErrors.push(makeError(`Value ${stringify(value)} is not equal to ${stringify(enumTo[0])}`));
        } else {
          const enumToStr = enumTo.map((val) => stringify(val)).join(', ');
          enumErrors.push(makeError(`Value ${stringify(value)} is not any of the following: ${enumToStr}`));
        }
      }
    });
    if (enumErrors.length) {
      return enumErrors;
    }
  }
  const allOfFrom = fromSchema.allOf;
  const allOfTo = toSchema.allOf;
  const anyOfFrom = fromSchema.anyOf;
  const anyOfTo = toSchema.anyOf;
  // If the source has enum, and the target is a combination type,
  // then we need to check each value separately (for recognizing formats, see below).
  if (enumFrom && enumFrom.length > 1 && (allOfTo || anyOfTo)) {
    return unionValues(
      ...enumFrom.map((value) => getSchemaAssignmentErrors(
        /* Single enum value only */
        { ...fromSchema, enum: [value] },
        toSchema,
        options,
      )),
    );
  }
  // If the first schema is an intersection, then ANY of them must be assignable to the second
  if (allOfFrom) {
    if (subset && !allOfFrom.length) {
      return [makeError('Empty intersection type is not a sub-type of anything')];
    }
    const errorLists = allOfFrom.map((subSchema) => (
      getSchemaAssignmentErrors(subSchema, toSchema, options)
    ));
    if (errorLists.some((errors) => !errors.length)) {
      return [];
    }
    return unionValues(...errorLists); // Flatten
  }
  // If the second schema is an intersection, then first schema must be assignable to ALL of them
  if (allOfTo) {
    if (subset && !allOfTo.length) {
      return [makeError('Nothing is a sub-set of an empty intersection type')];
    }
    const errorLists = allOfTo.map((subSchema) => (
      getSchemaAssignmentErrors(fromSchema, subSchema, options)
    ));
    return unionValues(...errorLists); // Flatten
  }

  // If the first schema is a `anyOf`, then ALL of the types must be assignable to the second
  if (anyOfFrom) {
    if (subset && !anyOfFrom.length) {
      return [makeError('Empty union type is not a sub-type of anything')];
    }
    const errorLists = anyOfFrom.map((subSchema) => (
      getSchemaAssignmentErrors(subSchema, toSchema, options)
    ));
    return unionValues(...errorLists); // Flatten
  }
  // If the second schema is a `anyOf`, then the first schema must be assignable to ANY of them
  if (anyOfTo) {
    if (subset && !anyOfTo.length) {
      return [makeError('Nothing is a sub-set of an empty union type')];
    }
    const errorLists = anyOfTo.map((subSchema) => (
      getSchemaAssignmentErrors(fromSchema, subSchema, options)
    ));
    if (errorLists.some((errors) => !errors.length)) {
      return [];
    }
    return unionValues(...errorLists); // Flatten
  }
  const from$ref = fromSchema.$ref;
  const to$ref = toSchema.$ref;
  if (from$ref != null && to$ref != null) {
    return from$ref === to$ref ? [] : [
      makeError(`Reference types ${stringify(to$ref)} and ${stringify(from$ref)} are not compatible`),
    ];
  }
  if (to$ref != null) {
    return [makeError(`Non-reference type is incompatible with reference type ${stringify(to$ref)}`)];
  }
  const fromType = fromSchema.type;
  const toType = toSchema.type;
  if (!toType || toType === 'value') {
    // Target type is unknown -> can assign anything
    return [];
  }
  if (from$ref != null) {
    return [makeError(`Reference type ${stringify(from$ref)} is incompatible with non-reference type`)];
  }
  // If checking a subset, then "value" is not assignable to anything (else)
  if (subset && fromType === 'value') {
    return [makeError(`Unknown type cannot be assigned to ${stringifyType(toType)}`)];
  }
  if (fromType === 'null' && toType !== 'undefined') {
    // Null can be assignable to any other type than 'undefined'
    return [];
  }
  if (fromType === 'undefined' && toType !== 'null') {
    // Undefined can be assignable to any other type than 'null'
    return [];
  }
  if (fromType === 'value') {
    // The wildcard type "value" is always assignable to anything
    return [];
  }
  if (toType === 'json') {
    // Only JSON-serializable type is assigable to "json" type
    return getSchemaJsonSerializationErrors(fromSchema);
  }
  if (toType === 'schema') {
    // Target type only accepts valid schema structures
    const toMeta = toSchema.schema;
    const { schema: fromMeta, errors: metaErrors } = resolveMetaSchema(fromSchema);
    if (metaErrors.length) {
      return [makeError(`${upperFirst(stringifyType(fromType))} does not represent a valid schema`, metaErrors)];
    }
    if (toMeta) {
      const errors = getSchemaAssignmentErrors(fromMeta, toMeta);
      if (errors.length) {
        return [makeError(`${upperFirst(stringifyType(fromType))} represents an incompatible schema`, errors)];
      }
    }
    return [];
  }
  if (toType === 'schematicValue') {
    // Target type only accepts valid schematic value structures
    const toMeta = toSchema.schema;
    if (fromType === 'schematicValue') {
      const errors = getSchemaAssignmentErrors(fromSchema.schema, toMeta);
      if (errors.length) {
        return [makeError(`${upperFirst(stringifyType(fromType))} represents an incompatible schema`, errors)];
      }
    } else {
      // Import lazily due to circular dependency
      // eslint-disable-next-line global-require
      const { getObjectPropertySchema } = require('./objects');
      const schemaMetaSchema = getObjectPropertySchema(fromSchema, 'schema');
      const { schema: valueMatchSchema } = resolveMetaSchema(schemaMetaSchema);
      const errors = getSchemaAssignmentErrors(fromSchema, {
        type: 'object',
        properties: {
          value: valueMatchSchema || {},
          schema: {
            type: 'schema',
            schema: toMeta,
          },
        },
        required: ['value', 'schema'],
      });
      if (errors.length) {
        return [makeError(`${upperFirst(stringifyType(fromType))} does not represent a valid schematic value`, errors)];
      }
    }
    return [];
  }
  if (!fromType) {
    // Unknown assigned type can be assigned to anything only in tolerant mode
    return tolerant ? [] : [makeError(`Unknown type cannot be assigned to ${stringifyType(toType)}`)];
  }
  // Types must be equal
  if (fromType !== toType) {
    return [makeError(`${upperFirst(stringifyType(fromType))} is not assignable to ${stringifyType(toType)}`)];
  }
  if (fromType === 'object') {
    return getObjectSchemaAssignmentErrors(fromSchema, toSchema, options);
  }
  if (fromType === 'array') {
    // Array type is assignable to another if their items are assignable
    const fromItems = fromSchema.items;
    const toItems = toSchema.items;
    const errors = getSchemaAssignmentErrors(fromItems, toItems, options);
    if (errors.length) {
      return [makeError('List items are incompatible', errors)];
    }
    return [];
  }
  if (fromType === 'string') {
    const fromFormat = fromSchema.format;
    const toFormat = toSchema.format;
    // When making a subset-check, disallow assigning a wildcard format to anything else
    if (subset && fromFormat === '*' && toFormat !== '*') {
      return [makeError('Wildcard-formatted text is not subset of non-wildcard-formatted text')];
    }
    // Wildcard format is assignable to any string format, and
    // any string format is assignable to wildcard format
    if (fromFormat === '*' || toFormat === '*') {
      return [];
    }
    // Otherwise anything is assignable to unformatted string, but formatted strings are
    // not considered subsets of unformatted strings.
    if (!toFormat && !subset) {
      return [];
    }
    const toFormatDef = toFormat ? formats[toFormat] : null;
    if (toFormatDef && enumFrom) {
      // All the possible enum values must be assignable to the format
      const invalidValues = enumFrom.filter((val) => (
        val != null && (typeof val !== 'string' || !toFormatDef.matches(val))
      ));
      return invalidValues.map((val) => makeError(
        `Value ${stringify(val)} is not assignable to text format ${stringify(toFormat)}`,
      ));
    }
    if (!fromFormat && toFormat) {
      return [makeError(`Unformatted text is unassignable to format ${stringify(toFormat)}`)];
    }
    if (fromFormat && !toFormat) {
      return [makeError(`Text with format ${stringify(fromFormat)} is not subset of unformatted text`)];
    }
    if ((!fromFormat && !toFormat) || isFormatCompatible(fromFormat, toFormat)) {
      return [];
    }
    return [makeError(`Text with format ${stringify(fromFormat)} is unassignable to format ${stringify(toFormat)}`)];
  }
  // Types are equal
  return [];
}

const noKeys = [];

/**
 * Expects two schemas with type "object" and returns their assignability errors.
 * @ignore
 */
function getObjectSchemaAssignmentErrors(fromSchema, toSchema, options) {
  const errors = [];
  const fromProperties = fromSchema.properties;
  const toProperties = toSchema.properties;
  const fromAdditionalProperties = fromSchema.additionalProperties;
  const toAdditionalProperties = toSchema.additionalProperties;
  const fromKeys = fromProperties ? Object.keys(fromProperties) : noKeys;
  const toKeys = toProperties ? Object.keys(toProperties) : noKeys;
  const requiredKeys = toSchema.required || toKeys;
  const alwaysPresentKeys = fromSchema.required || fromKeys;
  if (toProperties || toAdditionalProperties != null) {
    if (!fromProperties && fromAdditionalProperties == null) {
      // Allow assigning from unknown properties only in tolerant mode
      const tolerant = options && options.tolerant;
      if (!tolerant && requiredKeys.length) {
        errors.push(makeError('Object with unknown properties is unassignable to object type with required properties'));
      }
    } else {
      // Each property from the source must be assignable to the target
      // except those not existing on the target
      const missingKeys = requiredKeys.filter(
        (key) => !fromAdditionalProperties && !includesValue(alwaysPresentKeys, key),
      );
      if (missingKeys.length) {
        errors.push(makeError(
          'Object is missing required properties',
          missingKeys.map((missingKey) => makeError(
            fromProperties && fromProperties[missingKey]
              ? `Property ${stringify(missingKey)} may be missing`
              : `Property ${stringify(missingKey)} is missing`,
          )),
        ));
      }
      const knownKeys = unionValues(fromKeys, toKeys);
      knownKeys.forEach((key) => {
        const fromProperty = (fromProperties && fromProperties[key]) || fromAdditionalProperties;
        const toProperty = (toProperties && toProperties[key]) || toAdditionalProperties;
        if (fromProperty && toProperty === false) {
          // The target object type does not accept additional properties
          errors.push(makeError(`Object does not accept property ${stringify(key)}`));
        } else if (fromProperty && toProperty != null) {
          // Check if the property is assignable to the target type
          const propErrors = getSchemaAssignmentErrors(fromProperty, toProperty, options);
          if (propErrors.length) {
            errors.push(makeError(`Unassignable object property ${stringify(key)}`, propErrors));
          }
        }
      });
      if (fromAdditionalProperties && toAdditionalProperties === false) {
        // The target object type does not accept additional properties
        errors.push(makeError('Object does not accept additional properties'));
      } else if (fromAdditionalProperties && toAdditionalProperties) {
        // Remaining additional properties must be assignable
        const propErrors = getSchemaAssignmentErrors(
          fromAdditionalProperties,
          toAdditionalProperties,
          options,
        );
        if (propErrors.length) {
          errors.push(makeError('Unassignable object properties', propErrors));
        }
      }
    }
  }
  // Validate "maxProperties"
  let fromMaxProperties = fromSchema.maxProperties;
  if (fromMaxProperties == null) {
    fromMaxProperties = fromAdditionalProperties || !fromProperties
      ? Number.POSITIVE_INFINITY : fromKeys.length;
  }
  const toMaxProperties = toSchema.maxProperties == null
    ? Number.POSITIVE_INFINITY : toSchema.maxProperties;
  if (fromMaxProperties > toMaxProperties) {
    const message = [
      'The number of possible object properties',
      Number.isFinite(fromMaxProperties) ? `(${fromMaxProperties})` : '',
      'is larger than the allowed maximum',
      Number.isFinite(toMaxProperties) ? `(${toMaxProperties})` : '',
    ].filter(Boolean);
    errors.push(makeError(message.join(' ')));
  }
  // Validate "minProperties"
  const fromMinProperties = fromSchema.minProperties == null
    ? alwaysPresentKeys.length : fromSchema.minProperties;
  const toMinProperties = toSchema.minProperties == null
    ? 0 : toSchema.minProperties;
  if (fromMinProperties < toMinProperties) {
    errors.push(makeError(`The number of possible object properties (${fromMinProperties}) is smaller than the required minimum (${toMinProperties})`));
  }
  return errors;
}

/**
 * Returns an array of error messages if the first schema is not assignable to the second schema,
 * or an empty array if the first schema is assignable to the second.
 * @param fromSchema {object} schema to be assigned
 * @param toSchema {object} schema to which the assignment is attempted
 * @param options {Object} options for altering the way check is done
 * @param options.tolerant {boolean} whether to allow assignment of unknown types to a known value
 * @param options.subset {boolean} whether to perform a type subset check
 */
function isSchemaAssignable(fromSchema, toSchema, options) {
  return getSchemaAssignmentErrors(fromSchema, toSchema, options).length === 0;
}

const subsetCheckOptions = {
  tolerant: false,
  subset: true,
};

/**
 * Returns whether or not the first schema is a subset of the second one.
 * @param {object} subSchema sub-schema to test
 * @param {object} superSchema super-schema to test
 * @param {boolean} allowEquality whether or not to return true if the schemas are equal
 */
function isSubsetSchema(subSchema, superSchema, allowEquality = false) {
  if (getSchemaAssignmentErrors(subSchema, superSchema, subsetCheckOptions).length) {
    // Sub-schema is not assignable to the super-schema, so it cannot be a subset
    return false;
  }
  // Sub-schema is either a true sub-schema or an equal schema
  return allowEquality
    || getSchemaAssignmentErrors(superSchema, subSchema, subsetCheckOptions).length > 0;
}

/**
 * When given a schema with type "schema" or a schema that might represent a valid schema
 * then resolves the meta schema of that schema (from `schema` property).
 * Returns an object with two properties `schema` and `errors`.
 * @param {Object} schema schema for a value representing a schema
 * @returns {Object} object with `schema` and `errors`
 */
function resolveMetaSchema(schema) {
  if (schema && schema.type === 'schema') {
    return { schema: schema.schema || {}, errors: [] };
  }
  const errors = getSchemaAssignmentErrors(schema, metaSchema);
  if (errors.length) {
    return { schema: null, errors };
  }
  // TODO: Use a helper to get exact value options
  const valueOptions = schema.enum;
  if (!valueOptions) {
    return { schema: {}, errors: [] };
  }
  return {
    schema: valueOptions.length === 1 ? valueOptions[0] : { anyOf: valueOptions },
    errors: [],
  };
}

module.exports.getSchemaAssignmentErrors = getSchemaAssignmentErrors;
module.exports.isSchemaAssignable = isSchemaAssignable;
module.exports.isSubsetSchema = isSubsetSchema;
module.exports.resolveMetaSchema = resolveMetaSchema;
