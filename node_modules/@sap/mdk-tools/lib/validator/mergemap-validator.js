const fs = require("fs-extra");
const _ = require('lodash');
const path = require("path");
const toolUtils = require('../tool-utils');

const BASE_PROJECT_IDENTIFIER = ".base";
const ROOT_EXTENSION_POINT = "__ROOT_EXTENSION_POINT__";
const START_POSTFIX = "_START";;
const END_POSTFIX = "_END";
const KEY_NAME_METADATA ="_Name";
const KEY_ARRAY_INSERT_AFTER_NAME = "NameAfter";
const KEY_ARRAY_INSERT_AFTER_INDEX = "IndexAfter";
const KEY_ARRAY_INSERT_BEFORE_NAME = "NameBefore";
const KEY_ARRAY_INSERT_BEFORE_INDEX = "IndexBefore";
const KEY_ARRAY_REMOVE = "Remove";
const KEY_ARRAY_REORDER = "Reorder";
const KEY_ARRAY_ADD = "Add";
const KEY_ARRAY_INSERT_BEGIN = "InsertBegin";
const KEY_ARRAY_INSERT_END = "InsertEnd";
const KEY_ARRAY_INSERT_ANY = "InsertAny";
const KEY_SEP = "/";
const VALUE_REMOVED = "undefined";
const RegexJSExtContentStart = new RegExp(/\/\/ExtPt-(\w+):\s*==START==/, "g");
const RegexJSExtLineStart = new RegExp(/\/\/ExtPt-(\w+):\s*==START==/, "m");
const RegexJSExtContentEnd = new RegExp(/\/\/ExtPt-(\w+):\s*==END==/, "g");
const RegexJSExtLineEnd =new RegExp(/\/\/ExtPt-(\w+):\s*==END==/, "m");
const MERGEMAP_FILE_EXTNAME = ".mergemap";
const JSON_FILE_ENCODING = 'UTF-8';
const _SUPPORTED_JSON_FILE_EXT = [".app",".service",".global", ".action",".page", ".fragment"];

class MergeMapValidator {
	constructor (sAppExtPath, sAppBasePath) {
		this.appExtPath = sAppExtPath ? path.resolve(sAppExtPath) : "";
		this.appBasePath = sAppBasePath ? path.resolve(sAppBasePath) : "";
		this.allControlNames = [];
		this.diagnostics = [];
	}

	_getAllMergeMapFilesPath(folderFullPath) {
		let allSubFileFullPaths = [];
		try {
			if (fs.existsSync(folderFullPath) && path.basename(folderFullPath) !== BASE_PROJECT_IDENTIFIER) {
				let childrenNames = fs.readdirSync(folderFullPath);
				childrenNames.forEach(childName => {
					let childFullPath = path.join(folderFullPath, childName);
					let isFolder = toolUtils.isDirectory(childFullPath);
					if (isFolder) {
						allSubFileFullPaths = allSubFileFullPaths.concat(this._getAllMergeMapFilesPath(childFullPath));
					} else {
                        const extName = path.extname(childFullPath).toLowerCase();
                        if (extName === MERGEMAP_FILE_EXTNAME) {
                            allSubFileFullPaths.push(childFullPath);
                        }
					}
				}, this);
			}
		} catch (error) {
			console.log(error);
		}
		return allSubFileFullPaths;
	}

    _getBaseFilePath(mergeFilePath) {
		const fileName = path.basename(mergeFilePath);
		const fileFirstName = fileName.substring(0, fileName.lastIndexOf("."));
		let sPath;
		if (this.appBasePath) {
			sPath = mergeFilePath.replace(this.appExtPath, this.appBasePath);
		} else {
			sPath = mergeFilePath.replace(this.appExtPath, path.join(this.appExtPath, BASE_PROJECT_IDENTIFIER));
		}
		let relativePath = path.dirname(sPath);

		if (fs.existsSync(relativePath)) {
			let files = fs.readdirSync(relativePath);
			for (let i = 0; i < files.length; i++) {
				const _file = files[i];
				const _fileName = _file.substring(0, _file.lastIndexOf("."));
				if (_fileName === fileFirstName) {
					return path.join(relativePath, _file);
				}
			}
		}

		return "";
	}

    _validateForJsonFile(mergemapObj, sourceObj, filePath) {
		let _diagnostics = [];
		this.allControlNames.splice(0);
        if (Array.isArray(mergemapObj)) {
            const ExtensionPointMap = new Map();
			this._getAllNames(sourceObj);
            if (sourceObj["_ExtensionPoint"]) {
                ExtensionPointMap.set(ROOT_EXTENSION_POINT, sourceObj["_ExtensionPoint"]);
                if (sourceObj[KEY_NAME_METADATA]) {
                    ExtensionPointMap.set(sourceObj[KEY_NAME_METADATA], sourceObj["_ExtensionPoint"]);
                }
            }
            this._getExtensionPointsFromJsonFile(sourceObj, ExtensionPointMap);
            mergemapObj.forEach(item => {
				const _name = item[KEY_NAME_METADATA];
                const _tarExtensionPoint = ExtensionPointMap.get(_name || ROOT_EXTENSION_POINT);
                Object.keys(item).forEach(key => {
                    const _value = item[key];
                    if (key === KEY_NAME_METADATA) {
						// validate _Name
                        if (!ExtensionPointMap.get(_value)) {
                            _diagnostics.push(`"${_value}" does not exist or does not have _ExtensionPoint.`);
                        }
                        
                    } else {
						// validate ExtensionPoint
						let sMessage = `Cannot find _ExtensionPoint "${key}"${_name ? " in \"" + _name + "\"" : ""}.`;
						if (!_tarExtensionPoint) {
							_diagnostics.push(sMessage);
						} else {
							const _objExtPointItem = typeof _tarExtensionPoint === "object" ? _tarExtensionPoint[key] : {};
							if (!_objExtPointItem) {
								let pass = false;
								const _objObjectExtPointItem = this._getExtensionPointForObject(key, _tarExtensionPoint);
								if (_objObjectExtPointItem && Array.isArray(_objObjectExtPointItem)) {
									// for Object property:
									// Add, Remove
									const rst = this._validateObjectExtensionPoint(sourceObj, _name, key, _value, _objObjectExtPointItem);
									pass = rst.pass;
									if (!pass) {
										sMessage = rst.message;
									}
								}
								if (!pass) {
									_diagnostics.push(sMessage);
								}
							} else if (typeof _value === "object" && Array.isArray(_objExtPointItem)) {
								// for Array property:
								// Reorder, Remove, InsertBegin, InsertEnd, InsertAny
								let arrOri;
								let tarObj = this._findObjectByName(sourceObj, _name);
								let oRet = this._getSourceObjectByKey(tarObj, key);
								if (oRet.parent && oRet.parent.hasOwnProperty(oRet.key)) {
									arrOri = oRet.parent[oRet.key]; // source array
								}
								if (!Array.isArray(arrOri)) {
									arrOri = [];
								}
								Object.keys(_value).forEach(key2 => {
									if (key2 === KEY_ARRAY_REMOVE && arrOri.length > 0) {
										arrOri.pop();
									}
									const rst = this._validateArrayExtensionPoint(key2, _name, key, _objExtPointItem);
									if (!rst.pass) {
										_diagnostics.push(rst.message);
									} else {
										if (key2 === KEY_ARRAY_ADD) {
											const _rsts = this._validateInsertExtensionPoints(_value[key2], _name, key, arrOri, _objExtPointItem);
											_rsts.forEach(rst => {
												if (!rst.pass) {
													_diagnostics.push(rst.message);
												}
											});
										}
									}
								});
							}
						}
                    }
                });
            });
        }
		if (_diagnostics.length > 0) {
			this.diagnostics.push({
				filePath: filePath,
				messages: _diagnostics
			});
		}
	}

	_validateForJsFile(mergemapObj, sourceContent, filePath) {
		let _diagnostics = [];
        if (Array.isArray(mergemapObj)) {
            const ExtensionPointMap = new Map();
            this._getExtensionPointsFromJsFile(sourceContent, ExtensionPointMap);
            mergemapObj.forEach(item => {
                if (item.Name) {
                    const _tarExtensionPoint1 = ExtensionPointMap.get(item.Name + START_POSTFIX);
                    const _tarExtensionPoint2 = ExtensionPointMap.get(item.Name + END_POSTFIX);
                    if (!_tarExtensionPoint1 || !_tarExtensionPoint2) {
                        _diagnostics.push(`"${item.Name}" does not exist.`);
                    }
                }
            });
        }
		if (_diagnostics.length > 0) {
			this.diagnostics.push({
				filePath: filePath,
				messages: _diagnostics
			});
		}
	}

	_validateInsertExtensionPoints(value, name, extensionKey, arrOri, extensionPoint) {
		let results = [];
		let iStart = 0, iEnd = arrOri.length > 0 ? (arrOri.length - 1) : 0;

		if (value && Array.isArray(value)) {
			value.forEach(item => {
				let pass = true;
				const _tarKey = Object.keys(item).find(prop => {
					return [KEY_ARRAY_INSERT_AFTER_NAME,
						KEY_ARRAY_INSERT_AFTER_INDEX,
						KEY_ARRAY_INSERT_BEFORE_NAME,
						KEY_ARRAY_INSERT_BEFORE_INDEX].indexOf(prop) >= 0;
				});
				if (!extensionPoint.includes(KEY_ARRAY_INSERT_ANY) && value.length > 0 && _tarKey) {
					// validate NameAfter, IndexAfter, NameBefore, IndexBefore
					const _value = item[_tarKey];
					const sMessage = `"${_tarKey}" with value "${_value}" is not allowed in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""}.`
					let iIndex;
					if (_tarKey === KEY_ARRAY_INSERT_AFTER_NAME || 
						_tarKey === KEY_ARRAY_INSERT_BEFORE_NAME) {
						// NameAfter, NameBefore
						iIndex = arrOri.findIndex(oItem => { return oItem._Name === _value; });
						if (_tarKey === KEY_ARRAY_INSERT_AFTER_NAME) {
							iIndex = iIndex + 1;
						} else {
							iIndex = iIndex - 1;
						}
						arrOri.splice(iIndex, 0, { _Name: _value }); // add fake value
					} else if (_tarKey === KEY_ARRAY_INSERT_AFTER_INDEX || 
						_tarKey === KEY_ARRAY_INSERT_BEFORE_INDEX) {
						// IndexAfter, IndexBefore
						if (_tarKey === KEY_ARRAY_INSERT_AFTER_INDEX) {
							iIndex = _value + 1;
						} else {
							//the index is from end
							iIndex = arrOri.length - _value - 1;
						}
						arrOri.splice(iIndex, 0, {}); // add fake value
					}

					if (iIndex <= iStart) {
                        iStart++;
                    }
                    if (iIndex <= iEnd) {
                        iEnd++;
                    }

					if ((iIndex > iEnd && !extensionPoint.includes(KEY_ARRAY_INSERT_END)) ||
						(iIndex < iStart && !extensionPoint.includes(KEY_ARRAY_INSERT_BEGIN)) ||
						(iIndex > iStart && iIndex < iEnd)) {
						pass = false;
						results.push({
							result: false, 
							message: sMessage
						});
					}
				}
				if (item["Value"] && typeof(item["Value"]) === "object") {
					// validate "_Name" in "Value" properties
					Object.keys(item["Value"]).forEach(prop => {
						if (prop === KEY_NAME_METADATA && this.allControlNames.includes(item["Value"][prop])) {
							pass = false;
							results.push({
								pass: false, 
								message: `_Name "${item["Value"][prop]}" in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""} is duplicate with the one in base project.`
							});
						}
					});
				}

				if (pass) {
					results.push({ pass: true });
				}
			});
		}

		return results;
	}

	_validateArrayExtensionPoint(key, name, extensionKey, extensionPoint) {
		let result = { pass: true };
		let sMessage = `"${key}" is not allowed in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""}.`;
		switch(key) {
			case KEY_ARRAY_REMOVE:
				if (!extensionPoint.includes(KEY_ARRAY_REMOVE)) {
					result.pass = false;
					result.message = sMessage;
				}
				break;
			case KEY_ARRAY_REORDER:
				if (!extensionPoint.includes(KEY_ARRAY_REORDER)) {
					result.pass = false;
					result.message = sMessage;
				}
				break;
			case KEY_ARRAY_ADD:
				if (!extensionPoint.includes(KEY_ARRAY_INSERT_BEGIN) && 
					!extensionPoint.includes(KEY_ARRAY_INSERT_END) && 
					!extensionPoint.includes(KEY_ARRAY_INSERT_ANY)) {
					result.pass = false;
					result.message = sMessage;
				}
				break;
			default:
				result.pass = false;
				result.message = `"${key}" is not recognized in _ExtensionPoint "${extensionKey}"${name ? " of \"" + name + "\"" : ""}.`;
				break;
		}

		return result;
	}

	_validateObjectExtensionPoint(oSource, name, key, value, extensionPoint) {
		let result = { pass: true };
		const sMessage = `"${key}" is not allowed in _ExtensionPoint${name ? " of \"" + name + "\"" : ""}.`;
		if (value === VALUE_REMOVED && extensionPoint.includes("Remove")) {
			return result;
		} else {
			if (extensionPoint.includes("Add")) {
				// try to find Object property in source
				if (oSource) {
					const tarObj = this._findObjectByName(oSource, name);
					const oRet = this._getSourceObjectByKey(tarObj, key);
					if (oRet.parent && oRet.parent.hasOwnProperty(oRet.key)) {
						result.pass = false;
						result.message = sMessage;
					}
				}
			} else {
				result.pass = false;
				result.message = sMessage;
			}
		}
		
		return result;
	}

	_getExtensionPointsFromJsonFile(obj, ExtensionPointMap) {
		Object.keys(obj).forEach(key => {
			let value = obj[key];
			if (typeof value === "object" && value) {
				if (value[KEY_NAME_METADATA] && value._ExtensionPoint) {
					ExtensionPointMap.set(value[KEY_NAME_METADATA], value._ExtensionPoint);
				}
				this._getExtensionPointsFromJsonFile(value, ExtensionPointMap);
			}
		});
	}

	_getExtensionPointsFromJsFile(sContent, ExtensionPointMap) {
		const linesWithStart = sContent.match(RegexJSExtContentStart);
		const linesWithEnd = sContent.match(RegexJSExtContentEnd);
		linesWithStart?.forEach(line => {
			const startNamers = line.match(RegexJSExtLineStart);
			ExtensionPointMap.set(startNamers?.[1] + START_POSTFIX, true);
		});
		linesWithEnd?.forEach(line => {
			const endNames = line.match(RegexJSExtLineEnd);
			ExtensionPointMap.set(endNames?.[1] + END_POSTFIX, true);
		});
	}

	_getExtensionPointForObject(sKey, extensionPoint) {
		if (typeof extensionPoint === "object" && sKey.indexOf(KEY_SEP) > 0) {
			const aKey = sKey.split(KEY_SEP);
			let tarKey = [];
			for (let i = 0; i < aKey.length - 1; i++) {
				tarKey.push(aKey[i]);
				let oVal = extensionPoint[tarKey.join(KEY_SEP)];
				if (oVal) {
					return oVal;
				}
			}
		}
		return null;
	}

	_getSourceObjectByKey(oSource, sKey) {
		if (sKey.indexOf(KEY_SEP) <= 0) {
			return { parent: oSource, key: sKey };
		} else {
			let aKey = sKey.split(KEY_SEP);
			let oParent = oSource;
			for (let i = 0; i < aKey.length - 1; i++) {
				oParent = oParent[aKey[i]];
			}
			return { parent: oParent, key: aKey[aKey.length - 1] };
		}
	}

	_findObjectByName(obj, name) {
		if (!name) {
			return obj;
		}
		for (const key in obj) {
			if (obj.hasOwnProperty(key)) {
				const value = obj[key];

				if (key === '_Name' && value === name) {
					return obj;
				}

				if (typeof value === 'object' && value !== null) {
					const foundObject = this._findObjectByName(value, name);
					if (foundObject !== null) {
						return foundObject;
					}
				}

				if (Array.isArray(value)) {
					for (const item of value) {
						if (typeof item === 'object' && item !== null) {
							const foundObject = this._findObjectByName(item, name);
							if (foundObject !== null) {
								return foundObject;
							}
						}
					}
				}
			}
		}

		return null;
	}

	_getAllNames(obj) {
		Object.keys(obj).forEach(key => {
			const value = obj[key];
			if (key === '_Name') {
				this.allControlNames.push(value);
			} else if (typeof value === 'object' && value !== null) {
				this._getAllNames(value);
			}
		});
	}

	async _getDocumentJson(fileFullPath) {
		let data = await this._getDocumentContent(fileFullPath);
		return JSON.parse(data);
	}

	async _getDocumentContent(fileFullPath) {
		return new Promise(resolve => {
			fs.readFile(fileFullPath, JSON_FILE_ENCODING, (err, data) => {
				if (err) {
					console.log(err);
					resolve("{}");
				} else {
					resolve(data);
				}
			});
		});
	}

	async validate() {
		if (!this.appExtPath) {
			throw new Error('The parameter "sAppExtPath" is required.');
		}
		let mergeMapFilesPath = this._getAllMergeMapFilesPath(this.appExtPath);
		for (const filePath of mergeMapFilesPath) {
			try {
				let baseFilePath = this._getBaseFilePath(filePath);
				if (baseFilePath) {
					const mergemapObj = await this._getDocumentJson(filePath);
					const baseFileExtName = path.extname(baseFilePath).toLowerCase();
					if (_SUPPORTED_JSON_FILE_EXT.includes(baseFileExtName)) { // for JSON file
						let sourceObj = await this._getDocumentJson(baseFilePath);
						this._validateForJsonFile(mergemapObj, sourceObj, filePath);
					} else if (baseFileExtName === ".js") { // for js file
						const sourceContent = await this._getDocumentContent(baseFilePath);
						this._validateForJsFile(mergemapObj, sourceContent, filePath);
					}
				}
			} catch (error) {
				console.log(filePath);
				console.log(error);
			}
		}

		return this.diagnostics;
	}

	async validateOne(sMergeContent, sBaseContent, isJs) {
		if (sMergeContent && sBaseContent) {
			try {
				const mergemapObj = JSON.parse(sMergeContent);
				if (isJs) {
					this._validateForJsFile(mergemapObj, sBaseContent);
				} else {
					const sourceObj = JSON.parse(sBaseContent);
					this._validateForJsonFile(mergemapObj, sourceObj);
				}
			} catch (error) {
				console.log(error);
			}
		}

		return this.diagnostics;
	}
}

exports.MergeMapValidator = MergeMapValidator;
