const betaFn = require('./BETA.runtime');
const binomDist = require('./BINOMDIST.runtime');
const gammaLn = require('./GAMMALN.runtime');

const betacf = (x, a, b) => {
  const fpmin = 1e-30;
  const qab = a + b;
  const qap = a + 1;
  const qam = a - 1;
  let c = 1;
  let d = 1 - qab * x / qap;
  let m2;
  let aa;
  let del;
  let h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin) {
    d = fpmin;
  }

  d = 1 / d;
  h = d;

  for (let m = 1; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));

    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));

    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7) {
      break;
    }
  }
  return h;
};

const ibeta = (x, a, b) => {
  const bt = (x === 0 || x === 1)
    ? 0
    : Math.exp(gammaLn([a + b]) - gammaLn([a])
      - gammaLn([b]) + a * Math.log(x) + b
      * Math.log(1 - x));
  if (x < (a + 1) / (a + b + 2)) {
    return bt * betacf(x, a, b) / a;
  }
  return 1 - bt * betacf(1 - x, b, a) / b;
};

const probabilityFDist = (x, df1, df2) => {
  if (x < 0) {
    return null;
  }

  if (df1 <= 2) {
    if (x === 0 && df1 < 2) {
      return Infinity;
    }
    if (x === 0 && df1 === 2) {
      return 1;
    }
    return (1 / betaFn([df1 / 2, df2 / 2]))
      * ((df1 / df2) ** (df1 / 2))
      * (x ** ((df1 / 2) - 1))
      * ((1 + (df1 / df2) * x) ** (-(df1 + df2) / 2));
  }

  const p = (df1 * x) / (df2 + x * df1);
  const q = df2 / (df2 + x * df1);
  const f = df1 * q / 2.0;
  return f * binomDist([(df1 - 2) / 2, (df1 + df2 - 2) / 2, p]);
};

const cumulativeFDist = (x, df1, df2) => {
  if (x < 0) {
    return null;
  }
  return ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
};

module.exports = ([value, degrees1, degrees2, cumulative]) => {
  if (!(typeof value === 'number' && Number.isFinite(value))) {
    return null;
  }
  if (!(typeof degrees1 === 'number' && Number.isFinite(degrees1))) {
    return null;
  }
  if (!(typeof degrees2 === 'number' && Number.isFinite(degrees2))) {
    return null;
  }

  const result = cumulative
    ? cumulativeFDist(value, degrees1, degrees2)
    : probabilityFDist(value, degrees1, degrees2);
  return Number.isFinite(result) ? result : null;
};
