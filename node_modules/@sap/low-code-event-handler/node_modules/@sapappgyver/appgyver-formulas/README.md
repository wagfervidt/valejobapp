AppGyver Formulas
=================

Editor and runtime support for **[AppGyver Formula language](./docs/FORMULAS.md)** (previously known as _DOLAN expressions_).

**ðŸ“£ NOTE**: Before version 16.0.0 this library was previously released as [`@appgyver/formulas`](https://github.com/AppGyver/formulas). The development continues on this repository as `@sapappgyver/appgyver-formulas`!

## Getting started

Install the library to your project:

    npm install --save @sapappgyver/appgyver-formulas

The same package is used for both editor and runtime, in different modules.

- See **[Editor usage](#editor-usage)** for how to use the parser, analyze formulas, and export them for the runtime.
- See **[Runtime usage](#runtime-usage)** for how to run expressions.

## Editor usage

Validate and analyzing an expression works in the following steps:

1. **Parse** an expression string. Returns informatino if the **syntax** is valid or invalid.
2. **Analyze** the parsed expression by providing a context [schema][schema]. Provides info if the **semantic usage** is valid.
3. **Export** the expression to the format that can be saved to DOLAN and is accepted by the runtime.


### Parsing an expression string

```javascript
const { parseExpression } = require('@sapappgyver/appgyver-formulas/parser');

// Parse the expression
const expression = parseExpression('pageVars.myVariable + 2');
// Check if the expression is valid
if (expression.syntaxError) {
    console.error(`Cannot parse the expression:`, expression.syntaxError);
}
```

### Analyzing a parsed expression

```javascript
// Define the schema for each key in the context
const contextSchema = {
    // NOTE: Each "schema" must be the subset of JSONSchema supported by AppGyver
    pageVars: {
        type: 'object',
        properties: {
            myVariable: {
                type: 'number',
            },
        },
    },
};
// Perform analysis for the expression with a context schema
const analysis = expression.analyze(contextSchema);
// Check if there are any semantic errors (e.g. invalid type usage)
if (analysis.errors.length > 0) {
    console.warn(`Expression has errors:`, analysis.errors);
}
// Get the schema of the evaluated result of the expression
console.log(`Expression result schema:`, analysis.schema);
```

All the **schemas** used by the library match the [schema JSON representation format][schema].

Note that if the schema objects nested in the `contextSchema` contains `enum` or `examples`, the result schema will contain evaluated `enum` and `examples` accordingly, if possible.

If the expression is required to return a value compatible with some schema, you may provide the required return schema:

```javascript
const analysis = expression.analyze(contextSchema, { type: 'string' });
// Check if there are any semantic errors or if the return type is invalid
if (analysis.errors.length > 0) {
    console.warn(`Expression has errors:`, analysis.errors);
}
```

### Analyze timeouts

You may optionally define a timeout used for evaluating example return values for the formula.
Note: this is not the timeout for the whole analysis, just for example value executions.
If an execution times out, then the return schema might have some example values missing, but the function will not throw an error.

```javascript
const analysis = expression.analyze(contextSchema, { type: 'string' }, { executionTimeout: 5000 });
```

### Export expression for runtime

You should save the expression as an object that can be executed effeciently on runtime:

```javascript
// Export the experssion
const exportedExpression = expression.export();
```

The export generates a JSON-serializable object like this:

```javascript
{
    "formula": "SUM(pageVars.myNumbers) + 2",
    "script": "SUM(LOOKUP(pageVars,\"myNumbers\")+2",
    "dependencies": [
        ["pageVars", "myNumbers"]
    ],
    "functions": [
        "SUM", "LOOKUP",
    ]
}
```

You may safely store the exported expression objects, serialize them as JSON, etc. but **never** alter the contents of the object directly!
Doing so may prevent the [runtime](#runtime-usage) for executing it correctly or [re-importing](#importing-expressions) it again! You should only use exported expression objects together with [`importExpression`](#importing-expressions) and [`prepareExpression`](#runtime-usage).

You should **avoid relying on the properties of the exported object** too much! You _may_ read the contents, for example, to get information for optimizing your runtime usage.
Here's a reference for possible properties in exported expression objects:

Property       | Type     | Description
---------------|----------|------------
`formula`      | `string` | The original expression formula that was parsed
`script`       | `string` | JavaScript implementation of the formula. Never use this directly! Instead, always follow the [correct runtime usage](#runtime-usage)!
`dependencies` | `string[][]` | List of "accessor paths" describing what information the expression needs from the provided context object. You can use this information to optimize your runtime.
`functions`    | `string[]` | List of function names used by the expression on runtime. It may contain helper functions in addition to the ones written in formula.
`inverse`      | `string` | JavaScript for the **inverse evaluation**. Present if the formula supports inversion, otherwise omitted. Never use this directly, but instead follow the [inverse execution usage](#inverse-execution)!
`inverts`      | `string[][]` | List similar to `dependencies`, describing what "paths" in the context would be updated by an inverse evaluation. Present if the formula supports inversion **and if not equal to `dependencies`**, otherwise omitted.
`isConstant`   | `true`/`undefined` | Whether or not executing the expression _will always results to an equal value_. Value `true` implies that `dependencies` is empty, and `functions` is either empty or only contains deterministic functions. Instead of `false`, this property is omitted.
`isPointer`    | `true`/`undefined` | Whether or not the formula only consists of one context usage, followed by any number of property accessors, and _nothing else_. If `true` then `dependencies` has _exactly one_ array, and `functions` is empty or only contains `LOOKUP`. Instead of `false`, this property is omitted.


## Importing expressions

A previously [exported expression](#export-expression-for-runtime) can be re-imported again, with similar result than `parseExpression`:

```javascript
const { importExpression } = require('@sapappgyver/appgyver-formulas/parser');

const importedExpression = importExpression(exportedExpression);
```


## Runtime usage

### Executing expressions

Executing an expression consists of two phases:

1. Prepare an executable expression object using `prepareExecutable(exportedExpression)`
2. Run the `execute(context)` method whenever you want to evaluate the expression

For the best performance, if you want to evaluate the same expression multiple times, it is recommended to cache the instance returned by `prepareExecutable` and then call `execute` method whenever you want to get the latest value.

**Example**: evaluating an expression with immutable context:

```javascript
const { prepareExecutable } = require('@sapappgyver/appgyver-formulas/runtime');

// Create an executable expression from a previously exported expression, bound to the context.
// Let's assume here that the original formula is "pageVars.myVariable + 2"
const executable = prepareExecutable(exportedExpression);

// Set up a runtime context for the first run
const context1 = {
    pageVars: {
        myVariable: 3,
    },
};

// Evaluate the expression, throwing an exception if there are some critical errors
try {
    console.log(executable.execute(context1));  // Prints 5 with 'pageVars.myVariable + 2'
} catch (error) {
    console.error(`Failed to evaluate the expression:`, error);
}

// Set up a runtime context for the second run.
// NOTE: The context should always have the same set of root-level keys, even though their VALUES may change!
const context2 = {
    pageVars: {
        myVariable: 10, // Different value here
    },
};

// Re-evaluate the expression
try {
    console.log(executable.execute(context2));  // Prints 12 with 'pageVars.myVariable + 2'
} catch (error) {
    console.error(`Failed to evaluate the expression:`, error);
}
```

You can check if the execution would fail due to syntax error before calling `execute` method:

```javascript
if (executable.syntaxError) {
    console.error(`Evaluating the expression would fail:`, executable.syntaxError);
}
```

**Example**: evaluating an expression with mutated context:

```javascript
const { prepareExecutable } = require('@sapappgyver/appgyver-formulas/runtime');

// Set up a runtime context
const context = {
    pageVars: {
        myVariable: 3,
    },
};
// Create an executable expression from a previously exported expression, bound to the context.
// Let's assume here that the original formula is "pageVars.myVariable + 2"
const executable = prepareExecutable(exportedExpression, context);

// Evaluate the expression, throwing an exception if there are some critical errors
try {
    console.log(executable.execute());  // Prints 5 with 'pageVars.myVariable + 2'
} catch (error) {
    console.error(`Failed to evaluate the expression:`, error);
}

// Mutate the context
// NOTE: Root-level keys must NOT be changed, but their values can be changed!
context.pageVars.myVariable = 10;

// Re-evaluate the expression
try {
    console.log(executable.execute());  // Prints 12 with 'pageVars.myVariable + 2'
} catch (error) {
    console.error(`Failed to evaluate the expression:`, error);
}
```

### Execution timeouts

You may define a timeout (in milliseconds) after which the formula evalution is attempted to terminate as soon as possible, and `execute` will then throw a `TimeoutError`:

```javascript
// Evaluate the expression, throwing an exception if there are some critical errors or a timeout
try {
    console.log(executable.execute(context, { timeout: 5000 }));
} catch (error) {
    // Error might be a `TimeoutError`
    if (error.name === 'TimeoutError') {
        console.error('Expression evaluation timed out');
    }
}
```

Note that the timeout is not strict, so it might take slightly longer for the execution to interrupt.
Without the `timeout` option, the evaluation continues until complete.

### Executing parsed expressions

If you have an expression instance received using [`parseExpression`](#parsing-an-expression-string) or [`importExpression`](#importing-expressions), you can convert them directly to an executable using `toExecutable`, without a need to export them first:

```javascript
const { parseExpression } = require('@sapappgyver/appgyver-formulas/parser');

// Parse the expression
const expression = parseExpression('pageVars.myVariable + 2');
// Convert to an executable
const executable = expression.toExecutable();
// Prepare the context
const context = {
    pageVars: {
        myVariable: 3,
    },
};
// Evaluate
console.log(executable.execute(context));
```

### Inverse execution

Some formulas support **inverse execution**.
This means that the formula can be evaluated in reverse: you provide the **expected return value**, and you get the altered context as a result.
You need to provide the inverse execution the **current context** object and the **altered result**, and it will build the updated context for you.

Start by ensuring you have an executable, exactly like when [executing expressions](#executing-expressions):

```javascript
// Example formula that sorts strings
const exportedExpression = parseExpression('SORT_BY_KEY(pageVars.animals, "name")').export();

// You then prepare the executable normally
const executable = prepareExecutable(exportedExpression);
// An example initial context
const context = {
    pageVars: {
        animals: [
            { name: "horse", age: 2 },
            { name: "cat", age: 1 },
            { name: "dog", age: 3 },
        ],
    },
};
// If you execute the expression, you get the sorted array (optional step here)
const sortedAnimals = executable.execute(context);
console.log(sortedAnimals); // This would log animals in order: cat, dog, horse
```

Let's say that you would want to update the "age" property of the first item
in the **sorted** array, which in this case is the "cat". This can be done like this:

```javascript
const updatedSortedAnimals = sortedAnimals.slice();
updatedSortedAnimals[0] = { ...updatedSortedAnimals[0], age: 4 };

// You can invert this update back to the original context using the `invert` method:
const updatedContext = executable.invert(
    updatedSortedAnimals, // The "updated" result
    context, // The current context
);
// This would log the changed root-properties of the context!
console.log(updatedContext);
// Note how the updated "cat" is at its ORIGINAL position!
// {
//     pageVars: {
//         animals: [
//             { name: "horse", age: 2 },
//             { name: "cat", age: 4 },
//             { name: "dog", age: 3 },
//         ],
//     },
// }
```

**IMPORTANT:** Always assume full immutability! Never modify the objects returned by `execute` or `invert` directly!

If you would like to know what sub-properties of the context have changed, you can check the `inverts` property of the executable:

```javascript
console.log(executable.inverts);
```

This logs the list of paths that **may** have changed:

```javascript
[
    ["pageVars", "animals"],
    // etc.
]
```

If you still want to know what **actually** changed, just compare the old and updated context **at each of these paths**.
Shallow equality check is also likely enough for you.


## Refactoring expressions

You can rename context variable usage in an expression:

```javascript
// Parse the original expression
const oldExpression = parseExpression('2 * myVariable + 3');
// Get a renamed expression instance
const newExpression = oldExpression.rename({
    myVariable: 'myRenamedVariable',
});
// This logs '2 * myRenamedVariable + 3'
console.log(newExpression.formula);
```

You can also rename member accessors:

```javascript
// Parse the original expression
const oldExpression = parseExpression('"Name: " + user.name');
// Get a renamed expression instance
const newExpression = oldExpression.rename({
    user: {
        name: 'full_name',
    },
});
// This logs '"Name: " + user.full_name'
console.log(newExpression.formula);
```

## Command line usage

You can try out formulas on command line:

```bash
npm i -g @sapappgyver/appgyver-formulas
formula 'foo.bar + "â‚¬"' '{"foo":{"bar":123}}'
# The command will output: "123â‚¬"
```

Or alternatively using `npx`:

```bash
npx -p @sapappgyver/appgyver-formulas formula 'foo.bar + "â‚¬"' '{"foo":{"bar":123}}'
# The command will output: "123â‚¬"
```

The command takes two parameters:

1. the formula as a string
2. an optional context object as a JSON-encoded string

## Development

To start contributing to this repository, **please read and follow the [contribution guidelines](./CONTRIBUTING.md)**!

Ensure that you are using the correct Node version with nvm:

    nvm use

Install dependencies:

    npm install

Run tests:

    npm test

You should enable your editor to use ESLint, but you can also lint by the command line:

    npm run lint

Build JavaScript representation of the grammar from the Nearly syntax:

    npm run build

## Releasing

To release a new version of this package:

1. Ensure `main` branch contains changes you want to release (by merging pull requests)
2. Update [`CHANGELOG.md`](./CHANGELOG.md) to contain change log for the new upcoming version
3. Bump the version number but **do not create a tag** by running one of the following, depending on the nature of your release:
    - `npm version --no-git-tag-version major`
    - `npm version --no-git-tag-version minor`
    - `npm version --no-git-tag-version patch`
4. Commit the changes with a commit message equal to the version number (e.g. `16.0.0`)
5. Push the commit to remote: `git push origin main`
6. Ensure in GitHub that automated tests have passed for the commit
7. Go to [GitHub Releases page](https://github.tools.sap/AppGyver/appgyver-formulas/releases) and create a new release:
    - Create a new tag for the release matching the version number, prefixed with `v` (e.g. `v16.0.0`)
    - The name of the release must be equal to the version tag name (e.g. `v16.0.0`)
    - To the changelog, copy-paste the Markdown from the [`CHANGELOG.md`](./CHANGELOG.md) entry you wrote earlier
8. Automated release pipeline will publish the new version of `@sapappgyver/appgyver-formulas` package

### Updating dependencies
Update the formula version in the following repositories and bump the npm version for them if needed:

- [orchestra](https://github.com/AppGyver/orchestra)
- [platform](https://github.com/AppGyver/platform)
- [node-red](https://github.com/AppGyver/node-red)
- [logic-runner](https://github.com/AppGyver/logic-runner)
- [api-configurator](https://github.com/AppGyver/api-configurator)

Here are some example pull requests that update the formula version to 14.18.0:

```
https://github.com/AppGyver/api-configurator/pull/91
https://github.com/AppGyver/orchestra/pull/866
https://github.com/AppGyver/logic-runner/pull/8
https://github.com/AppGyver/node-red/pull/25
https://github.com/AppGyver/platform/pull/1137
```

## Troubleshooting

### npm ERR! code E401

Description:
"npm ERR E401! Incorrect or missing password."

Fix by:
``` bash
npm set //npm.pkg.github.com/:_authToken $GITHUB_TOKEN
```
Where `$GITHUB_TOKEN` is your GitHub access token.


[schema]: https://github.tools.sap/AppGyver/appgyver-schemas/blob/main/docs/SCHEMA.md
