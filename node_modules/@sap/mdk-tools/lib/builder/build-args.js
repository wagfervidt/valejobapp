const commandLineArgs = require('command-line-args');
const path = require('path');
const process = require('process');
const logger = require('../logger');
const { WEB_SOURCE_FOLDER, WEB_MODULE_FOLDER, WEB_FACTORY_NAME, BUILD_TARGET, REPORT_CONTENT } = require('../utils');
const fs = require('fs');

const optionDefinitions = [
  { name: 'target', type: String, multiple: false },
  { name: 'project', type: String, multiple: false },
  { name: 'name', type: String, multiple: false },
  { name: 'dist', type: String, multiple: false },
  { name: 'forceUpdate', type: Boolean, multiple: false },
  { name: 'ui5', type: Boolean, multiple: false },
  { name: 'externals', type: String, multiple: true },
  { name: 'filters', type: String, multiple: true },
  { name: 'ts-target', type: String, multiple: false },
  { name: 'runtime', type: String, multiple: false },
  { name: 'recursive', type: Boolean, multiple: false },
  { name: 'wmf', type: Boolean, multiple: false },
  { name: 'logFile', type: String, multiple: false },
  { name: 'log', type: Boolean, multiple: false },
  //below for internal usage
  { name: 'devtool',type: String, multiple: false },
  { name: 'bundle-zip-target-path',type: String, multiple: false },
  { name: 'web', type: Boolean, multiple: false },
  { name: 'validate', type: Boolean, multiple: false },
  { name: 'file', type: String, multiple: false },
  { name: 'content', type: String, multiple: false },
  { name: 'fromProject', type: String, multiple: false }
];

class BuildArgs {
  constructor() {
    this.options = commandLineArgs(optionDefinitions);
    this._processArguments();
  }

  target() {
    return this.options['target'];
  }

  name() {
    return this.options['name'];
  }

  project() {
    return this._getProjectFolder();
  }

  fromProject() {
    if (this.options['fromProject']) {
      let fullPath = path.resolve(this.options['fromProject']);
      if (fs.existsSync(fullPath)) {
        return fullPath;
      } else {
        console.error(`failed to find path ${fullPath}`);
        process.exit(-1);
      }
    } else {
      return "";
    }
  }

  forceUpdate() {
    return !!this.options['forceUpdate'];
  }

  ui5() {
    return !!this.options['ui5'];
  }

  dist() {
    let sProjectFolder = this._getProjectFolder();
    if (this.options['dist']) {
      return path.resolve(this.options['dist']);
    } else {
      if (this.options['target'] == BUILD_TARGET.MODULE) {
        return path.resolve(`${sProjectFolder}/${WEB_SOURCE_FOLDER}/${WEB_MODULE_FOLDER}`);
      } else {
        return path.resolve(path.join(sProjectFolder, "..", WEB_FACTORY_NAME));
      }
    }
  }

  externals() {
    return this.options['externals'] || [];
  }

  filters() {
    return this.options['filters'] || [];
  }

  tsTarget() {
    return this.options['ts-target'];
  }

  runtime() {
    return this.options['runtime'] || "";
  }

  recursive() {
    return !!this.options['recursive'];
  }

  useWmf = function() {
    return !!this.options['wmf'];
  }

  setProject(sProject) {
    if (sProject) {
      this.options['project'] = sProject;
    }
  }

  logFile() {
    if (this.options['logFile']) {
      return path.resolve(this.options['logFile']);
    } else {
     return "";
    }
  }

  log = function() {
    return !!this.options['log'];
  }

  devtool() {
    return this.options['devtool'];
  }

  bundleZipTargetPath() {
    var targetPath = this.options['bundle-zip-target-path'];
    if (!targetPath) return "";
    return path.resolve(path.normalize(targetPath));
  }

  web = function() {
    return !!this.options['web'];
  }

  validate = function() {
    return !!this.options['validate'];
  }

  file = function() {
    if (this.options['file']) {
      return path.resolve(this.options['file']);
    } else {
     return "";
    }
  }

  content = function() {
    return this.options['content'];
  }

  _getProjectFolder() {
    if (this.options['project']) {
      let fullPath = path.resolve(this.options['project']);
      if (fs.existsSync(fullPath)) {
        return fullPath;
      } else {
        console.error(`failed to find path ${fullPath}`);
        process.exit(-1);
      }
    } else {
      let sCurrentPath = process.cwd();//process.env.INIT_CWD ? process.env.INIT_CWD : process.env.OLDPWD;
      return sCurrentPath;

    }
  }

  _processArguments() {
    function getMissingRequiredArgumentMessage(options) {
      if (!options['target']) {
        return logger.getError('Missing target options');
      }
      if ((options['target'] !== BUILD_TARGET.MODULE) && (options['target'] !== BUILD_TARGET.MTA)
        && (options['target'] !== BUILD_TARGET.JS) && (options['target'] !== BUILD_TARGET.ZIP)
        && (options['target'] !== BUILD_TARGET.SOURCE) && (options['target'] !== BUILD_TARGET.REPORT)) {
        return logger.getError(`Target should be ${BUILD_TARGET.MODULE}|${BUILD_TARGET.MTA}|${BUILD_TARGET.JS}|${BUILD_TARGET.ZIP}|${BUILD_TARGET.SOURCE}`);
      }

      if (options['target'] === BUILD_TARGET.REPORT) {
        if (!options['content']) {
          return logger.getError(`Please specify report content to "${REPORT_CONTENT.EXTENSION_DEFINE}" or "${REPORT_CONTENT.EXTENSION_USING}" by --content.`);
        } else if (options['content']!==REPORT_CONTENT.EXTENSION_DEFINE && options['content']!==REPORT_CONTENT.EXTENSION_USING && options['content']!==REPORT_CONTENT.COMPARE_BASE) {
          return logger.getError(`content must be "${REPORT_CONTENT.EXTENSION_DEFINE}", "${REPORT_CONTENT.EXTENSION_USING}" or "${REPORT_CONTENT.COMPARE_BASE}"`);
        }
        if (options['content']===REPORT_CONTENT.COMPARE_BASE && !options['fromProject']) {
          return logger.getError("please specify --fromProject ");
        }
      }

      return null;
    }

    const missingArgumentMessage = getMissingRequiredArgumentMessage(this.options);
    if (missingArgumentMessage) {
      console.error(missingArgumentMessage);
    }
    if (missingArgumentMessage) {//|| options.help
      const getUsage = require('command-line-usage')

      const sections = [
        {
          header: 'Build MDK to Web Application',
          content: 'Build MDK metadata project to a Web module or MTA application with Web Module.'
        },
        {
          header: 'Options',
          optionList: [
            {
              name: 'target',
              typeLabel: '',
              description: '[common] Type of the build result, it can be js, zip, module,mta and report.'
            },
            {
              name: 'project',
              typeLabel: '{underline folder}',
              description: '[common] The location of the mdk application definitions.By default it\'s current folder.'
            },
            {
              name: 'devtool',
              description: '[common] Choose a style of source mapping to enhance the debugging process. e.x. source-map'
            },
            {
              name: 'externals',
              typeLabel: '{underline module-name module-name ...}',
              description: '[common] Space-delimited list of NPM modules to be excluded from the bundle. Use this option for dependencies you expect to be in the environment when the application is built.  '
            },
            {
              name: 'filters',
              typeLabel: '{underline module-name module-name ...}',
              description: '[common] Space-delimited list of files excluded from the bundle.'
            },
            {
              name: 'ts-target',
              typeLabel: '',
              description: '[common] typescript loader for es5 or es6.'
            },
            {
              name: 'wmf',
              type: Boolean,
              description: '[common] If this option is specified, the script will use Webpack Module Federation to generate the bundle.'
            },
            {
              name: 'bundle-zip-target-path',
              description: '[common] The location of the target for bundle zip. If this is specified, the bundle zip will be copied into it.'
            },

            {
              name: 'name',
              typeLabel: '',
              description: '[web] The app name in web deployment. '
            },
            {
              name: 'dist',
              typeLabel: '{underline folder}',
              description: '[web] The location of the build result.'
            },
            {
              name: 'forceUpdate',
              type: Boolean,
              description: '[web] If force update dist folder.'
            },
            {
              name: 'ui5',
              type: Boolean,
              description: '[web] If use ui5 wrapper, '
            },    
            {
              name: 'runtime',
              typeLabel: '',
              description: '[web] production, preview or development url. '
            },
            {
              name: 'recursive',
              type: Boolean,
              description: '[web] if find projects recursive.'
            },  
            {
              name: 'logFile',
              typeLabel: '',
              description: '[mobile] The file to log.'
            },
            {
              name: 'log',
              type: Boolean,
              description: '[mobile] If output details for log'
            },
            {
              name: 'validate',
              type: Boolean,
              description: '[mobile] If this option is specified, it will validate metadata before build.'
            },
            {
              name: 'file',
              description: '[report] If this option is specified, it will generate extension points report.'
            },
            {
              name: 'content',
              description: '[report]  content type for building report. it can be define, using or compare.'
            },
            {
              name: 'fromProject',
              description: '[report]  the compare project when build compare report'
            }
          ]
        }
      ]
      const usage = getUsage(sections);
      console.log(usage);
      process.exit(-1);
    }

    const sProjectFolder = this._getProjectFolder();
    if (!this.options['dist']) {
      if (this.options['target'] == BUILD_TARGET.MODULE) {
        console.log(logger.getInfoMore('dist') + logger.getPrefix(' was not specified, so use ') + logger.getInfoMore(path.resolve(sProjectFolder, "Web/MDKModule")) + logger.getPrefix(' as target.'));
      } else if (this.options['target'] == BUILD_TARGET.MTA) {
        let sParentFolder = sProjectFolder.substr(0, sProjectFolder.lastIndexOf(path.sep));
        console.log(logger.getInfoMore('dist') + logger.getPrefix(' was not specified, so use ') + logger.getInfoMore(path.resolve(sParentFolder, "WebApplicationFactory")) + logger.getPrefix(' as target.'));
      }
    }
  }

}
exports.BuildArgs = BuildArgs;

