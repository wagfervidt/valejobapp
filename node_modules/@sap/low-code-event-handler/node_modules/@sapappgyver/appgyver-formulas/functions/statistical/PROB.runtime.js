const calculateProb = (values, probs, lowLimit, highLimit) => {
  if (values.length !== probs.length) {
    return null;
  }
  if (!values.length) {
    return null;
  }
  const combinedProb = values.reduce((total, item, index) => {
    const prob = probs[index];
    const obj = { value: item, prob };
    return [...total, obj];
  }, []);

  const totalProb = combinedProb.reduce((total, item) => total + item.prob, 0);
  if (Math.abs(1 - totalProb) > 0.00000001) {
    return null;
  }

  const guessProb = combinedProb.reduce((total, item) => {
    const { prob, value } = item;
    return (value >= lowLimit && value <= highLimit)
      ? total + prob
      : total;
  }, 0);
  return guessProb;
};

module.exports = ([values, probs, lowLimit, highLimit]) => {
  if (!(Array.isArray(values) && Array.isArray(probs))) {
    return null;
  }
  if (typeof lowLimit !== 'number' || !Number.isFinite(lowLimit)) {
    return null;
  }
  const highLimitValid = (highLimit == null) ? lowLimit : highLimit;
  if (typeof highLimitValid !== 'number' || !Number.isFinite(highLimitValid)) {
    return null;
  }

  const valueIncorrect = values.findIndex(item => (typeof item !== 'number' || !Number.isFinite(item)));
  const probIncorrect = probs.findIndex(item => (
    typeof item !== 'number'
      || !Number.isFinite(item)
      || !(item >= 0 && item <= 1)
  ));

  if ((valueIncorrect + 1) || (probIncorrect + 1)) {
    return null;
  }
  const result = calculateProb(values, probs, lowLimit, highLimitValid);
  return Number.isFinite(result) ? result : null;
};
