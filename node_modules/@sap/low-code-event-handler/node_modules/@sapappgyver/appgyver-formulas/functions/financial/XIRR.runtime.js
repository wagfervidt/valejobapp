const { parseDateTime } = require('../../datetime');
const YEARFRAC = require('../date/YEARFRAC.runtime');

// Calculates the resulting amount
const irrResult = (values, dates, rate) => {
  const r = rate + 1;
  let result = values[0];
  // eslint-disable-next-line no-plusplus
  for (let i = 1; i < values.length; i++) {
    result += values[i] / (r ** YEARFRAC([dates[i], dates[0], 'actual_365']));
  }
  return result;
};

// Calculates the first derivation
const irrResultDeriv = (values, dates, rate) => {
  const r = rate + 1;
  let result = 0;
  // eslint-disable-next-line no-plusplus
  for (let i = 1; i < values.length; i++) {
    const frac = YEARFRAC([dates[i], dates[0], 'actual_365']);
    result -= frac * values[i] / (r ** (frac + 1));
  }
  return result;
};

module.exports = ([array, datesArray, rate]) => {
  if (!Array.isArray(array) || !Array.isArray(datesArray)) {
    return null;
  }
  const validValues = array.filter(item => (typeof item === 'number' && Number.isFinite(item)));
  const validDates = datesArray.filter(item => (parseDateTime(item).isValid()));
  if (!validValues.length || validDates.length !== validValues.length) {
    return null;
  }
  const formatDates = validDates.map(item => parseDateTime(item).format());
  // Check that values contains at least one positive value and one negative value
  let positive = false;
  let negative = false;
  // eslint-disable-next-line no-plusplus
  for (let i = 0; i < validValues.length; i++) {
    if (validValues[i] > 0) {
      positive = true;
    }
    if (validValues[i] < 0) {
      negative = true;
    }
  }

  // Return error if values does not contain at least one positive value and one negative value
  if (!positive || !negative) {
    return null;
  }

  // Initialize guess and resultRate
  const guess = rate || 0.1;
  if (typeof guess !== 'number' && !Number.isFinite(guess)) {
    return null;
  }
  let resultRate = guess;

  // Set maximum epsilon for end of iteration
  const epsMax = 1e-10;

  // Implement Newton's method
  let newRate; let epsRate; let
    resultValue;
  let contLoop = true;
  do {
    resultValue = irrResult(validValues, formatDates, resultRate);
    newRate = resultRate - resultValue / irrResultDeriv(validValues, formatDates, resultRate);
    epsRate = Math.abs(newRate - resultRate);
    resultRate = newRate;
    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
  } while (contLoop);

  // Return internal rate of return
  return Number.isNaN(resultRate) ? null : resultRate;
};
