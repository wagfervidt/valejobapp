const createFile = require('create-file');
const del = require('delete');
const dir = require('node-dir');
const execSync = require('child_process').execSync;
const fs = require('fs-extra');
const path = require('path');
const webpack = require('webpack');
const AdmZip = require('adm-zip');
const watch = require('node-watch');
const globToRegExp = require('glob-to-regexp');
const PathToExportName = require('./PathToExportName');
const timestamp = require('console-timestamp');
const toolUtils = require('../tool-utils');
const logger = require('../logger');
const { getRootPath } = require('../utils.js');
const fail = toolUtils.fail;
const showError = toolUtils.showError;
const isDirectory = toolUtils.isDirectory;
const isFile = toolUtils.isFile;
const exec = toolUtils.exec;
const pathIsNodeModule = toolUtils.pathIsNodeModule;
const os = require('os');
let less = null;
let CSSJSON = null;
let shelljs = null;
try {
  less = require('less');
  CSSJSON = require('cssjson');
} catch (e) {
  console.log('Cannot find module \'less\'');
}
try {
  shelljs = require('shelljs');
} catch (e) {
  console.log('Cannot find module \'shelljs\'');
}
let instance;


/** Webpack plugin responsible for setting up mdkRequire() */

/**
 * @param {string|string[]} moduleAndSpecifiers the module request
 * @returns {Object} the generated source
 */
const getSourceForMdkExternal = moduleAndSpecifiers => {
  if (!Array.isArray(moduleAndSpecifiers)) {
    return {
      expression: `mdkRequire(${JSON.stringify(moduleAndSpecifiers)})`
    };
  }
  const moduleName = moduleAndSpecifiers[0];
  return {
    expression: `mdkRequire(${JSON.stringify(moduleName)})${propertyAccess(
      moduleAndSpecifiers,
      1
    )}`
  };
};

class MdkModule extends webpack.ExternalModule {
  constructor(request, userRequest) {
    super(request, 'mdkrequire', userRequest);
  }
  codeGeneration({ concatenationScope }) {
    let { request, externalType } = this;
    if (typeof request === "object" && !Array.isArray(request))
      request = request[externalType];
    let sourceString = `module.exports = ${getSourceForMdkExternal(request).expression};`;
    const sources = new Map();
    if (this.useSourceMap || this.useSimpleSourceMap) {
      sources.set(
        "javascript",
        new webpack.sources.OriginalSource(sourceString, this.identifier())
      );
    } else {
      sources.set("javascript", new webpack.sources.RawSource(sourceString));
    }
    let runtimeRequirements = new Set([]);
    if (!concatenationScope) {
      runtimeRequirements.add(webpack.RuntimeGlobals.module);
    }
    return {
      sources: sources,
      runtimeRequirements
    };
  }
}

class MdkExternalsPlugin {
  /**
   * @param {Array<string|RegExp>} externals externals config
   */
  constructor(externals) {
    this.externals = externals || [];
  }

  /**
   * Apply the plugin
   * @param {import('webpack').Compiler} compiler the compiler instance
   * @returns {void}
   */
  apply(compiler) {
    compiler.hooks.compile.tap("MdkExternalsPlugin", ({ normalModuleFactory }) => {
      normalModuleFactory.hooks.factorize.tapAsync(
        "MdkExternalsPlugin",
        (data, callback) => {
          const dependency = data.dependencies[0];
          const handleExternal = () => {
            callback(null, new MdkModule(dependency.request, dependency.request));
          }
          for (const external of this.externals) {
            if (external instanceof RegExp) {
              if (external.test(dependency.request)) {
                return handleExternal();
              }
            } else if (typeof external === 'string') {
              if (external === dependency.request) {
                return handleExternal();
              }
            }
          }
          callback();
        });
    });
  }
}

class Bundler {

  constructor(bundlerArgs) {
    this.bundlerArgs = bundlerArgs;
    this.sBaseApplicationName = undefined;
    this.specifiedOutputPath = bundlerArgs.bundleDefinitionPath();

    // provide access to 'this' in chained promise methods
    instance = this;
    if (bundlerArgs.applicationName()) {
      console.error('The application-name argument is deprecated and is no longer used. The app name is now obtained from the _Name property of the Application.app file.');
    }
  }

  // bundler properties
  /**
   * Returns the build locaation 
   */
  get buildOutput() {
    return 'build.definitions';
  }

  /**
   * Returns the full build output path
   */
  get buildOutputPath() {
    return path.join(instance.specifiedOutputPath, instance.buildOutput);
  }

  /**
   * Returns the path to the location of the defintions to bundle
   */
  get clientDefinitionsPath() {
    const useEditorExport = !!instance.bundlerArgs.editorExport();
    return useEditorExport ? instance.exportedApplicationPath : instance.bundlerArgs.mdkBaseApplicationPath();
  }

  get exportedApplicationPath() {
    return path.join(instance.specifiedOutputPath, 'exported-application');
  }

  get uploadBundleContents() {
    return path.join(instance.specifiedOutputPath, 'uploadBundleContents');
  }

  // bundler public methods

  /**
   * This is the main entry point into the bundler functionality
   * 
   * If this is an editor build unzip first before preceeding to
   * promise chain.
   * 
   * Building is the result of a promise chaine that is defined as
   * the following:
   * 
   * - Clone all definitions which now includes components
   * - Move the base application's Application.app to the root build folder
   * - Get a list of all the file paths required in this build
   * - Create an index file that's can be given to webpack to build bundle.js
   * - Update bundle.js depending on where it resides
   * - Clean up the build folder
   */
  buildClientDefinitions() {
    // Pass true to make this call verbose. Temp files aren't expected to exist at this time,
    // so the user should be informed if something is deleted.
    instance._cleanTempFiles(true);

    if (instance.bundlerArgs.editorExport()) {
      instance._unzipEditorExport();
    }

    return instance._assemble()
      .then(instance._createBundlerVersionFile)
      .then(instance._getCIMRootApplication)
      .then((sBaseApplicationApp) => {
        sBaseApplicationApp = sBaseApplicationApp || `/${instance.sBaseApplicationName}/Application.app`;
        instance._rootBaseApplication(sBaseApplicationApp);
      })
      .then(instance._generateBundleFiles)
      .then(instance._createAppIndexFile)
      .then(instance._buildApplicationBundle)
      .then(instance._replaceImport)
      .then(instance._updateBundle)
      .then(instance._watchMetadata)
      //.then(instance._cleanTempFiles) //need to commment this line for debugging and increment build 
      .then(() => { return instance.sBaseApplicationName; })
      .catch(error => {
        instance._cleanTempFiles();
        return Promise.reject(error);
      });
  }

  _watchMetadata() {
    if (!instance.bundlerArgs.shouldWatch()) {
      instance._cleanTempFiles();
      return;
    }

    // watch metadata folder if 'bundle-target-path' isn't specified.
    if (instance.bundlerArgs.bundleTargetPath() == undefined) {
      const mdkBaseApplicationPath = instance.clientDefinitionsPath;
      if (mdkBaseApplicationPath) {
        const DestPath = `${path.join(instance.specifiedOutputPath, 'build.definitions')}/${instance.sBaseApplicationName}`;
        instance._watchFiles(mdkBaseApplicationPath, DestPath,
          (filePath) => {
            const watchFoldersGlobs = [
              mdkBaseApplicationPath + "/Application.app",
              mdkBaseApplicationPath + "/*.cim",
              mdkBaseApplicationPath + "/Actions/**/*.action",
              mdkBaseApplicationPath + "/Pages/**/*.page",
              mdkBaseApplicationPath + "/Rules/**/*.js",
              mdkBaseApplicationPath + "/Services/**/*.service",
              mdkBaseApplicationPath + "/Globals/**/*.global",
              mdkBaseApplicationPath + "/Style/**/*.css",
              mdkBaseApplicationPath + "/i18n/*.properties"
            ];
            // Return true if the path matches any of the globs in watchFolders.
            return watchFoldersGlobs.some(glob => {
              return globToRegExp(glob, { globstar: true }).test(filePath);
            });
          });
      }
    }

    // copy bundle.js and bundle.js.map to target path
    fs.watchFile(path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName()), function () {
      instance._updateBundle();
    });

  }

  _watchFiles(sWatchPath, sTargetPath, fnShouldTriggerBuild) {
    watch(sWatchPath, { recursive: true }, function (event, filePath) {
      if (typeof filePath === "string" && fnShouldTriggerBuild(filePath)) {
        console.log(logger.getPrefix('MDK Bundler - File change detected: ') + logger.getInfoMore(filePath));
        const subPath = filePath.substr(sWatchPath.length);
        shelljs.cp('-r', filePath, path.join(sTargetPath, subPath));
      }
    });
  }


  /**
   * Cleans the build output
   */
  cleanBuild() {
    return Promise.resolve()
      .then(this._cleanProjectIndex)
      .then(this._cleanBuildOutput);
  }

  /**
   * Returns the definition source path for the sepcified component
   * 
   * instance.clientDefinitionsPath + component.ProjectName
   * 
   * @param {object} component 
   */
  componentSourcePath(component) {
    let segments = instance.clientDefinitionsPath.split(path.sep);
    if (!instance.bundlerArgs.editorExport()) {
      // pop the base application name
      segments.pop();
    }

    // construct project path and component path
    if (component.ProjectName && segments[segments.length - 1] !== component.ProjectName) {
      segments.push(component.ProjectName);
    }
    let sComponentProjectPath = segments.length > 0 ? segments.join(path.sep) : "";

    if (component.ApplicationName && component.ProjectName !== component.ApplicationName) {
      segments.push(component.ApplicationName);
    }
    let sComponentApplicationPath = segments.length > 0 ? segments.join(path.sep) : "";

    if (fs.existsSync(sComponentProjectPath)) {
      if (fs.existsSync(path.join(sComponentProjectPath, 'Application.app'))) {
        return sComponentProjectPath;
      } else {
        if (fs.existsSync(sComponentApplicationPath)) {
          if (fs.existsSync(path.join(sComponentApplicationPath, 'Application.app'))) {
            return sComponentApplicationPath;
          } else {
            throw new Error('Cannot find component app at ' + sComponentApplicationPath);
          }
        } else {
          throw new Error('parsed component application path at ' + sComponentProjectPath + " is invalid");
        }
      }
    } else {
      throw new Error('parsed component project path at ' + sComponentProjectPath + ' is invalid');
    }
  }

  createUploadBundle() {
    fs.mkdirSync(instance.uploadBundleContents);
    const bundlePath = path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName());
    if (!fs.existsSync(bundlePath)) {
      throw new Error('Cannot find bundle file at ' + bundlePath);
    }
    fs.copySync(bundlePath, path.join(instance.uploadBundleContents, instance.bundlerArgs.bundleName()));
    if (instance.bundlerArgs.devtool()) {
      const bundleSourceMapPath = path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName() + '.map');
      if (!fs.existsSync(bundleSourceMapPath)) {
        throw new Error('Cannot find bundle source map file at ' + bundleSourceMapPath);
      }
      fs.copySync(bundleSourceMapPath, path.join(instance.uploadBundleContents, instance.bundlerArgs.bundleName() + '.map'));
    }
    const webpackContentPathDirectory = path.join(instance.clientDefinitionsPath, '.che');
    const webpackContentPath = path.join(webpackContentPathDirectory, 'project.json');
    const deprecatedWebpackContentPath = path.join(instance.clientDefinitionsPath, '.project.json');
    let webpackContentFound = false;
    if (fs.existsSync(webpackContentPath)) {
      webpackContentFound = true;
      fs.copySync(webpackContentPathDirectory, path.join(instance.uploadBundleContents, '.che'));
    }
    if (fs.existsSync(deprecatedWebpackContentPath)) {
      webpackContentFound = true;
      fs.copySync(deprecatedWebpackContentPath, path.join(instance.uploadBundleContents, '.project.json'));
    }
    if (!webpackContentFound) {
      throw new Error('Cannot find webpack content file at ' + webpackContentPath + ' or ' + deprecatedWebpackContentPath + '. It must be in one of these locations for the upload to succeed.');
    }
    const zipPath = path.join(instance.bundlerArgs.bundleZipTargetPath(), 'uploadBundle.zip');
    if (true) {//process.platform === 'win32'
      var zip = new AdmZip();
      zip.addLocalFolder(instance.uploadBundleContents);
      zip.writeZip(zipPath);
    } else {
      execSync('cd ' + instance.uploadBundleContents + ' && zip -r ../uploadBundle.zip .');
    }
    console.log(logger.getPrefix('MDK Bundler - archived files into ') + logger.getInfoMore(zipPath));
  }

  /**
   * 
   */
  updateClientDefinitions() {
    let sTargetPath = path.join(instance.bundlerArgs.nativeScriptProjectPath(), instance.bundlerArgs.bundleName());
    instance.copyBundleResults(sTargetPath, true);

    if (instance.bundlerArgs.bundleTargetPath()) {
      sTargetPath = path.join(instance.bundlerArgs.bundleTargetPath(), instance.bundlerArgs.bundleName());
      instance.copyBundleResults(sTargetPath, false);
    }
  }

  copyBundleResults(sTargetPath, bVerbose) {
    if (bVerbose) {
      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('replacing ') + logger.getInfoMore(sTargetPath));
    }
    fs.copySync(path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName()), sTargetPath);
    const sSourceMapSourcePath = path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName()) + '.map';
    if (fs.existsSync(sSourceMapSourcePath)) {
      const sSourceMapTargetPath = sTargetPath + '.map';
      if (bVerbose) {
        console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('replacing ') + logger.getInfoMore(sSourceMapTargetPath));
      }
      fs.copySync(sSourceMapSourcePath, sSourceMapTargetPath);
    }
  }

  // bundler private methods

  /**
   * Returns the value of the _Name property from the Application.app file
   * if exists.
   * 
   * @param {string} sSourcePath - path to folder containing Application.app
   */
  _appNameFromAppFile(sSourcePath) {
    const sApplicationAppPath = path.join(sSourcePath, 'Application.app');
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('resolving application @path ') + logger.getInfoMore(sSourcePath));
    if (isFile(sApplicationAppPath)) {
      let oApplicationAppJson;
      try {
        oApplicationAppJson = fs.readJsonSync(sApplicationAppPath);
      } catch (e) {
        console.log(e);
      }
      if (!oApplicationAppJson) {
        fail(`Could not parse ${sApplicationAppPath}`);
      }
      if (!oApplicationAppJson._Name) {
        fail(`_Name property not found in ${sApplicationAppPath}`);
      }
      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('found application ') + logger.getInfoMore(`'${oApplicationAppJson._Name}'`));
      return oApplicationAppJson._Name;
    }

    // file not found - abort
    fail(`File ${sApplicationAppPath} does not exist`);
  }

  /**
   * Assemble a single application and one ore more components. Recursively
   * process the component as a base application.
   * 
   * @param {string} sApplicationName - application name from _Name property
   * @param {string} sSourcePath - definition path
   * @param {string} sTargetPath - path to 
   * @param {array} cloneables - current list of cloneables
   */
  _assembleApplication(sApplicationName, sSourcePath, sTargetPath, cloneables) {
    cloneables = cloneables || [];
    let componentQueue = [];
    // first add a cloneable for this parent application
    let baseCloneable = instance._toCloneable(sApplicationName, sSourcePath, sTargetPath);
    cloneables.push(baseCloneable);
    return instance._readComponentIntegrationFiles(baseCloneable.sSourcePath)
      .then((aComponentIntegrations) => {
        return instance._componentToCloneable(baseCloneable, aComponentIntegrations);
      }).then((aComponentCloneables) => {
        return this._assembleComponents(aComponentCloneables, componentQueue, cloneables).then(() => {
          return cloneables;
        });
      });
  }

  /**
   * Entry point for applicaton assembly.  Start by assemblying the base
   * application, then assemble any components that may exist.
   * 
   * Determines base application and then call _assembleApplication to perform
   * recursive clone.
   */
  _assemble() {
    instance.sBaseApplicationName = instance._appNameFromAppFile(instance.clientDefinitionsPath);
    const sSourcePath = instance.clientDefinitionsPath;
    return instance._assembleApplication(instance.sBaseApplicationName, sSourcePath, instance.buildOutputPath)
      .then(instance._createBuildOutput)
      .then(instance._compileStyleFile);
  }

  /**
 * Maintains a queue of components by adding any new components in aComponents
 * Then processes the next component in the queue by calling
 * _assembleApplication to process that application's components.
 * 
 * @param {object[]} aComponents 
 * @param {object[]} componentQueue 
 * @param {object[]} cloneables 
 */
  _assembleComponents(aComponents, componentQueue, cloneables) {
    // first 
    aComponents.forEach((oComponent) => {
      componentQueue.push(oComponent);
    });

    if (componentQueue.length > 0) {
      let promises = componentQueue.map((oComponent) => {
        return instance._assembleApplication(oComponent.sApplicationName, oComponent.sSourcePath, oComponent.sTargetPath, cloneables);
      });

      return Promise.all(promises);
    }

    return Promise.resolve();
  }

  /**
   * Returns the content of application-index.js in the form of
   * 
   * Require statement
   * "let application_app = require('./Application.app');"
   * // additional require statements may follow
   * 
   * Import statement:
   * "module.exports = {"
   *     application_app : application_app,"
   *    // additional export statements may follow
   * "}"
   * 
   * @param {array} aBundleFiles 
   */
  _buildAppIndexContent(aBundleFiles) {
    const aExports = instance._buildExportObjects(aBundleFiles);
    const duplicates = instance._filterDuplicateNames(aExports);
    // fail if duplicate names are detected
    if (duplicates.length > 0) {
      throw new Error(`Create bundle failure - duplicate names detected: ${duplicates[0]}`);
    }

    let aModifiedExports = aExports;
    let aMappings = [];
    return instance._getIntegrationTargetSourceMappings(instance.clientDefinitionsPath, aMappings).then(() => {
      let sourceTargetMap = {};
      aMappings.forEach(oMapping => {
        let sSource = PathToExportName.pathToExportName(oMapping.Source, true);
        let sTarget = PathToExportName.pathToExportName(oMapping.Target, true);
        sourceTargetMap[sTarget] = {
          sSource: sSource,
          sTarget: sTarget,
          Source: oMapping.Source,
          Target: oMapping.Target
        };
      });

      if (Object.keys(sourceTargetMap).length > 0) {
        let aProcessedMappings = [];
        aModifiedExports = aExports.map(oTargetItem => {
          let oSource = sourceTargetMap[oTargetItem.name];
          if (oSource) {
            aProcessedMappings.push(oSource);
            let sSource = oSource.sSource;
            while (sourceTargetMap[sSource]) {
              oSource = sourceTargetMap[sSource];
              aProcessedMappings.push(oSource);

              sSource = oSource.sSource;
            }

            const oTargetExportPath = instance._getExportMapPath(aExports, sSource);
            if (oTargetExportPath) {
              oTargetItem.path = oTargetExportPath;
            }
          }
          return oTargetItem;
        });

        let restSourceTargetMaps = [];
        for (let sTarget in sourceTargetMap) {
          const oMapping = sourceTargetMap[sTarget];

          const oTargetExport = aProcessedMappings.find(oSource => {
            if (oSource.sSource === oMapping.sSource) {
              return true;
            }
          });

          if (!oTargetExport) {
            restSourceTargetMaps.push(oMapping);
          }
        }

        if (restSourceTargetMaps.length > 0) {
          restSourceTargetMaps.forEach(oMapping => {
            const oTargetExportPath = instance._getExportMapPath(aModifiedExports, oMapping.sSource);
            if (oTargetExportPath) {
              aModifiedExports.push({
                name: oMapping.sTarget,
                path: oTargetExportPath
              });
            }
          });
        }
      }

      aModifiedExports.sort(function (a, b) {
        if (a.name.toLowerCase() > b.name.toLowerCase())
          return 1;
        return -1;
      });

      let aRequireStatements = instance._createRequireStatements(aModifiedExports);
      let aExportStatements = instance._createExportStatements(aModifiedExports);
      // add the import statments
      let sIndexFileContent = aRequireStatements.join('\n');
      // append the expots
      sIndexFileContent += aExportStatements.join('\n');
      return Promise.resolve(sIndexFileContent);
    });
  }

  _getExportMapPath(aExports, sSource) {
    const oTargetExport = aExports.find(oSourceItem => {
      if (oSourceItem.name === sSource) {
        return true;
      }
    });

    return oTargetExport ? oTargetExport.path : null;
  }

  _getIntegrationTargetSourceMappings(sApplicationPath, aMappings) {
    return instance._readComponentIntegrationFiles(sApplicationPath).then((aComponents) => {
      let promises = [];

      aComponents.forEach((oComponent) => {
        oComponent.IntegrationPoints = oComponent.IntegrationPoints ? oComponent.IntegrationPoints : [];
        oComponent.IntegrationPoints.forEach(oIntegrationPoint => {
          aMappings.push(oIntegrationPoint);
        });

        let sComponentPath = instance.componentSourcePath(oComponent);
        promises.push(instance._getIntegrationTargetSourceMappings(sComponentPath, aMappings));
      });

      if (promises.length > 0) {
        return Promise.all(promises);
      }
    });
  }

  /**
   * Builds the bundle.js file by invoking webpack
   */
  _buildApplicationBundle() {
    return new Promise(function (resolve, reject) {
      // Add required externals if they're not specified
      let aExternals = instance.bundlerArgs.externals();

      const isForWeb = instance.bundlerArgs.isForWeb && instance.bundlerArgs.isForWeb();

      const useWmf = instance.bundlerArgs.useWmf() && !isForWeb;

      const wmfExternals = useWmf ? aExternals.filter(pathIsNodeModule) : [];
      let mdkExternals;
      if (useWmf) {
        mdkExternals = aExternals.filter((ext) => !pathIsNodeModule(ext));
      } else {
        const tsConfig = instance.bundlerArgs.tsTarget();
        if (tsConfig && tsConfig === "es5") {
          mdkExternals = [...aExternals, /^tns\-core\-modules\//, /^mdk\-core\//];
        } else {
          mdkExternals = [...aExternals, /^\@nativescript\/core/, /^mdk\-core\//];
        }
      }

      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('using external modules ') + logger.getInfoMore(aExternals));
      const sDevtool = instance.bundlerArgs.devtool();
      if (sDevtool) {
        console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('using devtool option ') + logger.getInfoMore(sDevtool));
      }

      const getChildDirs = (p, childFolderName) => {
        return fs.readdirSync(p).filter((f) => {
          return fs.statSync(path.join(p, f)).isDirectory() &&
            fs.existsSync(path.join(p, f, childFolderName)) &&
            fs.statSync(path.join(p, f, childFolderName)).isDirectory();
        }).map(f => path.resolve(p, f, childFolderName));
      };

      let tsFolders = getChildDirs(instance.buildOutputPath, 'Extensions');

      const safeNsImports = ['ui', 'trace', 'connectivity', 'color', 'platform', 'utils', 'fps-meter', 'http', 'profiling', 'image-source', 'core-types', 'application', 'file-system', 'application-settings', 'xml'];

      const wmfConfig = { eager: true, singleton: true, requiredVersion: "*", import: false };

      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('using wmf option ') + useWmf);

      let compiler = webpack({
        ...(useWmf ?
          {
            context: path.join(instance.buildOutputPath, ".."),
            // this dummy entry is needed so webpack module federation can work
            entry: { ['dummy.js']: path.join(instance.buildOutputPath, instance.bundlerArgs.projectIndexFile()) },
            output: {
              path: instance.specifiedOutputPath,
              filename: '[name]',
              libraryTarget: instance.bundlerArgs.libraryTarget(),
              library: instance.bundlerArgs.sBaseApplicationName,
              globalObject: 'this'
            },
          } :
          {
            context: path.join(instance.buildOutputPath, ".."),
            entry: path.join(instance.buildOutputPath, instance.bundlerArgs.projectIndexFile()),
            output: {
              path: instance.specifiedOutputPath,
              filename: instance.bundlerArgs.bundleName(),
              libraryTarget: instance.bundlerArgs.libraryTarget(),
              library: instance.bundlerArgs.sBaseApplicationName,
              globalObject: 'this'
            },
          }),
        mode: 'development',
        devtool: sDevtool ? sDevtool : false,
        resolveLoader: {
          modules: [path.join(getRootPath(), '../node_modules'), path.join(getRootPath(), '../../../')],
          alias: {
            'fragments-loader': path.join(getRootPath(), 'bundler/loaders/fragments-loader'),
            'i18n-strings-loader': path.join(getRootPath(), 'bundler/loaders/i18n-strings-loader')
          },
        },
        resolve: {
          extensions: ['.ts', '.js'],
          modules: ['__dummy_node_modules__']
        },
        ...(useWmf ?
          {
            optimization: {
              runtimeChunk: false
            },
            plugins: [
              new webpack.container.ModuleFederationPlugin({
                name: instance.bundlerArgs.bundleName(),
                exposes: { '.': path.join(instance.buildOutputPath, instance.bundlerArgs.projectIndexFile()) },
                library: {
                  type: 'commonjs'
                },
                shared: {
                  ...wmfExternals.reduce((acc, key) => ({ ...acc, [key]: wmfConfig, [key + '/']: wmfConfig }), {}),
                  '@nativescript/core': wmfConfig,
                  // allows '@nativescript/core/a few safe modules'
                  ...safeNsImports.reduce((acc, key) => ({
                    ...acc,
                    [`@nativescript/core/${key}`]: wmfConfig,
                    [`@nativescript/core/${key}/`]: wmfConfig
                  }), {}),
                  'mdk-core': wmfConfig,
                  'mdk-core/': wmfConfig,
                  'tns-core-modules': wmfConfig,
                  'tns-core-modules/': wmfConfig
                }
              }),
              new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 }),
              new MdkExternalsPlugin(mdkExternals)
            ],
          } : {
            ...(isForWeb ? { externals: mdkExternals } :
              { plugins: [new MdkExternalsPlugin(mdkExternals)] })
          }),
        module: {
          rules: [
            {
              test: /\.page$/,
              use: [
                {
                  loader: 'json-loader'
                },
                {
                  loader: 'fragments-loader',
                  options: {
                    fragmentsPath: instance.buildOutputPath
                  }
                }
              ]
            },
            {
              test: /\.app$|\.action$|\.object$|\.fragment$|\.service$|\.global$/,
              loader: 'json-loader'
            },
            {
              test: /\.(jpe?g|png|pdf)$/i,
              type: 'asset/inline'
            },
            {
              test: /\.js$/i,
              exclude: /(node_modules|bower_components)/,
              include: /(Rules|Extensions)/,
              loader: 'babel-loader', // 'babel-loader' is also a valid name to reference
              options: {
                babelrc: false,
                // Should be able to specify just 'es2015', but this fails when our module
                // is linked using npm link. This workaround was found at
                // https://github.com/babel/babel-loader/issues/149.
                presets: [
                  [
                    "@babel/preset-env",
                    {
                      "targets": {
                        "node": "current"
                      }
                    }
                  ]
                ]
              }
            },
            {
              test: /\.ts$/,
              include: tsFolders,
              enforce: "pre",
              use: [
                {
                  loader: "source-map-loader"
                },
                {
                  loader: 'ts-loader',
                  options: {
                    transpileOnly: true
                  }
                }
              ]
            },
            {
              test: /\.css$|\.nss$|\.less$/,
              loader: 'css-loader',
              options: {
                esModule: false,
              }
            },
            {
              test: /\.properties$/,
              loader: 'i18n-strings-loader'
            },
            {
              test: /\.mdkbundlerversion$|\.xml$/,
              type: 'asset/source'
            },
            {
              test: (path.sep === '\\') ? /\\[^\.]+$/ : /\/[^\.]+$/,
              type: 'asset/source'
            },
          ]
        }
      });
      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('creating bundle ') + logger.getInfoMore(path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName())));
      if (!instance.bundlerArgs.shouldWatch()) {
        compiler.run(function (error, status) {
          if (!status) {
            console.error(logger.getError(error));
            reject();
          }
          if (status.compilation.errors.length > 0) {
            console.error(logger.getPrefix('MDK Bundler - failed to create bundle '));
            console.error(logger.getInfo(status));
            console.error(logger.getError(status.compilation.errors));
            reject();
          } else {
            resolve(error);
          }
        });
      } else {
        const watching = compiler.watch({}, function (error, status) {
          if (!status) {
            console.error(logger.getError(error));
            reject();
          }
          if (status.compilation.errors.length > 0) {
            console.error(logger.getPrefix('MDK Bundler - failed to create bundle '));
            console.error(logger.getInfo(status));
            console.error(logger.getError(status.compilation.errors));
            reject();
          } else {
            resolve(error);
          }
        });

        // watching.close(() => {
        //   console.log("MDK Bundler - Watching Ended.");
        // });
      }

    });
  }

  _buildExportObjects(aBundleFiles) {
    // Remove instance.buildOutputPath from the paths.
    return aBundleFiles.map(sPath => {
      return sPath.replace(instance.buildOutputPath, '.');
    }).map((sLocalPath) => {
      return { path: sLocalPath, name: PathToExportName.pathToExportName(sLocalPath, false) };
    });
  }

  _cleanBuildOutput() {
    if (fs.existsSync(instance.buildOutputPath)) {
      console.log(logger.getPrefix('MDK Bundler - deleting ') + logger.getInfoMore(instance.buildOutputPath));
      fs.remove(instance.buildOutputPath, function (error, aDirs, aFiles) {
        if (error) {
          console.error(logger.getError(error));
        }
      });
    }
  }

  _cleanProjectIndex() {
    if (fs.existsSync(instance.bundlerArgs.projectIndexFile())) {
      console.log(logger.getPrefix('MDK Bundler - deleting ') + logger.getInfoMore(instance.bundlerArgs.projectIndexFile()));
      del([instance.bundlerArgs.projectIndexFile()], { force: true }, function (error) {
        if (error) {
          console.error(logger.getError(error));
        }
      });
    }
  }

  /**
   * 
   * @param {boolean} bVerbose 
   */
  _cleanTempFiles(bVerbose) {
    if (fs.existsSync(instance.exportedApplicationPath)) {
      if (bVerbose) {
        console.log(logger.getPrefix('MDK Bundler - removing temporary directory ') + logger.getInfoMore(instance.exportedApplicationPath));
      }
      del(instance.exportedApplicationPath, { force: true });
    }
    if (fs.existsSync(instance.buildOutputPath)) {
      if (bVerbose) {
        console.log(logger.getPrefix('MDK Bundler - removing build output directory ') + logger.getInfoMore(instance.buildOutputPath));
      }
      del(instance.buildOutputPath, { force: true });
    }
    const bundleName = instance.bundlerArgs.bundleName();
    const sBundlePath = path.join(instance.specifiedOutputPath, bundleName);
    if (fs.existsSync(sBundlePath)) {
      if (bVerbose) {
        console.log(logger.getPrefix(`MDK Bundler - removing ${bundleName} file `) + logger.getInfoMore(sBundlePath));
      }
      del(sBundlePath, { force: true });
    }
    const bundleNameMap = bundleName + '.map';
    const sBundleSourceMapPath = path.join(instance.specifiedOutputPath, bundleNameMap);
    if (fs.existsSync(sBundleSourceMapPath)) {
      if (bVerbose) {
        console.log(logger.getPrefix(`MDK Bundler - removing ${bundleNameMap} file `) + logger.getInfoMore(sBundleSourceMapPath));
      }
      del(sBundleSourceMapPath, { force: true });
    }
    if (fs.existsSync(instance.uploadBundleContents)) {
      if (bVerbose) {
        console.log(logger.getPrefix('MDK Bundler - removing upload bundle contents directory ') + logger.getInfoMore(instance.uploadBundleContents));
      }
      del(instance.uploadBundleContents, { force: true });
    }
  }

  /**
   * Given an array of component integration objects this method
   * builds a list of cloneables, and returns a list of the valid
   * cloneables.
   * 
   * @param {object[]} aComponentIntegrations 
   */
  _componentToCloneable(oBaseCloneable, aComponentIntegrations) {
    return aComponentIntegrations.filter((oComponent) => {
      // first filter out invalid component paths
      const sComponentSourcePath = instance.componentSourcePath(oComponent);
      if (!isDirectory(sComponentSourcePath)) {
        console.log(logger.getError('Unable to load component ') + logger.getInfoMore(sComponentSourcePath));
        // component source path is NOT valid DO NOT add it to the component list
        return false;
      }
      // component source path is valid add it to the component list
      return true;
    }).map((oComponent) => {
      // now map components to a cloneable object
      return instance._toComponentCloneable(oComponent, oBaseCloneable.sTargetPath);
    }).filter(oCloneable => {
      // finally filter out invalid cloneables
      if (!oCloneable.bValid) {
        console.log(logger.getError(`${oCloneable.sInvalidReason}, component project: `) + logger.getInfoMore(oCloneable.sSourcePath));
      }
      return oCloneable.bValid;
    });
  }

  /**
   * 
   * @param {*} aBundleFiles 
   */
  _createAppIndexFile(aBundleFiles) {
    return instance._buildAppIndexContent(aBundleFiles)
      .then(instance._saveAppIndexFile);
  }

  /**
   * 
   * @param {object} cloneables
   * 
   * see _toCloneable for the cloneable definition
   */
  _createBuildOutput(cloneables) {
    if (shelljs) {
      shelljs.mkdir('-p', instance.buildOutputPath);
    } else {
      exec(`mkdir -p "${instance.buildOutputPath}"`);
    }
    // tsconfig.json required for ts-loader to compile ts files on definition
    const tsConfig = instance.bundlerArgs.tsTarget();
    let sourceConfigFile;
    if (tsConfig && tsConfig === "es5") {
      sourceConfigFile = "tsconfig5.json";
      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('using ts5 target for ts loader'));
    } else {
      sourceConfigFile = "tsconfig6.json";
      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('using ts2015 target for ts loader'));
    }

    const tsConfigPath = path.join(getRootPath(), `bundler/${sourceConfigFile}`);

    if (fs.existsSync(tsConfigPath)) {
      console.log(`copy ${tsConfigPath} to ${instance.buildOutputPath}/tsconfig.json`);
      if (shelljs) {
        shelljs.cp(tsConfigPath, `${instance.buildOutputPath}/tsconfig.json`);
      } else {
        exec(`cp "${tsConfigPath}" "${instance.buildOutputPath}/tsconfig.json"`);
      }
    } else {
      console.log(`Failed to copy ${tsConfigPath}`);
    }
    cloneables.forEach((oCloneable) => {
      const sApplicationName = oCloneable.sApplicationName;
      const sSourcePath = oCloneable.sSourcePath;
      const sTargetPath = `${oCloneable.sTargetPath}/${sApplicationName}`;
      console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('copying ') + logger.getInfoMore(sSourcePath) + logger.getInfo(' to ') + logger.getInfoMore(path.join(instance.buildOutputPath, sApplicationName)));

      if (shelljs) {
        shelljs.cp('-r', sSourcePath, sTargetPath);
      } else {
        exec(`cp -r "${sSourcePath}" "${sTargetPath}"`);
      }
    });
  }

  /**
   * convert .less style file to .css for Nativescript, 
   * and then generate .nss for iOS and .json for Android
   */
  _compileStyleFile() {
    return new Promise((resolve, reject) => {
      const sApplicationAppPath = `${instance.buildOutputPath}/${instance.sBaseApplicationName}/Application.app`;
      if (isFile(sApplicationAppPath)) {
        try {
          let oApplicationAppJson = fs.readJsonSync(sApplicationAppPath);
          if (!oApplicationAppJson) {
            return resolve();
          }
          oApplicationAppJson.StyleSheets = {};
          const sStylesDir = `${instance.buildOutputPath}/${instance.sBaseApplicationName}/Styles/`;
          if (isDirectory(sStylesDir)) {
            console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('compiling ') + logger.getInfoMore(sStylesDir));
            if (less == null) {
              return new Promise((resolve, reject) => {
                return reject('Cannot find module \'less\'');
              });
            }
            if (CSSJSON == null) {
              return new Promise((resolve, reject) => {
                return reject('Cannot find module \'CSSJSON\'');
              });
            }
            const aStyleSheets = fs.readdirSync(sStylesDir).filter((sFile) => {
              if (sFile.endsWith('.less')) {
                return sFile;
              }
            });
            let promises = [];
            let backwardAdaption = false;
            if (aStyleSheets.length === 1 && aStyleSheets[0] && !(instance.bundlerArgs.isForWeb && instance.bundlerArgs.isForWeb())) {
              let styleName = aStyleSheets[0].slice(0, -5);
              if (styleName && styleName.indexOf('.dark') <= 0 && styleName.indexOf('.light') <= 0) {
                backwardAdaption = true;
              }
            }
            aStyleSheets.forEach((sStyleSheet) => {
              if (sStyleSheet) {
                const sStyles = `/${instance.sBaseApplicationName}/Styles/${sStyleSheet}`;
                promises.push(instance._writeStyleFileContent(sStyleSheet.slice(0, -5), sStyles, backwardAdaption));
              }
            });
            return Promise.all(promises).then((styleDefs) => {
              if (styleDefs && styleDefs.length > 0) {
                if (backwardAdaption) {
                  oApplicationAppJson.Styles = styleDefs[0].orgCss;
                  oApplicationAppJson.SDKStyles = {
                    ios: styleDefs[0].entries.ios,
                    android: styleDefs[0].entries.android
                  };
                }
                styleDefs.forEach((def) => {
                  oApplicationAppJson.StyleSheets[def.name] = def.entries;
                });
                fs.writeFileSync(sApplicationAppPath, JSON.stringify(oApplicationAppJson, null, '\t'), 'utf8');
              }
              resolve();
            });
          } else {
            resolve();
          }
        } catch (err) {
          console.error(logger.getError(err));
          reject(err);
        }
      } else {
        reject();
      }
    });
  }

  _writeStyleFileContent(sStyleName, sStyles, backwardAdaption) {
    return new Promise((resolve, reject) => {
      // generate files
      fs.readFile(`${instance.buildOutputPath}${sStyles}`, function (error, data) {
        if (error) {
          return reject(error);
        }
        const sContent = data.toString();
        const jsonLess = JSON.parse(
          JSON.stringify(CSSJSON.toJSON(sContent)).replace(/"color"/gi, '"font-color"')
        );
        // less to css
        less.render(sContent, {}, function (err, oCSS) {
          if (err) {
            return reject(err);
          }
          let sWebCss = oCSS.css;
          if (instance.bundlerArgs.isForWeb && instance.bundlerArgs.isForWeb()) {
            console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('converting type selectors for ') + logger.getInfoMore('WebClient'));
            sWebCss = sWebCss
              // nativescript controls
              .replace(/\bPage\b/gi, 'div.MDKPage')
              .replace(/\bStackLayout\b/gi, 'div#stackLayout')
              .replace(/\bActionBar\b/gi, 'ui5-mdk-bar.actionbar')
              .replace(/\bActionBarTitle\b/gi, 'ui5-mdk-bar.actionbar>ui5-title')
              .replace(/\bToolBar\b/gi, 'ui5-mdk-overflow-toolbar.toolbar')
              // formcell controls
              .replace(/\bAttachmentFormCellBackground\b/gi, 'div.afcBackground')
              .replace(/\bButtonFormCellBackground\b/gi, 'div.bfcBackground')
              .replace(/\bButtonFormCellValue\b/gi, 'ui5-button.bfcValue')
              .replace(/\bDatePickerFormCellBackground\b/gi, 'div.dafcBackground')
              .replace(/\bDatePickerFormCellCaption\b/gi, 'ui5-label.dafcCaption')
              .replace(/\bDatePickerFormCellValue\b/gi, 'ui5-timepicker.dafcValue')
              .replace(/\bDurationPickerFormCellBackground\b/gi, 'div.dufcBackground')
              .replace(/\bDurationPickerFormCellCaption\b/gi, 'ui5-label.dufcCaption')
              .replace(/\bDurationPickerFormCellValue\b/gi, 'ui5-duration-picker.dufcValue')
              .replace(/\bFilterFormCellBackground\b/gi, 'div.ffcBackground')
              .replace(/\bFilterFormCellCaption\b/gi, 'ui5-label.ffcCaption')
              .replace(/\bListPickerFormCellBackground\b/gi, 'div.lpfcBackground')
              .replace(/\bListPickerFormCellCaption\b/gi, 'ui5-label.lpfcCaption')
              .replace(/\bListPickerFormCellValue\b/gi, 'ui5-input.lpfcValue')
              .replace(/\bNoteFormCellBackground\b/gi, 'div.nfcBackground')
              .replace(/\bNoteFormCellValue\b/gi, 'ui5-textarea.nfcValue')
              .replace(/\bSegmentedControlFormCellBackground\b/gi, 'div.scfcBackground')
              .replace(/\bSegmentedControlFormCellCaption\b/gi, 'ui5-label.scfcCaption')
              .replace(/\bSimplePropertyFormCellBackground\b/gi, 'div.spfcBackground')
              .replace(/\bSimplePropertyFormCellCaption\b/gi, 'ui5-label.spfcCaption')
              .replace(/\bSimplePropertyFormCellValue\b/gi, 'ui5-input.spfcValue')
              .replace(/\bSwitchFormCellBackground\b/gi, 'div.sfcBackground')
              .replace(/\bSwitchFormCellSwitch\b/gi, 'ui5-label.sfcCaption')
              .replace(/\bSwitchFormCellCaption\b/gi, 'ui5-switch.sfcSwitch')
              .replace(/\bTitleFormCellBackground\b/gi, 'div.tfcBackground')
              .replace(/\bTitleFormCellValue\b/gi, 'ui5-input.tfcValue')
              .replace(/\bImageCellImage\b/gi, 'ui5-avatar.icImage')
              // for section controls
              .replace(/\bObjectHeaderDetailImage\b/gi, 'ui5-avatar.ohDetailImage')
              .replace(/\bObjectHeaderHeadlineText\b/gi, 'span.ohHeadlineText')
              .replace(/\bObjectHeaderSubhead\b/gi, 'span.ohSubhead')
              .replace(/\bObjectHeaderStatusImage\b/gi, '.ohStatusImage')
              .replace(/\bObjectHeaderSubstatusImage\b/gi, '.ohSubstatusImage')
              .replace(/\bObjectHeaderStatusText\b/gi, '.ohStatusText')
              .replace(/\bObjectHeaderSubstatusText\b/gi, '.ohSubstatusText')
              .replace(/\bObjectHeaderDescription\b/gi, 'span.ohDescription')
              .replace(/\bObjectHeaderBodyText\b/gi, 'span.ohBodyText')
              .replace(/\bObjectHeaderFootnote\b/gi, 'span.ohFootnote')
              .replace(/\bSimplePropertyCellKeyName\b/gi, 'span.scKeyName')
              .replace(/\bSimplePropertyCellValue\b/gi, 'span.scValue')
              .replace(/\bObjectCellBackgroundColor\b/gi, 'ui5-mdk-object-cell.ocBackgroundColor')
              .replace(/\bObjectCellDetailImage\b/gi, 'ui5-avatar.ocDetailImage')
              .replace(/\bObjectCellTitle\b/gi, 'span.ocTitle')
              .replace(/\bObjectCellSubhead\b/gi, 'span.ocSubhead')
              .replace(/\bObjectCellDescription\b/gi, 'span.ocDescription')
              .replace(/\bObjectCellFootnote\b/gi, 'span.ocFootnote')
              .replace(/\bObjectCellStatusImage\b/gi, '.ocStatusImage')
              .replace(/\bObjectCellSubstatusImage\b/gi, '.ocSubstatusImage')
              .replace(/\bObjectCellStatusText\b/gi, '.ocStatusText')
              .replace(/\bObjectCellSubstatusText\b/gi, '.ocSubstatusText')
              .replace(/\bContactCellDetailImage\b/gi, 'ui5-avatar.ccDetailImage')
              .replace(/\bContactCellHeadline\b/gi, 'span.ccHeadline')
              .replace(/\bContactCellSubheadline\b/gi, 'span.ccSubheadline')
              .replace(/\bContactCellDescription\b/gi, 'span.ccDescription')
              ;
          } else {
            // MDK-7883: to include .ns-light / .ns-dark identifier on css type selector
            // this is because MDK internal css is using the identifier, when all selectors are available
            // the one with identifier would take precendence.
            let modeToBeAppended = '.ns-light'; // default as ns-light to ensure it would override the MDK internal css
            if (sStyleName.indexOf('.dark') > 0) {
              modeToBeAppended = '.ns-dark';
            } else if (sStyleName.indexOf('.light') > 0) {
              modeToBeAppended = '.ns-light';
            }

            if (modeToBeAppended !== '') {
              const jsonCssMain = CSSJSON.toJSON(sWebCss);
              const newJsonCssMain = Object.keys(jsonCssMain.children).reduce((acc, key) => {
                let newKey = key;
                newKey = modeToBeAppended + ' ' + key;
                const renamedObject = {
                  [newKey]: jsonCssMain.children[key]
                };
                return {
                  ...acc,
                  ...renamedObject
                };
              }, {});

              const newJsonCss = {
                children: newJsonCssMain,
                attributes: jsonCssMain.attributes
              }
              sWebCss = CSSJSON.toCSS(newJsonCss);
            }
          }
          const sOrgCSSFile = sStyles.replace('.less', '.css');
          if (backwardAdaption) {
            fs.writeFileSync(`${instance.buildOutputPath}${sOrgCSSFile}`, oCSS.css, 'utf8');
            sStyles = sStyles.replace('.less', '.light.less');
          }
          const sCSSFile = sStyles.replace('.less', '.css');
          fs.writeFileSync(`${instance.buildOutputPath}${sCSSFile}`, sWebCss, 'utf8');

          // css to json, only keep class selectors
          // remove '.' in front of selector
          const includeTypeSelectors = ['ActionBar'];
          const jsonCss = JSON.parse(
            JSON.stringify(CSSJSON.toJSON(oCSS.css)).replace(/"color"/gi, '"font-color"')
          );
          const fontFamilyProp = 'font-family';
          const filtered = Object.keys(jsonCss.children)
            .filter(key => !key.includes(':active'))
            .reduce((obj, key) => {
              if (key.startsWith('.')) {
                obj[key.substr(1)] = jsonCss.children[key];
                delete obj[key.substr(1)].attributes[fontFamilyProp];
              } else if (includeTypeSelectors.includes(key)) {
                obj[key] = jsonCss.children[key];
                delete obj[key].attributes[fontFamilyProp];
              }
              return obj;
            }, {});
          // json to nss
          const jsonNss = {
            children: filtered,
            attributes: jsonLess.attributes
          }
          const nss = CSSJSON.toCSS(jsonNss);
          const sNSSFile = sStyles.replace('.less', '.nss');
          fs.writeFileSync(`${instance.buildOutputPath}${sNSSFile}`, nss, 'utf8');

          // json file for android
          const jsonAndroid = Object.keys(filtered)
            .reduce((obj, key) => {
              obj[key] = filtered[key].attributes;
              return obj;
            }, {});
          const sJSONFile = sStyles.replace('.less', '.json');
          fs.writeFileSync(`${instance.buildOutputPath}${sJSONFile}`, JSON.stringify(jsonAndroid, null, '\t'), 'utf8');

          let def = {
            name: sStyleName,
            entries: {
              css: sCSSFile,
              ios: sNSSFile,
              android: sJSONFile
            },
            orgCss: backwardAdaption ? sOrgCSSFile : null
          };
          resolve(def);
        });
      });
    });
  }

  /**
   * 
   */
  _createBundlerVersionFile() {
    // This is a simple way of writing the bundler version into the bundle
    // so that it can be accessed just like a definition.
    exec(`echo 1.1 > "${instance.buildOutputPath}"/version.mdkbundlerversion`);
  }

  /**
   * Produces a array of export statements from aExportNames of the form:
   * <export name> : <export name>
   * 
   * Example:
   * application_app : application_app"
   * 
   * Example output:
   * "module.exports = {"
   *     application_app : application_app,"
   *    // additional export statements may follow
   * "}"
   * @param {string[]} aExportNames 
   */
  _createExportStatements(aExports) {
    let aExportStatements = ['', 'module.exports = {']
      .concat(aExports.map(oExport => {
        return `\t${oExport.name} : ${oExport.name},`;
      }));
    // all export statements excluding the last one must end with ','
    aExportStatements[aExportStatements.length - 1] = aExportStatements[aExportStatements.length - 1].replace(',', '');
    aExportStatements.push('}');
    return aExportStatements;
  }

  /**
   * Produces a array of require statements from aExportNames of the form:
   * 
   * Requires that aExportNames[n] maps to aFiles[n]
   * 
   * "let <export name> = require('<path to export> ');"
   * 
   * @param {string[]} aExportNames - array of exported names
   * @param {string[]} aFiles - array of paths
   */
  _createRequireStatements(aExports) {
    const aRequireStatements = aExports.map(oExport => {

      // if (oExport.path.endsWith('.png')) {
      //   // npm install image-webpack-loader --save
      //   //sRequire = "require('url-loader?mimetype=image/png!" + sFilePath + "');";
      //   // npm install  img-loader --save
      //   //sRequire = "require('file!img!" + sFilePath + "');";
      // }
      let requirePath = oExport.path;
      if (path.sep === '\\') { // in windows
        requirePath = requirePath.replace(/\\/g, '/');
      }
      return `let ${oExport.name} = require('${requirePath}')`;
    });

    // push a empty string to add final newline during join
    aRequireStatements.push('');
    return aRequireStatements;
  }

  /**
   * Produces a list of filtered bundled files or an error if reading.
   * 
   * See _isValidBundleFile for the filtering details
   */
  _generateBundleFiles() {
    return new Promise(function (resolve, reject) {
      dir.files(instance.buildOutputPath, function (error, aFiles) {

        if (error) {
          reject(error);
        }

        let aBundleFiles = aFiles.filter((sFilePath) => {
          return instance._isValidBundleFile(sFilePath);
        });

        resolve(aBundleFiles);
      });
    });
  }

  /**
   * Determines of the list of 
   * @param {*} aNames 
   */
  _filterDuplicateNames(aExports) {
    const counts = {};
    aExports.forEach(oExport => {
      counts[oExport.name] = (counts[oExport.name] || 0) + 1;
    });
    return Object.keys(counts).filter(count => counts[count] > 1);
  }

  /**
 * Method to determine if the file should be added to the list
 * of webpack files.
 * 
 * @param {string} sFilePath
 * @returns {boolean} false if the file is not a valid MDK webpack file
 * otherwise true
 */
  _isValidBundleFile(sFilePath) {
    let aFilterFiles = instance.bundlerArgs.filters();
    // Swap backslashes in the path with a forward slash
    // sFilePath = sFilePath.replace(/(\\|\/)/g, path.sep);
    let bFilter = false;
    aFilterFiles.forEach((sFile) => {
      sFile = sFile.replace(/(\\|\/)/g, path.sep);
      if (sFilePath.includes(sFile)) {
        bFilter = true;
      }
    });
    if (bFilter) {
      return false;
    }
    // Skip unneeded files
    if (sFilePath.includes('DS_Store')
      || sFilePath.includes('README.md')
      // This json file is created by the editor.
      // We don't need to include it in the bundle and it causes an error
      // because webpack chokes on file names with dashes.
      || sFilePath.includes('neo-app.json')
      // Ignore .spec.js files so that metadata can contain unit tests
      || sFilePath.includes('.spec.js')
      // Ignore Component Integration Files
      || sFilePath.includes('.cim')
      // Ignore Object Files
      || sFilePath.includes('.object')
      // Ignore extension support file generated by editor
      || sFilePath.includes('.extension')
      // Ignore .rule files because they're created and used by the editor.
      // These are JSON files that are used to generate .rule.js files, which are bundled.
      || sFilePath.substring(sFilePath.length - 5) === '.rule'
      || sFilePath.substring(sFilePath.length - 4) === '.SMF'
      || sFilePath.endsWith('.mergemap')) {
      return false;
    }

    // Only bundle the root Application.app file, all other component base Application.app files 
    if (sFilePath.includes('Application.app')) {
      let segments = sFilePath.split(path.sep);
      if (segments[segments.length - 2] !== instance.buildOutput) {
        return false;
      }
    }

    // Ignore all hidden files and directories.
    if (sFilePath.split(path.sep).some(sPathComponent => {
      return sPathComponent.length > 1 && sPathComponent[0] === '.';
    })) {
      return false;
    }

    return true;
  }

  /**
    * Link a single application and one ore more components. Recursively
    * process the component as a base application.
    * @param {string} sApplicationPath
    * @param {string} sApplicationName
    */
  _linkApplication(sApplicationPath, sApplicationName) {
    let componentQueue = [];
    // read the components for this application
    return instance._readComponentIntegrationFiles(sApplicationPath).then((aComponents) => {
      aComponents.forEach((oComponent) => {
        oComponent.IntegrationPoints = oComponent.IntegrationPoints ? oComponent.IntegrationPoints : [];
        oComponent.IntegrationPoints.forEach(integrationPoint => {
          if (integrationPoint.Target === `/${instance.sBaseApplicationName}/Application.app`) {
            // skip it
            return;
          }

          const aSourceSegements = integrationPoint.Source.split('/');
          const aTargetSegements = integrationPoint.Target.split('/');

          if (aSourceSegements[1] === oComponent.ApplicationName && aTargetSegements[1] === sApplicationName) {
            aSourceSegements.shift();
            aSourceSegements.shift();
            aTargetSegements.shift();
            aTargetSegements.shift();

            instance._linkComponent(oComponent.__path__, path.join(instance.componentSourcePath(oComponent), aSourceSegements.join(path.sep)), path.join(sApplicationPath, aTargetSegements.join(path.sep)), integrationPoint);
          }

          if (aSourceSegements[1] === sApplicationName && aTargetSegements[1] === oComponent.ApplicationName) {
            aSourceSegements.shift();
            aSourceSegements.shift();
            aTargetSegements.shift();
            aTargetSegements.shift();

            instance._linkComponent(oComponent.__path__, path.join(sApplicationPath, aSourceSegements.join(path.sep)), path.join(instance.componentSourcePath(oComponent), aTargetSegements.join(path.sep)), integrationPoint);
          }
        });
      });
      return aComponents;
    }).then((aComponents) => {
      return instance._linkComponents(aComponents, componentQueue);
    });
  }

  /**
   * Entry point for applicaton linking.  Start by linking the base
   * application to its componenent, then recursively link any components
   * that may exist in the component application.
   */
  _link() {
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('linking application ') + logger.getInfoMore(instance.clientDefinitionsPath));
    return instance._linkApplication(instance.clientDefinitionsPath, instance.sBaseApplicationName);
  }

  /**
   *
   * @param {string} sCIMPath
   * @param {string} sSourcePath
   * @param {string} sTargetPath
   * @param {object} integrationPoint
   */
  _linkComponent(sCIMPath, sSourcePath, sTargetPath, integrationPoint) {
    if (!fs.existsSync(sSourcePath)) {
      throw new Error(`Cannot find source path: "${sSourcePath}" in "${sCIMPath}"`);
    } else if (!fs.existsSync(sTargetPath)) {
      throw new Error(`Cannot find target path: "${sTargetPath}" in "${sCIMPath}"`);
    }

    const sPath = path.join(instance.specifiedOutputPath, instance.bundlerArgs.bundleName());
    if (fs.existsSync(sPath)) {
      let sContents = fs.readFileSync(sPath, 'utf8');
      //let pattern = '\/ \"\./build\.definitions' + integrationPoint.Target + '\"';
      let pattern = 'var \.* = __webpack_require__\.*\/ \"\./build\.definitions' + integrationPoint.Target + '\"';
      let regex = new RegExp(pattern, 'gmi');
      if (regex.test(sContents)) {
        let newContents = sContents.replace(regex, function (match) {
          return match.replace('\"\./build\.definitions' + integrationPoint.Target + '\"',
            '\"\./build\.definitions' + integrationPoint.Source + '\"');
        });

        fs.writeFileSync(sPath, newContents, 'utf8');
        console.log("\n" + '[hh:mm:ss]'.timestamp + logger.getPrompt(" -- replace Import --"));
      }
    } else {
      console.log(logger.getPrefix('MDK Bundler - File not found: ') + logger.getInfoMore(sPath));
    }
  }

  /**
   * 
   * @param {object[]} aComponents 
   * @param {object[]} componentQueue 
   */
  _linkComponents(aComponents, componentQueue) {
    // first 
    aComponents.forEach((oComponent) => {
      componentQueue.push(oComponent);
    });

    if (componentQueue.length > 0) {
      const oComponent = componentQueue.shift();
      return instance._linkApplication(instance.componentSourcePath(oComponent), oComponent.ApplicationName);
    }

    return Promise.resolve();
  }

  /**
   * Reads and returns the list of components for an application
   * 
   * @param {string} sSourcePath - path to folder containing Application.app
   */
  _readComponentIntegrationFiles(sSourcePath) {
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('reading components @path ') + logger.getInfoMore(sSourcePath));

    return new Promise((resolve, reject) => {
      let aComponents = [];
      dir.readFiles(sSourcePath, { match: /^(.*\.cim$)*$/, recursive: false }, (error, content, file, next) => {
        if (!error) {
          let jsonObj = JSON.parse(content);
          jsonObj.__path__ = file;
          aComponents.push(jsonObj);
          next();
        } else {
          resolve([]);
        }
      },
        (error, files) => {
          if (!error) {
            files.forEach((file) => {
              console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('processed component @path ') + logger.getInfoMore(file));
            });
            resolve(aComponents);
          }

          resolve([]);
        });
    }).catch(error => {
      return [];
    });
  }

  _getCIMRootApplication() {
    // read the components for this application
    return instance._readComponentIntegrationFiles(instance.clientDefinitionsPath).then((aComponents) => {
      for (let oComponent of aComponents) {
        oComponent.IntegrationPoints = oComponent.IntegrationPoints ? oComponent.IntegrationPoints : [];
        for (let integrationPoint of oComponent.IntegrationPoints) {
          if (integrationPoint.Target === `/${instance.sBaseApplicationName}/Application.app`) {
            return integrationPoint.Source;
          }
        }
      }

      return null;
    });
  }

  _rootBaseApplication(sBaseApplicationApp) {
    let srcPath = `${instance.buildOutputPath}${sBaseApplicationApp}`;
    if (!isFile(srcPath)) {
      fail(`Cannot find base project Application.app file at ${instance.buildOutputPath}${sBaseApplicationApp}`);
    }

    let destPath = `${instance.buildOutputPath}/Application.app`;
    if (srcPath !== destPath) {
      if (shelljs) {
        shelljs.mv('-f', srcPath, destPath);
      } else {
        exec(`mv -f "${srcPath}" "${destPath}"`);
      }
    }
  }

  _saveAppIndexFile(sIndexFileContent) {
    return new Promise(function (resolve, reject) {
      createFile(path.join(instance.buildOutputPath, instance.bundlerArgs.projectIndexFile()), sIndexFileContent, (error) => {
        if (error) {
          reject(error);
        }
        resolve(sIndexFileContent);
      });
    });
  }

  _toCloneable(sApplicationName, sSourcePath, sTargetPath, bValid = true, sInvalidReason = '') {
    return { sApplicationName, sSourcePath, sTargetPath, bValid, sInvalidReason };
  }

  _toComponentCloneable(oComponent, sTargetPath) {
    const sComponentSourcePath = instance.componentSourcePath(oComponent);
    const sComponentApplicationName = instance._appNameFromAppFile(sComponentSourcePath)
    if (oComponent.ApplicationName != sComponentApplicationName) {
      const sComponentMismatchText = `Component Integration - application name mismatch cim says: ${oComponent.ApplicationName}`;
      const sApplicationMismatchText = `Application.app says: ${sComponentApplicationName}`;
      const sInvalidReason = `${sComponentMismatchText}, ${sApplicationMismatchText}`;
      return instance._toCloneable(sComponentApplicationName, sComponentSourcePath, sTargetPath, false, sInvalidReason);
    }
    return instance._toCloneable(sComponentApplicationName, sComponentSourcePath, sTargetPath);
  }

  _unzipEditorExport() {
    console.log(logger.getPrefix('MDK Bundler - unzipping archive at ') + logger.getInfoMore(instance.bundlerArgs.editorExport()) + logger.getInfo(' to ') + logger.getInfoMore(this.clientDefinitionsPath));
    const zip = new AdmZip(instance.bundlerArgs.editorExport());
    zip.extractAllTo(instance.exportedApplicationPath, /*overwrite*/ true);
  }

  _updateBundle() {
    console.log("\n" + '[hh:mm:ss]'.timestamp + logger.getPrompt(" -- updating definitions --"));
    instance.updateClientDefinitions();
    if (instance.bundlerArgs.shouldCreateBundle()) {
      console.log("\n" + '[hh:mm:ss]'.timestamp + logger.getPrompt(" -- creating upload bundle --"));
      return instance.createUploadBundle();
    }
  }

  _replaceImport() {
    console.log(logger.getPrefix('MDK Bundler - ') + logger.getInfo('replacing bundle ') + logger.getInfoMore(instance.clientDefinitionsPath));
    return instance._linkApplication(instance.clientDefinitionsPath, instance.sBaseApplicationName);
  }

};

exports.Bundler = Bundler;