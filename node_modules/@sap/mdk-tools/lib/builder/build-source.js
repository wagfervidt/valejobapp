const logger = require('../logger');
const fs = require('fs-extra');
const path = require('path');
const AdmZip = require('adm-zip');
const timestamp = require('console-timestamp');


const { getRootPath, BUILD_TEMP_FOLDER, MDK_IDENTITY_FILE, APPLICATION_FILE, getAppName} = require('../utils');

let instance;
let childProcessExecOption;
class Builder {

    constructor(args) {
        this.buildArgs = args;
        instance = this;
        childProcessExecOption = {
            stdio: 'inherit'
        }
        instance.sBundleTempFolder = path.join(instance.buildArgs.project(), BUILD_TEMP_FOLDER);
    }
    /**
     * This is the main entry point into the build source functionality
     */
     build() {
        return new Promise(function (resolve, reject) {
            try {
                if (fs.existsSync(instance.sBundleTempFolder)) {
                    fs.removeSync(instance.sBundleTempFolder);
                }

                //synch _SchemaVersion from application to project.json
                let sProjectPath = instance.buildArgs.project();
                let sAppName = getAppName(sProjectPath);
            

                let destCheProjectPath = path.join(sProjectPath, '.che', MDK_IDENTITY_FILE);
                let srcCheProjectPath = path.join(getRootPath(),'builder', 'template', MDK_IDENTITY_FILE);
                const applicationFile = path.join(sProjectPath, APPLICATION_FILE);
                let definistionsVersion = "5.2";
                if (fs.existsSync(applicationFile)) {
                    const applicationJson = fs.readJSONSync(applicationFile);
                    definistionsVersion = applicationJson["_SchemaVersion"] ? applicationJson["_SchemaVersion"] : "5.2";
                }
                let configContent = fs.readFileSync(srcCheProjectPath, {
                    encoding: "utf8"
                });
                configContent = configContent.replace("{definitionsVersion}",definistionsVersion);
                let oConfig = JSON.parse(configContent);
                oConfig['mdkProjectType'] = "metadata";
                configContent = JSON.stringify(oConfig,null, "\t");
                fs.ensureDirSync(path.dirname(destCheProjectPath));
                fs.writeFileSync(destCheProjectPath, configContent);
                instance.zipFolder(sProjectPath,`${instance.sBundleTempFolder+path.sep+sAppName}.zip`);
                resolve();
            } catch (error) {
                reject(error);
            }
           
        });
    }

    zipFolder(folderPath, outputPath) {
        const zip = new AdmZip();
      
        function addFilesToZip(directory, zip, baseDir) {
          const files = fs.readdirSync(directory);
      
          for (const file of files) {
            const filePath = path.join(directory, file);
            const relativePath = path.relative(baseDir, filePath);
      
            if (fs.statSync(filePath).isDirectory()) {
              if (file !== '.base' && file!==".build") {
                addFilesToZip(filePath, zip, baseDir);
              }
            } else {
              //if (relativePath !== 'test1.txt') {
                zip.addLocalFile(filePath, path.dirname(relativePath));
              //}
            }
          }
        }
      
        addFilesToZip(folderPath, zip, folderPath);
        zip.writeZip(outputPath);
      }
      
};

exports.Builder = Builder;
