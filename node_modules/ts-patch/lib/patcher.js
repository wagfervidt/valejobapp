"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchTSModule = void 0;
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var system_1 = require("./system");
var file_utils_1 = require("./file-utils");
var actions_1 = require("./actions");
/* ****************************************************************************************************************** */
// region: Constants
/* ****************************************************************************************************************** */
var dtsPatchSrc = '\n' +
    fs_1.default.readFileSync(path_1.default.resolve(system_1.appRoot, system_1.tspPackageJSON.directories.resources, 'module-patch.d.ts'), 'utf-8');
var jsPatchSrc = fs_1.default.readFileSync(path_1.default.resolve(system_1.appRoot, system_1.tspPackageJSON.directories.resources, 'module-patch.js'), 'utf-8');
// endregion
/* ********************************************************************************************************************
 * Helpers
 * ********************************************************************************************************************/
/**
 * Generate insertion code for module-patch
 */
var generatePatch = function (isTSC) {
    return jsPatchSrc
        .replace(/(^\s*Object\.assign\(ts,\s*{[\s\S]*tspVersion,[\s\S]+?}\);?$)/m, "var tspVersion = '" + system_1.tspPackageJSON.version + "';\n" +
        ("var isTSC = " + isTSC + ";\n") +
        "$1");
};
/**
 * Validate TSModule and TSPackage before patching
 */
function validate(tsModule, tsPackage) {
    if (tsModule) {
        var file = tsModule.file, filename = tsModule.filename, dir = tsModule.dir, patchVersion = tsModule.patchVersion, canPatch = tsModule.canPatch, outOfDate = tsModule.outOfDate;
        if (!fs_1.default.existsSync(file))
            throw new system_1.FileNotFound("Could not find module " + filename + " in " + (dir + path_1.default.sep));
        if (patchVersion && !outOfDate)
            throw new system_1.PatchError("Module " + filename + " is already up-to-date with local version - v" + patchVersion);
        if (!canPatch)
            throw new system_1.PatchError("Module " + filename + " cannot be patched! No instance of TypeScript found.");
    }
    if (tsPackage) {
        var _a = tsPackage.version.split('.'), major = _a[0], minor = _a[1];
        if (+major < 3 && +minor < 7)
            throw new system_1.WrongTSVersion("ts-patch requires TypeScript v2.7 or higher.");
    }
    return true;
}
var patchModule = function (tsModule, source) {
    var src = source || tsModule.moduleSrc;
    var funcPos = src.search(/function emitFilesAndReportErrors\(/);
    if (funcPos < 0)
        throw new Error("Bad TS Code. Could not find function emitFilesAndReportErrors in " + tsModule.filename);
    var startCode = src.substr(0, funcPos);
    var restCode = src.substr(funcPos);
    /* Modern TS */
    var pos = restCode.search(/^\s*?var emitResult =/m);
    if (pos >= 0) {
        return startCode +
            restCode.substr(0, pos) +
            "\nts.diagnosticMap.set(program, allDiagnostics);\n" +
            restCode.substr(pos);
    }
    /* TS 2.7 */
    pos = restCode.search(/^\s*?var [_\w]+? = program.emit\(\)/m);
    if (pos < 0)
        throw new Error("Could not recognize diagnostics signature in emitFilesAndReportErrors(). Please open an issue with your TS version #.");
    return startCode +
        restCode.substr(0, pos) +
        "\nts.diagnosticMap.set(program, diagnostics);\n" +
        restCode.substr(pos);
};
/* ********************************************************************************************************************
 * Patch
 * ********************************************************************************************************************/
/**
 * Patch TypeScript Module
 */
function patchTSModule(tsModule, tsPackage) {
    validate(tsModule, tsPackage);
    var filename = tsModule.filename, file = tsModule.file, dir = tsModule.dir;
    /* Install patch */
    var isTSC = (filename === 'tsc.js');
    var patchSrc = generatePatch(isTSC);
    /* Add diagnostic modification support */
    var moduleSrc = patchModule(tsModule);
    try {
        if (isTSC) {
            /* Select non-patched typescript.js */
            var tsFile = [
                path_1.default.join(tsPackage.packageDir, actions_1.BACKUP_DIRNAME, 'typescript.js'),
                path_1.default.join(tsPackage.libDir, 'typescript.js')
            ]
                .filter(function (f) { return fs_1.default.existsSync(f); })[0];
            /* Expand TSC with full typescript library (splice tsc part on top of typescript.ts code) */
            fs_1.default.writeFileSync(file, Buffer.concat([
                Buffer.from(patchModule(tsModule, fs_1.default.readFileSync(tsFile, 'utf-8'))),
                Buffer.from(!file_utils_1.getTSModule(tsFile).patchVersion ? patchSrc : ''),
                Buffer.from(moduleSrc.replace(/^[\s\S]+(\(function \(ts\) {\s+function countLines[\s\S]+)$/, '$1'))
            ]));
        }
        else
            fs_1.default.writeFileSync(file, Buffer.concat([
                Buffer.from(moduleSrc),
                Buffer.from(patchSrc)
            ]));
    }
    catch (e) {
        throw new system_1.FileWriteError(filename, e.message);
    }
    /* Patch d.ts with types (if module is typescript.ts) */
    if (filename === 'typescript.js') {
        var targetFile = path_1.default.join(dir, 'typescript.d.ts');
        var backupFile = path_1.default.join(tsPackage.packageDir, actions_1.BACKUP_DIRNAME, 'typescript.d.ts');
        try {
            if (fs_1.default.existsSync(backupFile))
                fs_1.default.writeFileSync(targetFile, fs_1.default.readFileSync(backupFile, 'utf-8') + dtsPatchSrc);
            else
                fs_1.default.appendFileSync(targetFile, dtsPatchSrc);
        }
        catch (e) {
            throw new system_1.FileWriteError(filename, e.message);
        }
    }
}
exports.patchTSModule = patchTSModule;
//# sourceMappingURL=patcher.js.map