## Modules

<dl>
<dt><a href="#module_utils/array">utils/array</a></dt>
<dd><p>Helpers for working with arrays.</p>
</dd>
<dt><a href="#module_utils/equality">utils/equality</a></dt>
<dd><p>Utilities for equality checks.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#formats">formats</a></dt>
<dd><p>Object whose keys defines all the formats understood by the expression system.
All the formats defined here are applied e.g. constant values automatically.
Other format keywords may be used as well but the expression system does not
understand their structure.</p>
<p>Some formats are based on the implementations here:
<a href="https://github.com/epoberezkin/ajv/blob/d5edde43752e8c1bdb26074402452a41fe0742cb/lib/compile/formats.js">https://github.com/epoberezkin/ajv/blob/d5edde43752e8c1bdb26074402452a41fe0742cb/lib/compile/formats.js</a></p>
</dd>
<dt><a href="#reservedKeywords">reservedKeywords</a></dt>
<dd><p>List of reserved keywords in any schema object.
Not all of them are supported, but they might still be reserved
for future use.</p>
</dd>
<dt><a href="#annotationKeywords">annotationKeywords</a></dt>
<dd><p>List of some of the known annotation keywords.
Basically any non-reserved keyword is a valid annotation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#getArrayItemSchema">getArrayItemSchema(schema)</a></dt>
<dd><p>Resolves the schema of items in the array described by the given schema.
Returns null if the given parameter does not represent an array of items.</p>
</dd>
<dt><a href="#getBlankValueForSchema">getBlankValueForSchema(schema)</a></dt>
<dd><p>Returns a &quot;blank&quot; or &quot;empty&quot; value that matches the given schema:</p>
<ul>
<li>for strings this is an empty string</li>
<li>for booleans this is false</li>
<li>for numbers this is 0</li>
<li>for arrays this is an empty array</li>
<li>for objects this is an object with blank values for all properties</li>
</ul>
</dd>
<dt><a href="#getConstantSchema">getConstantSchema(value)</a></dt>
<dd><p>Returns a schema as explicit as possible for the given actual value.</p>
</dd>
<dt><a href="#detectValueSchema">detectValueSchema(value, defaultSchema)</a></dt>
<dd><p>Returns a simplified schema for the given actual value.</p>
</dd>
<dt><a href="#getExampleValues">getExampleValues(schema, force)</a></dt>
<dd><p>Returns an array of example values for the given schema.
If the schema defines <code>examples</code>, then those are returned.
Alternatively this builds an array of examples using the <code>enum</code>,
<code>default</code> and <code>format</code> properties of the schema. If no examples
can be found, then an empty array is returned.</p>
<p>If the schema is a combination schema, then the example values
are collected from sub-schemas.</p>
<p>Note that this function assumes immutability and it is not safe to mutate
the returned array of its contents! Please clone the returned value if
you are planning to mutate the results!</p>
<p>If optional second parameter is true, then this attempts to return at least
one example value even if the schema does not include any information what
kind of values the schema could contain. For example, for &quot;string&quot; types it
includes a blank string, for &quot;number&quot; type it includes zero (0), and for &quot;json&quot;
type it includes an empty object.</p>
</dd>
<dt><a href="#extractSchema">extractSchema(sourceSchema, targetSchema)</a></dt>
<dd><p>Constructs a type schema by extracting from the source schema all (sub)types that are
overlapping (compatible) with the target schema. Returns <code>null</code> if the two schemas
are not overlapping.</p>
</dd>
<dt><a href="#detectStringFormats">detectStringFormats(str)</a></dt>
<dd><p>Returns all the known formats to which the given string matches.</p>
</dd>
<dt><a href="#getValueValidationErrors">getValueValidationErrors(value, schema)</a></dt>
<dd><p>Validates the given value against the schema, and returns an array of validation errors.
If the returned array is empty, then the value matches the given schema!</p>
</dd>
<dt><a href="#getIntersectionSchema">getIntersectionSchema(schemas)</a></dt>
<dd><p>Combines the given schemas to an intersection schema that only matches
if all the original schemas match. Returns <code>null</code> if some of the given
schemas are incompatible so that there is no common schema. Otherwise
returns a valid schema object.</p>
</dd>
<dt><a href="#combineSchemaIntersection">combineSchemaIntersection(sourceSchema, targetSchema)</a></dt>
<dd><p>Builds an intersection of the two given schemas so that the returned
schema matches both of them.</p>
</dd>
<dt><a href="#pickAnnotations">pickAnnotations(schema)</a></dt>
<dd><p>Returns an object containing those properties of the given schema
that are not reserved validation-related keywords (<code>type</code>, <code>format</code>, etc.).
In other words, it only picks annotation keywords (<code>title</code>, <code>description</code>, etc.)
including any custom annotation keywords.</p>
</dd>
<dt><a href="#omitAnnotations">omitAnnotations(schema)</a></dt>
<dd><p>Returns an object containing only validation-related keywords of the given
schema (<code>type</code>, <code>format</code>, etc.). In other words, ignore all annotation
keywords (<code>title</code>, <code>description</code>, etc.) including any custom annotation keywords.</p>
</dd>
<dt><a href="#getSchemaAnnotation">getSchemaAnnotation(schema, annotationName)</a></dt>
<dd><p>Returns an annotation property of the given schema.
If the schema is a combination schema, the property is looked from
sub-schemas secondarily.</p>
</dd>
<dt><a href="#getMinimalAssignableSchema">getMinimalAssignableSchema(schema)</a> ⇒ <code>Schema</code></dt>
<dd><p>Returns minimal schema that is assignable to given schema. All fields in the returned schema
are required and all nested fields in objects as well. Basic schemas are returned as is.
All annotations are removed from the schema.</p>
</dd>
<dt><a href="#normalizeSchema">normalizeSchema(schema)</a> ⇒</dt>
<dd><p>Normalizes schema object to the recommended format.</p>
</dd>
<dt><a href="#resolveObjectMemberAccessor">resolveObjectMemberAccessor(operandSchema, accessorSchema, tolerant)</a></dt>
<dd><p>Resolves the result schema when accessing a property of the value, described by the
given schema, using the given accessor schema. Returns an object with two
properties: <code>schema</code> is the result schema and <code>errors</code> is an array of any errors
with the accessor operation.</p>
</dd>
<dt><a href="#getObjectPropertySchema">getObjectPropertySchema(schema, propertyName, tolerant)</a></dt>
<dd><p>An useful shortcut to resolve a type for an property of an object, represented
by the given schema. Same than calling <code>resolveObjectMemberAccessor</code> using
a constant string type as an accessor schema.</p>
</dd>
<dt><a href="#getPossibleObjectSchemaProperties">getPossibleObjectSchemaProperties(schema)</a></dt>
<dd><p>Returns an array of properties that the object represented by the schema can
possibly have. Note that in case of union (<code>anyOf</code>) types, not all the returned
properties are valid for every type.</p>
<p>If the schema (or any of its allowed schemas) is not an object, or do not have
known properties, then this returns null.</p>
</dd>
<dt><a href="#getRequiredObjectSchemaProperties">getRequiredObjectSchemaProperties(schema)</a></dt>
<dd><p>Returns an array of properties that the object represented by the schema
always has. This is a subset of properties returned by getPossibleObjectSchemaProperties.</p>
<p>If the schema (or any of its allowed schemas) is not an object, then this returns null.
If the schema is an object without known properties, returns an empty array.</p>
</dd>
<dt><a href="#pickObjectSchemaProperties">pickObjectSchemaProperties(schema, propertyNames)</a> ⇒ <code>Object</code></dt>
<dd><p>Takes a schema representing an object and returns an altered
schema for object that only includes the given property names.
All other properties from the original schema are omitted.
This also correctly handles union and intersection types.</p>
<p>NOTE: The ordering of the keys will be altered to equal the given property name list!</p>
</dd>
<dt><a href="#omitObjectSchemaProperties">omitObjectSchemaProperties(schema, propertyNames)</a> ⇒ <code>Object</code></dt>
<dd><p>Takes a schema representing an object and returns an altered
schema for object that does not contain the given property names,
but contains all the other existing properties.
This also correctly handles union and intersection types.</p>
</dd>
<dt><a href="#setRequiredObjectSchemaProperty">setRequiredObjectSchemaProperty(schema, propertyName, propertySchema)</a> ⇒ <code>Object</code></dt>
<dd><p>Takes a schema representing an object and returns an altered
schema for object that has a required property with the given name
and the given schema as its schema. If the schema already defines
a property of the same name, it will be overridden (and made required).
This also correctly handles union and intersection types.</p>
</dd>
<dt><a href="#setOptionalObjectSchemaProperty">setOptionalObjectSchemaProperty(schema, propertyName, propertySchema)</a> ⇒ <code>Object</code></dt>
<dd><p>Takes a schema representing an object and returns an altered
schema for object that has a required property with the given name
and the given schema as its schema. If the schema already defines
a property of the same name, it will be overridden (and made required).
This also correctly handles union and intersection types.</p>
</dd>
<dt><a href="#setRequiredObjectSchemaProperties">setRequiredObjectSchemaProperties(schema, requiredPropertyNames)</a> ⇒ <code>Object</code></dt>
<dd><p>Takes a schema representing an object and returns an altered
schema for object that has all the given property names marked as required.
All other properties will become optional. You should only use existing property names.
This also correctly handles union and intersection types.</p>
</dd>
<dt><a href="#idenfitySchemas">idenfitySchemas(modelSchema, actualSchema)</a></dt>
<dd><p>Determines a concrete schema for each <code>$id</code> marked schema in the given
<code>modelSchema</code>, using the given <code>actualSchema</code>. Returns an object where
keys are the <code>$id</code> values found, and values are the resolved schemas,
or <code>null</code> values if could not be resolved.</p>
</dd>
<dt><a href="#resolveSchemaReferences">resolveSchemaReferences(schema, references, defaultSchema)</a></dt>
<dd><p>Replaces the schema or its sub-schemas with <code>$ref</code> to another schema,
using the given mapping object (which should have identifiers as keys and schemas as values).
Any unknown references are replaced with unknown types.</p>
</dd>
<dt><a href="#simplifySchema">simplifySchema(schema, defaultSchema)</a></dt>
<dd><p>Returns a simplified version of the given schema. A &quot;simplified&quot; schema…</p>
<ul>
<li>has no combination types (<code>anyOf</code> or <code>allOf</code>)</li>
<li>has no enums</li>
<li>has no <code>blank</code> string format</li>
</ul>
</dd>
<dt><a href="#traverseSchema">traverseSchema(schema, iteratee)</a></dt>
<dd><p>Traverses through the given schema and its subschemas recursively calling the
given function for each schema. The function should either return the original
schema object, or a schema replacement schema, in which case the current schema
or sub-schema is replaced with the new object. No recursion is done with the replacement.</p>
</dd>
<dt><a href="#replaceSchemaTypes">replaceSchemaTypes(schema, replacements)</a></dt>
<dd><p>Replaces any type of or within the given schema using the given replacements.
This allows using type aliases in your schema which you can then replace to
some concrete schemas. For example, by providing this schema:</p>
<pre><code>{type: &#39;array&#39;, items: {type: &#39;person&#39;}}
</code></pre>
<p>And giving these replacements:</p>
<pre><code>{person: {type: &#39;object&#39;, properties: {name: {type: &#39;string&#39;}}}}
</code></pre>
<p>The result would be:</p>
<pre><code>{type: &#39;array&#39;: items: {type: &#39;object&#39;, properties: {name: {type: &#39;string&#39;}}}}}
</code></pre>
<p>NOTE: Types &#39;object&#39; and &#39;array&#39; cannot be replaced!</p>
</dd>
<dt><a href="#getUnionSchema">getUnionSchema(schemas, simplify)</a></dt>
<dd><p>Returns an union schema of the all given schemas.
If the array is empty, then returns null.</p>
</dd>
<dt><a href="#getSchemaAssignmentErrors">getSchemaAssignmentErrors(fromSchema, toSchema, options)</a></dt>
<dd><p>Returns an array of error messages if the first schema is not assignable to the second schema,
or an empty array if the first schema is assignable to the second.</p>
</dd>
<dt><a href="#isSchemaAssignable">isSchemaAssignable(fromSchema, toSchema, options)</a></dt>
<dd><p>Returns an array of error messages if the first schema is not assignable to the second schema,
or an empty array if the first schema is assignable to the second.</p>
</dd>
<dt><a href="#isSubsetSchema">isSubsetSchema(subSchema, superSchema, allowEquality)</a></dt>
<dd><p>Returns whether or not the first schema is a subset of the second one.</p>
</dd>
<dt><a href="#resolveMetaSchema">resolveMetaSchema(schema)</a> ⇒ <code>Object</code></dt>
<dd><p>When given a schema with type &quot;schema&quot; or a schema that might represent a valid schema
then resolves the meta schema of that schema (from <code>schema</code> property).
Returns an object with two properties <code>schema</code> and <code>errors</code>.</p>
</dd>
</dl>

<a name="module_utils/array"></a>

## utils/array
Helpers for working with arrays.


* [utils/array](#module_utils/array)
    * [~indexOfValue(array, value)](#module_utils/array..indexOfValue) ⇒ <code>number</code>
    * [~includesValue(array, value)](#module_utils/array..includesValue) ⇒ <code>boolean</code>
    * [~immutableMap(array, callback)](#module_utils/array..immutableMap) ⇒ <code>Array</code>
    * [~addUnionValues(results, ...arrays)](#module_utils/array..addUnionValues) ⇒ <code>Array</code>
    * [~unionValues(...arrays)](#module_utils/array..unionValues) ⇒ <code>Array</code>
    * [~intersectionValues(...arrays)](#module_utils/array..intersectionValues) ⇒ <code>Array</code>
    * [~combinations(optionArrays)](#module_utils/array..combinations) ⇒ <code>Array</code>
    * [~pickEvenly(values, count)](#module_utils/array..pickEvenly) ⇒ <code>Array</code>
    * [~performSort(array, direction, key, caseSensitive)](#module_utils/array..performSort) ⇒ <code>Array</code>
    * [~sort(array, direction, key, caseSensitive)](#module_utils/array..sort) ⇒ <code>Array</code>
    * [~performFilter(array, criteria)](#module_utils/array..performFilter) ⇒ <code>Array</code>
    * [~median(array)](#module_utils/array..median) ⇒ <code>\*</code>
    * [~repeat(item, count)](#module_utils/array..repeat) ⇒ <code>Array</code>

<a name="module_utils/array..indexOfValue"></a>

### utils/array~indexOfValue(array, value) ⇒ <code>number</code>
Returns the first index of the value in the array that would equal to the
given value.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>number</code> - index of the value in the array, or -1 if not found  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | array of values |
| value | <code>\*</code> | value to search from the array |

<a name="module_utils/array..includesValue"></a>

### utils/array~includesValue(array, value) ⇒ <code>boolean</code>
Returns whether or not a value equal to the given one is found
from the given array.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>boolean</code> - whether the value exists in the array or not  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | array of values |
| value | <code>\*</code> | value to search from the array |

<a name="module_utils/array..immutableMap"></a>

### utils/array~immutableMap(array, callback) ⇒ <code>Array</code>
Performs a map operation similar to the `Array.map` except that
it returns the original array if the map would result in exact items
with the original array.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of mapped values  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | array of values |
| callback | <code>function</code> | mapping function |

<a name="module_utils/array..addUnionValues"></a>

### utils/array~addUnionValues(results, ...arrays) ⇒ <code>Array</code>
Mutates the first given array parameter by adding
all the values from the following parameter arrays that
do not exist in the original array.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of unique values  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Array</code> | result array |
| ...arrays | <code>Array</code> | arrays of added values |

<a name="module_utils/array..unionValues"></a>

### utils/array~unionValues(...arrays) ⇒ <code>Array</code>
Returns an array containing unique values
from each of the given arrays.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of union values  

| Param | Type | Description |
| --- | --- | --- |
| ...arrays | <code>Array</code> | arrays of values |

<a name="module_utils/array..intersectionValues"></a>

### utils/array~intersectionValues(...arrays) ⇒ <code>Array</code>
Returns values that exist in each of the given array.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of intersection values  

| Param | Type | Description |
| --- | --- | --- |
| ...arrays | <code>Array</code> | arrays of values |

<a name="module_utils/array..combinations"></a>

### utils/array~combinations(optionArrays) ⇒ <code>Array</code>
Returns all possible combinations from the given arrays of arrays.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of all combinations  

| Param | Type | Description |
| --- | --- | --- |
| optionArrays | <code>Array</code> | array of arrays |

<a name="module_utils/array..pickEvenly"></a>

### utils/array~pickEvenly(values, count) ⇒ <code>Array</code>
Ensures that the given array is no larger than the given count.
If the array is larger, then returns an array where existing values
are picked as evenly as possible from the original array. Otherwise
returns the original array.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of max `count` items  

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array</code> | array of values |
| count | <code>number</code> | max number of items |

<a name="module_utils/array..performSort"></a>

### utils/array~performSort(array, direction, key, caseSensitive) ⇒ <code>Array</code>
Sorts the given array of items. If the iteratee function is provided,
then this is called for each item and those values are compared.
The sort is stable: equal items preserve their original order (even if descending).
The return value is an array of special slot objects with the following properties:
- "item" the value from the original array
- "index" the original index
- "key" the value used to compare the items

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - sorted slots  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | items to sort |
| direction | <code>string</code> | either "asc" or "desc" |
| key | <code>function</code> | function returning the key for each item to compare, or a key name |
| caseSensitive | <code>boolean</code> | whether to use case-sensitive sorting |

<a name="module_utils/array..sort"></a>

### utils/array~sort(array, direction, key, caseSensitive) ⇒ <code>Array</code>
Sorts the given array of items. If the iteratee function is provided,
then this is called for each item and those values are compared.
The sort is stable: equal items preserve their original order (even if descending).
The return value is an array of special slot objects with the following properties:
- "item" the value from the original array
- "index" the original index
- "key" the value used to compare the items

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - sorted items  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | items to sort |
| direction | <code>string</code> | either "asc" or "desc" |
| key | <code>function</code> | function returning the key for each item to compare, or a key name |
| caseSensitive | <code>boolean</code> | whether to use case-sensitive sorting |

<a name="module_utils/array..performFilter"></a>

### utils/array~performFilter(array, criteria) ⇒ <code>Array</code>
Filters the given array of items, similar to `filter` method, but instead
of returning an array of filtered items, it returns an array of slot objects
containing information about the indexes at the original array::
- "item" the value from the original array
- "index" the original index

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - filtered item slots  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | items to sort |
| criteria | <code>function</code> | function for selecting items |

<a name="module_utils/array..median"></a>

### utils/array~median(array) ⇒ <code>\*</code>
Returns the median of the given array of sortable values.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>\*</code> - median value  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array</code> | array of sortable values |

<a name="module_utils/array..repeat"></a>

### utils/array~repeat(item, count) ⇒ <code>Array</code>
Returns an array containing the given value repeated the
given number of times.

**Kind**: inner method of [<code>utils/array</code>](#module_utils/array)  
**Returns**: <code>Array</code> - array of repeated item  

| Param | Type | Description |
| --- | --- | --- |
| item | <code>\*</code> | any value |
| count | <code>number</code> | how many times to repeat the value |

<a name="module_utils/equality"></a>

## utils/equality
Utilities for equality checks.


* [utils/equality](#module_utils/equality)
    * [~isEqual(value1, value2)](#module_utils/equality..isEqual) ⇒ <code>boolean</code>
    * [~isSame(value1, value2)](#module_utils/equality..isSame) ⇒ <code>boolean</code>

<a name="module_utils/equality..isEqual"></a>

### utils/equality~isEqual(value1, value2) ⇒ <code>boolean</code>
Performs a proper equality check whether the two given values
are considered equal. This is basically a wrapper around Lodash.isEqual

**Kind**: inner method of [<code>utils/equality</code>](#module_utils/equality)  
**Returns**: <code>boolean</code> - whether or not values are equal  

| Param | Type | Description |
| --- | --- | --- |
| value1 | <code>\*</code> | first value |
| value2 | <code>\*</code> | second value |

<a name="module_utils/equality..isSame"></a>

### utils/equality~isSame(value1, value2) ⇒ <code>boolean</code>
Returns whether or not the values are the same.

**Kind**: inner method of [<code>utils/equality</code>](#module_utils/equality)  
**Returns**: <code>boolean</code> - whether or not the values are the same  

| Param | Type | Description |
| --- | --- | --- |
| value1 | <code>\*</code> | first value |
| value2 | <code>\*</code> | second value |

<a name="formats"></a>

## formats
Object whose keys defines all the formats understood by the expression system.
All the formats defined here are applied e.g. constant values automatically.
Other format keywords may be used as well but the expression system does not
understand their structure.

Some formats are based on the implementations here:
https://github.com/epoberezkin/ajv/blob/d5edde43752e8c1bdb26074402452a41fe0742cb/lib/compile/formats.js

**Kind**: global constant  
<a name="reservedKeywords"></a>

## reservedKeywords
List of reserved keywords in any schema object.
Not all of them are supported, but they might still be reserved
for future use.

**Kind**: global constant  
<a name="annotationKeywords"></a>

## annotationKeywords
List of some of the known annotation keywords.
Basically any non-reserved keyword is a valid annotation.

**Kind**: global constant  
<a name="getArrayItemSchema"></a>

## getArrayItemSchema(schema)
Resolves the schema of items in the array described by the given schema.
Returns null if the given parameter does not represent an array of items.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | array schema |

<a name="getBlankValueForSchema"></a>

## getBlankValueForSchema(schema)
Returns a "blank" or "empty" value that matches the given schema:

- for strings this is an empty string
- for booleans this is false
- for numbers this is 0
- for arrays this is an empty array
- for objects this is an object with blank values for all properties

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema to which the value must match |

<a name="getConstantSchema"></a>

## getConstantSchema(value)
Returns a schema as explicit as possible for the given actual value.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>\*</code> | value for which the schema is built |

<a name="detectValueSchema"></a>

## detectValueSchema(value, defaultSchema)
Returns a simplified schema for the given actual value.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>\*</code> | value for which the schema is built |
| defaultSchema | <code>object</code> | schema to default on null/undefined schemas |

<a name="getExampleValues"></a>

## getExampleValues(schema, force)
Returns an array of example values for the given schema.
If the schema defines `examples`, then those are returned.
Alternatively this builds an array of examples using the `enum`,
`default` and `format` properties of the schema. If no examples
can be found, then an empty array is returned.

If the schema is a combination schema, then the example values
are collected from sub-schemas.

Note that this function assumes immutability and it is not safe to mutate
the returned array of its contents! Please clone the returned value if
you are planning to mutate the results!

If optional second parameter is true, then this attempts to return at least
one example value even if the schema does not include any information what
kind of values the schema could contain. For example, for "string" types it
includes a blank string, for "number" type it includes zero (0), and for "json"
type it includes an empty object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema definition object |
| force | <code>boolean</code> | whether to attempt to force-generate at least 1 value |

<a name="extractSchema"></a>

## extractSchema(sourceSchema, targetSchema)
Constructs a type schema by extracting from the source schema all (sub)types that are
overlapping (compatible) with the target schema. Returns `null` if the two schemas
are not overlapping.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| sourceSchema | <code>object</code> | source schema |
| targetSchema | <code>object</code> | target schema |

<a name="detectStringFormats"></a>

## detectStringFormats(str)
Returns all the known formats to which the given string matches.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> | string value |

<a name="getValueValidationErrors"></a>

## getValueValidationErrors(value, schema)
Validates the given value against the schema, and returns an array of validation errors.
If the returned array is empty, then the value matches the given schema!

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>\*</code> | any value |
| schema | <code>object</code> | schema definition |

<a name="getIntersectionSchema"></a>

## getIntersectionSchema(schemas)
Combines the given schemas to an intersection schema that only matches
if all the original schemas match. Returns `null` if some of the given
schemas are incompatible so that there is no common schema. Otherwise
returns a valid schema object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schemas | <code>array</code> | schemas to combine |

<a name="combineSchemaIntersection"></a>

## combineSchemaIntersection(sourceSchema, targetSchema)
Builds an intersection of the two given schemas so that the returned
schema matches both of them.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| sourceSchema | <code>object</code> | the first schema |
| targetSchema | <code>object</code> | the second schema |

<a name="pickAnnotations"></a>

## pickAnnotations(schema)
Returns an object containing those properties of the given schema
that are not reserved validation-related keywords (`type`, `format`, etc.).
In other words, it only picks annotation keywords (`title`, `description`, etc.)
including any custom annotation keywords.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |

<a name="omitAnnotations"></a>

## omitAnnotations(schema)
Returns an object containing only validation-related keywords of the given
schema (`type`, `format`, etc.). In other words, ignore all annotation
keywords (`title`, `description`, etc.) including any custom annotation keywords.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |

<a name="getSchemaAnnotation"></a>

## getSchemaAnnotation(schema, annotationName)
Returns an annotation property of the given schema.
If the schema is a combination schema, the property is looked from
sub-schemas secondarily.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |
| annotationName | <code>string</code> | name of the annotation property |

<a name="getMinimalAssignableSchema"></a>

## getMinimalAssignableSchema(schema) ⇒ <code>Schema</code>
Returns minimal schema that is assignable to given schema. All fields in the returned schema
are required and all nested fields in objects as well. Basic schemas are returned as is.
All annotations are removed from the schema.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Schema</code> | schema to assign to |

<a name="normalizeSchema"></a>

## normalizeSchema(schema) ⇒
Normalizes schema object to the recommended format.

**Kind**: global function  
**Returns**: normalized schema object  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |

<a name="resolveObjectMemberAccessor"></a>

## resolveObjectMemberAccessor(operandSchema, accessorSchema, tolerant)
Resolves the result schema when accessing a property of the value, described by the
given schema, using the given accessor schema. Returns an object with two
properties: `schema` is the result schema and `errors` is an array of any errors
with the accessor operation.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| operandSchema | <code>object</code> | Schema of the value whose property is being accessed |
| accessorSchema | <code>object</code> | Schema of the accessor (the property to get) |
| tolerant | <code>boolean</code> | if true, then treat unknown values as wildcards |

<a name="getObjectPropertySchema"></a>

## getObjectPropertySchema(schema, propertyName, tolerant)
An useful shortcut to resolve a type for an property of an object, represented
by the given schema. Same than calling `resolveObjectMemberAccessor` using
a constant string type as an accessor schema.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |
| propertyName | <code>string</code> | name of the property |
| tolerant | <code>boolean</code> | if true, then treat unknown values as wildcards |

<a name="getPossibleObjectSchemaProperties"></a>

## getPossibleObjectSchemaProperties(schema)
Returns an array of properties that the object represented by the schema can
possibly have. Note that in case of union (`anyOf`) types, not all the returned
properties are valid for every type.

If the schema (or any of its allowed schemas) is not an object, or do not have
known properties, then this returns null.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |

<a name="getRequiredObjectSchemaProperties"></a>

## getRequiredObjectSchemaProperties(schema)
Returns an array of properties that the object represented by the schema
always has. This is a subset of properties returned by getPossibleObjectSchemaProperties.

If the schema (or any of its allowed schemas) is not an object, then this returns null.
If the schema is an object without known properties, returns an empty array.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |

<a name="pickObjectSchemaProperties"></a>

## pickObjectSchemaProperties(schema, propertyNames) ⇒ <code>Object</code>
Takes a schema representing an object and returns an altered
schema for object that only includes the given property names.
All other properties from the original schema are omitted.
This also correctly handles union and intersection types.

NOTE: The ordering of the keys will be altered to equal the given property name list!

**Kind**: global function  
**Returns**: <code>Object</code> - new schema representing an object with the picked properties  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Object</code> | schema representing an object |
| propertyNames | <code>Array</code> | list of picked property names |

<a name="omitObjectSchemaProperties"></a>

## omitObjectSchemaProperties(schema, propertyNames) ⇒ <code>Object</code>
Takes a schema representing an object and returns an altered
schema for object that does not contain the given property names,
but contains all the other existing properties.
This also correctly handles union and intersection types.

**Kind**: global function  
**Returns**: <code>Object</code> - new schema representing an object without the omitted properties  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Object</code> | schema representing an object |
| propertyNames | <code>Array</code> | list of omitted property names |

<a name="setRequiredObjectSchemaProperty"></a>

## setRequiredObjectSchemaProperty(schema, propertyName, propertySchema) ⇒ <code>Object</code>
Takes a schema representing an object and returns an altered
schema for object that has a required property with the given name
and the given schema as its schema. If the schema already defines
a property of the same name, it will be overridden (and made required).
This also correctly handles union and intersection types.

**Kind**: global function  
**Returns**: <code>Object</code> - new schema representing an object with the property  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Object</code> | schema representing an object |
| propertyName | <code>string</code> | name of the property |
| propertySchema | <code>Object</code> | schema for the property value |

<a name="setOptionalObjectSchemaProperty"></a>

## setOptionalObjectSchemaProperty(schema, propertyName, propertySchema) ⇒ <code>Object</code>
Takes a schema representing an object and returns an altered
schema for object that has a required property with the given name
and the given schema as its schema. If the schema already defines
a property of the same name, it will be overridden (and made required).
This also correctly handles union and intersection types.

**Kind**: global function  
**Returns**: <code>Object</code> - new schema representing an object with the property  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Object</code> | schema representing an object |
| propertyName | <code>string</code> | name of the property |
| propertySchema | <code>Object</code> | schema for the property value |

<a name="setRequiredObjectSchemaProperties"></a>

## setRequiredObjectSchemaProperties(schema, requiredPropertyNames) ⇒ <code>Object</code>
Takes a schema representing an object and returns an altered
schema for object that has all the given property names marked as required.
All other properties will become optional. You should only use existing property names.
This also correctly handles union and intersection types.

**Kind**: global function  
**Returns**: <code>Object</code> - new schema representing an object with the required properties  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Object</code> | schema representing an object |
| requiredPropertyNames | <code>Array</code> | list of required property names |

<a name="idenfitySchemas"></a>

## idenfitySchemas(modelSchema, actualSchema)
Determines a concrete schema for each `$id` marked schema in the given
`modelSchema`, using the given `actualSchema`. Returns an object where
keys are the `$id` values found, and values are the resolved schemas,
or `null` values if could not be resolved.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| modelSchema | <code>object</code> | Schema with possible `$id` schemas |
| actualSchema | <code>object</code> | Schema used to resolve the identified schemas |

<a name="resolveSchemaReferences"></a>

## resolveSchemaReferences(schema, references, defaultSchema)
Replaces the schema or its sub-schemas with `$ref` to another schema,
using the given mapping object (which should have identifiers as keys and schemas as values).
Any unknown references are replaced with unknown types.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | Schema to resolve |
| references | <code>object</code> | Mapping of schemas by their $id |
| defaultSchema | <code>object</code> | Schema to use when no matching $id is found |

<a name="simplifySchema"></a>

## simplifySchema(schema, defaultSchema)
Returns a simplified version of the given schema. A "simplified" schema…

- has no combination types (`anyOf` or `allOf`)
- has no enums
- has no `blank` string format

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object to simplify |
| defaultSchema | <code>object</code> | schema to default on null/undefined schemas |

<a name="traverseSchema"></a>

## traverseSchema(schema, iteratee)
Traverses through the given schema and its subschemas recursively calling the
given function for each schema. The function should either return the original
schema object, or a schema replacement schema, in which case the current schema
or sub-schema is replaced with the new object. No recursion is done with the replacement.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |
| iteratee | <code>object</code> | function to call for each sub-schema |

<a name="replaceSchemaTypes"></a>

## replaceSchemaTypes(schema, replacements)
Replaces any type of or within the given schema using the given replacements.
This allows using type aliases in your schema which you can then replace to
some concrete schemas. For example, by providing this schema:

    {type: 'array', items: {type: 'person'}}

And giving these replacements:

    {person: {type: 'object', properties: {name: {type: 'string'}}}}

The result would be:

    {type: 'array': items: {type: 'object', properties: {name: {type: 'string'}}}}}

NOTE: Types 'object' and 'array' cannot be replaced!

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>object</code> | schema object |
| replacements | <code>object</code> | mapping of replacement schemas by their type names |

<a name="getUnionSchema"></a>

## getUnionSchema(schemas, simplify)
Returns an union schema of the all given schemas.
If the array is empty, then returns null.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| schemas | <code>array</code> | array of schemas to combine |
| simplify | <code>boolean</code> | whether or not to find common shared schema |

<a name="getSchemaAssignmentErrors"></a>

## getSchemaAssignmentErrors(fromSchema, toSchema, options)
Returns an array of error messages if the first schema is not assignable to the second schema,
or an empty array if the first schema is assignable to the second.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| fromSchema | <code>Object</code> | schema to be assigned |
| toSchema | <code>Object</code> | schema to which the assignment is attempted |
| options | <code>Object</code> | options for altering the way check is done |
| options.tolerant | <code>boolean</code> | whether to allow assignment of unknown types to a known value |
| options.subset | <code>boolean</code> | whether to perform a type subset check |
| options.references | <code>Object</code> | mapping of references to schemas by their ID |

<a name="isSchemaAssignable"></a>

## isSchemaAssignable(fromSchema, toSchema, options)
Returns an array of error messages if the first schema is not assignable to the second schema,
or an empty array if the first schema is assignable to the second.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| fromSchema | <code>object</code> | schema to be assigned |
| toSchema | <code>object</code> | schema to which the assignment is attempted |
| options | <code>Object</code> | options for altering the way check is done |
| options.tolerant | <code>boolean</code> | whether to allow assignment of unknown types to a known value |
| options.subset | <code>boolean</code> | whether to perform a type subset check |

<a name="isSubsetSchema"></a>

## isSubsetSchema(subSchema, superSchema, allowEquality)
Returns whether or not the first schema is a subset of the second one.

**Kind**: global function  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| subSchema | <code>object</code> |  | sub-schema to test |
| superSchema | <code>object</code> |  | super-schema to test |
| allowEquality | <code>boolean</code> | <code>false</code> | whether or not to return true if the schemas are equal |

<a name="resolveMetaSchema"></a>

## resolveMetaSchema(schema) ⇒ <code>Object</code>
When given a schema with type "schema" or a schema that might represent a valid schema
then resolves the meta schema of that schema (from `schema` property).
Returns an object with two properties `schema` and `errors`.

**Kind**: global function  
**Returns**: <code>Object</code> - object with `schema` and `errors`  

| Param | Type | Description |
| --- | --- | --- |
| schema | <code>Object</code> | schema for a value representing a schema |
