const logger = require('../logger');
const execSync = require('child_process').execSync;
const fs = require('fs-extra');
const path = require('path');
const AdmZip = require('adm-zip');
const timestamp = require('console-timestamp');
const yamlParser = require('js-yaml');
const os = require('os');
const utils= require('../utils');
const _ = require('lodash');

let childProcessExecOption;
let COPY_FILES = ["/Images/"];
const CENTRAL_APPROUTER = "central";
const DEFAULT_TEMPLATE = {
    "id": "@ext-mdkvsc-npm-dev/generator-mdk",
    "name": "List Detail",
    "version": "0.0.1"
};
const VersionFile = "version.txt";
class Builder {
    constructor(args) {
        this.buildArgs = args;
        this.settings = {
            project: null,
            deploy: {}
        };
        childProcessExecOption = {
            stdio: 'inherit'
        }
        this.sBundleTempFolder = path.join("out", path.basename(this.buildArgs.project()));
    }
    /**
     * This is the main entry point into the build web functionality
     *
     * - collect project info
     * - validation
     * - bundle
     * - generate module
     */
    build() {
        this.isModule = (this.buildArgs.target() == utils.BUILD_TARGET.MODULE);
        console.log('[hh:mm:ss]'.timestamp + ' Start building web');
        return this._getProjectInfo()
            .then(() => this._validate())
            .then(() => this._createWeb())
            .then(() => this._syncWebFiles())
            .then(() => this._bundle())
            .then(() => {
                console.log('[hh:mm:ss]'.timestamp + `Build web successfully in ${this.buildArgs.dist()}`);
                return true;
            })
            .catch(error => {
                console.error(logger.getError(`Failed to build web with error: ${error}`));
                return Promise.reject(error);
            });
    }

    _getProjectInfo() {
        let instance = this;
        return new Promise(function (resolve, reject) {
            let sFilePath, sContent, oContent;
            try {
                sFilePath = path.join(instance.buildArgs.project(), utils.MDK_CONFIG_JSON);
                sContent = fs.readFileSync(sFilePath).toString();
                oContent = JSON.parse(sContent);
                if (oContent["CF"] && oContent["CF"]["Deploy"]) {
                    instance.settings.deploy = oContent["CF"]["Deploy"];
                }
                if (oContent["LCAP"] && oContent["LCAP"]["UserTask"]) {
                    instance.settings.usertask = oContent["LCAP"]["UserTask"];
                }
                if (oContent["LCAP"] && oContent["LCAP"]["FullName"]) {
                    instance.settings.fullName = oContent["LCAP"]["FullName"];
                }

                instance.settings.template = DEFAULT_TEMPLATE;
                if (oContent["Template"]) {
                    instance.settings.template["id"] = oContent["Template"]["Id"];
                    instance.settings.template["name"] = oContent["Template"]["Name"];
                    instance.settings.template["version"] = oContent["Template"]["Version"];
                } 
            } catch (e) {
                instance.settings.deploy = {};
            }

            if (!instance.settings.deploy["WebClient"]) {
                instance.settings.deploy["WebClient"] = {};
            }

            if (instance.buildArgs.name()) {
                instance.settings.deploy["Name"] = instance.buildArgs.name();
            }

            let runtime = instance.buildArgs.runtime();
            if (runtime) {
                if (runtime === utils.WEB_RUNTIME.PREVIEW || runtime === utils.WEB_RUNTIME.PRODUCTION) {
                    instance.settings.deploy["WebClient"]["Runtime"] = runtime;
                } else if (runtime.indexOf("https://")===0) {
                    instance.settings.deploy["WebClient"]["Runtime"] = utils.WEB_RUNTIME.DEV;
                    instance.settings.deploy["WebClient"]["URL"] = runtime;
                } else {
                    console.log("Unknown runtime type, ignore it.")
                }       
            }

            try {
                sFilePath = path.join(instance.buildArgs.project(), utils.APPLICATION_FILE);
                sContent = fs.readFileSync(sFilePath).toString();
                instance.settings.project = JSON.parse(sContent);
            } catch (e) {
                reject(e);
            }

            resolve(true);
        });
    }

    _validate() {
        return new Promise(function (resolve, reject) {
            resolve(true); //todo
        });
    }

    _bundle() {
        let instance = this;
        return new Promise(function (resolve, reject) {
            //resolve(true);//todo
            let sMDKTools = utils.getMDKTools();
            let sDistPath;
            if (instance.isModule) {
                sDistPath = path.join(instance.buildArgs.dist(), utils.WEB_TARGET_FOLDER);
            } else {
                sDistPath = path.join(instance.buildArgs.dist(), utils.WEB_MODULE_FOLDER, utils.WEB_TARGET_FOLDER);
            }
            let sProjectPath = instance.buildArgs.project();
            let sAppName = utils.getAppName(sProjectPath);
            let aExternals = instance.buildArgs.externals();
            let aFilters = [`${path.sep}Web${path.sep}`, `${path.sep}Images${path.sep}`, `${path.sep}Extensions${path.sep}`].concat(instance.buildArgs.filters());

            for (let i = 0; i < aFilters.length; i++) {
                aFilters[i] = `${path.sep}${sAppName}${aFilters[i]}`;
            }

            let sCommand = `${sMDKTools} bundle --nativescript-project "${sDistPath}" --seam-project "${sProjectPath}" `
                + `--externals ${aExternals.join(" ")} `
                + `--filters ${aFilters.join(" ")} `
                //+ `--bundle-zip-target-path "${instance.sBundleTempFolder}" `
                + `--bundle-definition-path "${instance.sBundleTempFolder}" `
                + "--devtool source-map --web";

            if (instance.buildArgs.useWmf()) {
                sCommand = `${sCommand} --wmf`;
            }
            
            try {
                console.log(sCommand);
                execSync(sCommand, childProcessExecOption);
                resolve();
            } catch (error) {
                console.error(logger.getError(`Bundle project failed with error: ${error}`));
                reject(error);
            }
        });
    }

    _createWeb() {
        if (this._shouldUpdate()) {
            return this._createWebProject().then(()=>this._addVersion());
        } else {
            return Promise.resolve();
        }
    }
    _shouldUpdate() {
        let sDistPath;
        if (this.isModule) {
            sDistPath = path.join(this.buildArgs.dist(), utils.WEB_TARGET_FOLDER);
        } else {
            sDistPath = path.join(this.buildArgs.dist(), utils.WEB_MODULE_FOLDER, utils.WEB_TARGET_FOLDER);
        }
        if (!fs.existsSync(sDistPath)) {
            return true;
        }

        const versionFilePath = path.join(this.buildArgs.dist(), VersionFile);
        if (fs.existsSync(versionFilePath)) {
           const preVersion = fs.readFileSync(versionFilePath).toString();
           const curVersion = utils.getVersion();
           return preVersion!==curVersion;
        } else {
            return true;
        }
    }

    _createWebProject() {
        let instance = this;
        const fullName = instance.settings.fullName;
        let oDeploySetting = instance.settings.deploy;
        let baseAppInfo = instance.settings.project;
        let usertaskInfo = instance.settings.usertask;
        let webProjectPath = instance.buildArgs.dist();
        let useUI5 =instance.buildArgs.ui5();
        let appVersion = oDeploySetting["Version"] ? oDeploySetting["Version"] : "1.0.0";
        let appId = oDeploySetting["Name"] ? oDeploySetting["Name"] : (fullName ? fullName : baseAppInfo._Name);
        let appId_sim = appId.split(".").pop();
        let appName = appId.replace(/\./g, '');
        let appDescription = oDeploySetting["Description"];
        let sWebClientUrl = instance._getWebRuntimeUrl(oDeploySetting);
        let isLocal = false;
        let appTemplateStr = JSON.stringify(instance.settings.template, null, "\t");
        console.log('[hh:mm:ss]'.timestamp + `Creating new web module in ${webProjectPath}...`);

        //clear previous folder
        try {
            fs.emptyDirSync(webProjectPath);
            fs.rmdir(webProjectPath);
        } catch (e) {
            console.error(logger.getError(e));
        }
        let sTemplate;
        let cloudService;
        if (instance.isModule) {
            if (useUI5) {
                if (usertaskInfo) {
                    sTemplate = "usertaskmodule.zip";
                } else {
                    sTemplate = "ui5module.zip";
                }
            } else {
                sTemplate = "webmodule.zip";
            }    
        } else {
            sTemplate = oDeploySetting["AppRouter"]===CENTRAL_APPROUTER ?  "central-router.zip" : "stand-router.zip";
            cloudService = oDeploySetting["CloudService"];
        }
        let templatePath = path.join(utils.getRootPath(),'builder', 'template', sTemplate);
        let sODataDestionConfig = JSON.stringify(instance._getOdataDestinationConfig(oDeploySetting));
        let sTitle = instance._getWebDisplayTitle(baseAppInfo._Name);
        let zip = new AdmZip(templatePath);
        let promises = [];
        let zipEntries = zip.getEntries();
        zipEntries.forEach(zipEntry => {
            if (!zipEntry.isDirectory) {
                let entryName = zipEntry.entryName;
                let targetEntryName = entryName;

                if (!instance.isModule) {
                    let arrParts = entryName.split("/");
                    let i;
                    for (i = 0; i < arrParts.length; i++) {
                        if (arrParts[i].endsWith("-approuter")) {
                            arrParts[i] = appName + "-approuter";
                        }
                    }
                    targetEntryName = arrParts.join("/");
                }

                let targetFilePath = path.join(webProjectPath, targetEntryName);

                if (targetFilePath.charAt(targetFilePath.length - 1) === path.sep) {
                    fs.ensureDirSync(targetFilePath);
                } else {
                    fs.ensureDirSync(path.dirname(targetFilePath));
                }

                let strContent = zipEntry.getData().toString();
                strContent = strContent.replace(/<APPVERSION>/g, appVersion);
                strContent = strContent.replace(/<APPID>/g, appId);
                strContent = strContent.replace(/<APPID_SIM>/g, appId_sim);
                strContent = strContent.replace(/<APPID_PATH>/g, appId.replace(/\./g, '/'));
                strContent = strContent.replace(/<APPNAME>/g, appName);

                strContent = strContent.replace(/<CLOUDSERVICE>/g, cloudService);

                strContent = strContent.replace(/<SAPURL>/g, `/${appName}`);
                strContent = strContent.replace(/<ApplicationDisplayName>/g, sTitle);
                strContent = strContent.replace(/<ApplicationDescription>/g, appDescription ? appDescription : sTitle);
                if (usertaskInfo) {
                    strContent = strContent.replace(/<USERTASK_DECISIONBUTTONS>/g, instance._formatUserTaskDecisionButtons(usertaskInfo.decisionButtons)); 
                    strContent = strContent.replace(/<CAPENTITY_KEYTYPES>/g, JSON.stringify(usertaskInfo.capEntityKeyTypes)); 
                }
                if (targetFilePath.endsWith("manifest.json")) {
                    strContent = strContent.replace(/"<TEMPLATE>"/g, appTemplateStr);
                    let oTempJson = JSON.parse(strContent);
                    strContent = JSON.stringify(oTempJson,  null, '\t');
                } else if (targetFilePath.endsWith("mta.yaml")) {
                    strContent = strContent.replace(/<DESTINATIONS>/g, instance._getPrivateDestinations(oDeploySetting));
                } else if (targetFilePath.endsWith("xs-app.json")) {
                    strContent = instance._formatRouterWithBackend(strContent, oDeploySetting);
                } else if (targetFilePath.endsWith("launch.json")) {
                    //strContent = strContent.replace(/<workspaceFolder>/g, vscode.workspace.rootPath);
                } else if (targetFilePath.endsWith(".envmdk")) {
                    strContent = strContent.replace(/<ODataDestionConfig>/g, sODataDestionConfig);
                } else if (isLocal && targetFilePath.endsWith(utils.DEPLOY_SETTING_FILE)) {
                    try {
                        let oContent = JSON.parse(strContent);
                        oContent["local"] = true;
                        strContent = JSON.stringify(oContent, null, '\t');
                    } catch (e) {
                    }
                } else if (targetFilePath.endsWith(".html") || targetFilePath.endsWith(".js")) {
                    strContent = strContent.replace(/<WebClientUrl>/g, sWebClientUrl);
                }
                promises.push(fs.writeFile(targetFilePath, strContent));
            }
        });
        return Promise.all(promises);
    }

    _addVersion() {
        const webProjectPath = this.buildArgs.dist();
        const version =utils.getVersion();
        fs.writeFileSync(path.join(webProjectPath,VersionFile),version);
    }

    
    _formatUserTaskDecisionButtons(decisionButtons) {
        let addButtonCodes = "";
        let prefix = "this.getInboxAPI().addAction(";
        let middle = ", function () {this.completeTask(\"";
        let suffix = "\");}, this);";
        if (decisionButtons) {
            for (let i = 0; i < decisionButtons.length; i++) {
                let actionObj = {action: decisionButtons[i].buttonId, label: decisionButtons[i].buttonName, type: decisionButtons[i].buttonType};
                let codes = prefix + JSON.stringify(actionObj) + middle + decisionButtons[i].buttonId + suffix;
                addButtonCodes = addButtonCodes + codes;
                if (i < decisionButtons.length - 1) {
                    addButtonCodes = addButtonCodes + "\n\t\t\t\t";
                }
            }
        }
        return addButtonCodes;
    }

    _getPrivateDestinations(oDeploySetting) {
        let ret = [];
        if (oDeploySetting["Destination"] && oDeploySetting["Destination"].length > 0) {
            for (let k = 0; k < oDeploySetting["Destination"].length; k++) {
                let sUrl = oDeploySetting["Destination"][k]["URL"];
                let sDest = oDeploySetting["Destination"][k]["CF"] ? oDeploySetting["Destination"][k]["CF"] : oDeploySetting["Destination"][k]["MDK"];
                if (sUrl && (sUrl.toLowerCase().startsWith("http:") || (sUrl.toLowerCase().startsWith("https:")))) {
                    ret.push({
                        "name": sDest,
                        "url": sUrl,
                        "forwardAuthToken": true
                    });
                }
            }
        }
        return JSON.stringify(ret);
    }

    _getOdataDestinationConfig(oDeploySetting) {
        let sCFDestination, sCFUrl;
        if (oDeploySetting["Destination"] && oDeploySetting["Destination"].length > 0) {
            sCFDestination = oDeploySetting["Destination"][0].CF ? oDeploySetting["Destination"][0].CF : oDeploySetting["Destination"][0].MDK;
            sCFUrl = oDeploySetting["Destination"][0].URL;
            if (sCFUrl) {
                return {
                    "name": sCFDestination,
                    "url": oDeploySetting["Destination"][0].URL
                }
            } else {
                return {
                    "name": sCFDestination,
                    "url": `https://${sCFDestination}.dest`,
                    "proxyHost": "http://127.0.0.1",
                    "proxyPort": "8887"
                }
            }

            return {};
        }
    }

    _syncWebFiles() {
        let instance = this;
        return new Promise(function (resolve, reject) {
            let sourceRoot = instance.buildArgs.project();
            let targetRoot = instance.buildArgs.dist();

            console.log('[hh:mm:ss]'.timestamp + `Synchronizing metadata from ${sourceRoot} to ${targetRoot}...`);
            let sourceFolder = `${sourceRoot}/${utils.WEB_SOURCE_FOLDER}`;
            let targetFolder;
            if (instance.isModule) {
                targetFolder = `${targetRoot}/${utils.WEB_TARGET_FOLDER}`;
            } else {
                targetFolder = `${targetRoot}/${utils.WEB_MODULE_FOLDER}/${utils.WEB_TARGET_FOLDER}`;
            }
            try {
                COPY_FILES.forEach(sPath => {
                    if (fs.existsSync(`${sourceRoot}${sPath}`)) {
                        fs.copySync(`${sourceRoot}${sPath}`, `${targetFolder}${sPath}`);
                    }
                });


                if (fs.existsSync(sourceFolder)) {
                    fs.readdirSync(sourceFolder).forEach(function (name) {
                        if (name === utils.WEB_MODULE_FOLDER) {
                            return;
                        }
                        let filePath = path.join(sourceFolder, name);
                        let stat = fs.statSync(filePath);
                        if (stat.isFile()) {
                            fs.copySync(filePath, `${targetFolder}/${name}`);
                        } else if (stat.isDirectory()) {
                            fs.ensureDirSync(`${targetFolder}/${name}`);
                            fs.copySync(filePath, `${targetFolder}/${name}`);
                        }
                    });
                }

                if (fs.existsSync(`${targetFolder}/xs-security.json`) && targetRoot !== sourceFolder) {
                    fs.moveSync(`${targetFolder}/xs-security.json`, `${targetRoot}/xs-security.json`, { overwrite: true });
                }

                fs.ensureDirSync(`${sourceFolder}/App_Resources`);

                let configJson = `${sourceFolder}/config.json`;
                let configJs = `${targetFolder}/config.js`;
                let sContent;
                if (fs.existsSync(configJson)) {
                    if (fs.existsSync(configJs)) {
                        // fs.removeSync(configJs);
                    }
                    sContent = fs.readFileSync(configJson).toString();
                    sContent = "var appSettings = " + sContent;
                    fs.writeFileSync(configJs, sContent);
                    // fs.removeSync(configJson);
                } else if (fs.existsSync(configJs)) {
                    sContent = fs.readFileSync(configJs).toString();
                    sContent = sContent.substring(sContent.indexOf('{'));
                    fs.writeFileSync(`${targetFolder}/config.json`, sContent);
                }
                resolve(true);
            } catch (error) {
                console.error(logger.getError(`Failed to synch web files with error: ${error}`));
                reject(error);
            }
        });
    }

    _getWebDisplayTitle(name) {
        let customizeTitle;
        let configJson = `${this.buildArgs.project()}/${utils.WEB_SOURCE_FOLDER}/config.json`;
        if (fs.existsSync(configJson)) {
            let sContent = fs.readFileSync(configJson).toString();
            try {
                let oContent = JSON.parse(sContent);
                customizeTitle = oContent["ApplicationDisplayName"];
            } catch (e) {
                customizeTitle = "";
            }
        }
        return customizeTitle ? customizeTitle : name;
    }

    _formatRouterWithBackend(strContent, oDeploySetting) {
        let oContent;
        try {
            oContent = JSON.parse(strContent);
        } catch (e) {
            console.error(logger.getError("failed to parse xs-app.json with error " + e));
            return strContent;
        }
        if (oContent && oContent.routes && oDeploySetting["Destination"]) {
            for (var i = 0; i < oDeploySetting["Destination"].length; i++) {
                let sMDK = oDeploySetting["Destination"][i].MDK;
                if (sMDK.indexOf("/") >= 0) {
                    continue; //if contains '/', it should be relative to other module.
                }
                let sCF = oDeploySetting["Destination"][i].CF ? oDeploySetting["Destination"][i].CF : sMDK;
                let oRoute = {
                    "csrfProtection": false,
                    "source": "^/" + sMDK + "/(.*)$",
                    "target": "$1",
                    "destination": sCF,
                    "authenticationType": "xsuaa"
                };
                oContent.routes.splice(0, 0, oRoute);
            }
            return JSON.stringify(oContent, null, '\t');
        }
        return strContent;
    }

    _getWebRuntimeUrl(oDeploySetting) {
        let sHost;
        const runtime = oDeploySetting["WebClient"]["Runtime"];

        if (oDeploySetting["WebClient"]["URL"] && runtime!==utils.WEB_RUNTIME.PREVIEW && runtime!==utils.WEB_RUNTIME.PRODUCTION) {
            return oDeploySetting["WebClient"]["URL"];
        } else {
            const homedir = os.homedir();
            const configFile = path.join(homedir, ".cf/config.json");
            if (fs.existsSync(configFile)) {
                let data = fs.readFileSync(configFile).toString();
                let oLogin = JSON.parse(data);
                sHost = _.get(oLogin, "Target", "");
                
            }  
            return utils.getWebRuntimeUrl(runtime, sHost);
        } 
    }
};

exports.Builder = Builder;
